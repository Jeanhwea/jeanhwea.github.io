#+TITLE: 分布式事务
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-28 Wed 08:23:51>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: distributed transaction


* 分布式事务
  分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于
  不同的分布式系统的不同节点之上
  1. 事务参与者 (APP)
     - 前端处理请求的应用
  2. 事务管理器 (TM)
     - 后台协调事务的应用
  3. 资源服务器 (RM)
     - 一般指的是数据库中的数据

* 2PC & 3PC
** 提交模型
   2PC 和 3PC 参与事务提交的处理流程如下，事务包含如下三类角色
   1. 一个业务发起方 APP
   2. 一个事务管理器 TM
   3. 三个资源管理器 RM
   #+BEGIN_SRC text
     [APP] -> [  TM  ] -> [RM_1]
                |  |
                |  +----> [RM_2]
                |
                +-------> [RM_3]
   #+END_SRC

** 2PC (two-phase-commit) 两阶段事务
   2PC 的具体的实现流程如下
   1. Prepare 阶段
      - APP 向 TM 发送请求，请求执行一个操作
      - TM 向所有参与的 RM 发送 *预请求*, RM 需要报告能否执行操作
        + TM 可以向 MQ 消息队列发送个半消息 (Half Message)
        + RM 打开本地事务，执行到待提交的阶段
        + 然后反馈能否成功执行事务
   2. Commit 阶段
      - TM 接收所有 RM 的报告
      - TM 接收到所有的报告，如果所有 RM 表示可以成功执行
        + TM 发送全局提交 (Global Commit) 信号
        + 所有 RM 提交事务
      - TM 接收到所有的报告，如果有一个 RM 表示不能成功执行
        + TM 发送全局回滚 (Global Commit) 信号
        + 所有 RM 回滚事务

   2PC 存在问题
   1. RM 的事务一直挂起可能存在 *性能问题*
   2. TM 是单点的，可能存在 *单点故障*
   3. Commit 阶段出现消息丢失会导致数据不一致

** 3PC (three-phase-commit) 三阶段事务
   3PC 在 2PC 的基础上增加了 CanCommit 阶段
   1. 增加了 *超时机制*, 可以预先判断任何 RM 是否宕机，减少超时交互的成本
   2. 有效地解决了 RM 的 *单点故障* 问题

   3PC 的具体的实现流程如下
   1. CanCommit 阶段
      - APP 向 TM 发送请求，请求执行一个操作
      - TM 向所有参与的 RM 发送 *自检操作*, 所有 RM 完成自检回复 Yes/No
        + 注意，这里 RM 并没有开启本地事务
      - 如果 TM 收到任何一个 RM 回复 No，事务操作终止
      - 如果任何一个 TM 超时，事务操作终止
   2. PreCommit 阶段
      - 在 CanCommit 阶段中 TM 都回复 Yes
      - 接着进行 PreCommit 阶段，该阶段类似 2PC 的 Prepare 阶段
      - TM 向所有参与的 RM 发送 *预请求*, RM 需要报告能否执行操作
        + 所有 RM 执行本地事务，记录 Undo/Redo 日志
        + 如果 RM 确认可以执行，向 TM 返回 ACK 确认
   3. doCommit 阶段
      - 该阶段类似于 2PC 的 Commit 阶段
      - TM 接收所有 RM 的报告
      - TM 接收到所有的报告，如果所有 RM 表示可以成功执行
        + TM 发送全局提交 (Global Commit) 信号
        + 所有 RM 提交事务
      - TM 接收到所有的报告，如果有一个 RM 表示不能成功执行
        + TM 发送全局回滚 (Global Commit) 信号
        + 所有 RM 回滚事务

* TCC (Try-Confirm-Cancel) 补偿事务
** 提交模型
   TCC 参与事务提交的处理流程如下，事务包含如下三类角色
   1. 一个业务发起方 APP
   2. 一个事务管理器 TM
   3. 三个资源管理器 RM
      - 每个 RM 需要实现 Try, Confirm, Cancel 接口
   #+BEGIN_SRC text
     [APP] ->[  TM  ]-> [RM_1]
               |  |
               |  +---> [RM_2]
               |
               +------> [RM_3]
   #+END_SRC

** TCC 三个操作说明
   1. Try 操作
      - 完成业务检查，预留业务所需的资源
   2. Confirm 操作
      - 执行业务逻辑
   3. Cancel 操作
      - 释放 Try 操作预留的业务资源

** TCC 实践案例
   1. 汇款服务
      - Try: 处理预扣款逻辑
        + 检查 A 账户的有效性
        + 检查 A 账户的余额是否充足
        + 从 A 账户中扣减 100 元，并将状态置为 "转账中"
        + 预留扣减资源，将 "从 A 账户向 B 账户转账 100 元" 这个事件存入消息或日志
      - Confirm: 不做任何操作
      - Cancel: A 账户增加 100 元；从日志或消息中释放扣减资源
   2. 收款服务
      - Try: 检查 B 账户的有效性
      - Confirm: 读取日志或者消息, B 账户增加 100 元；从日志或消息中释放扣减资源
      - Cancel: 不做任何操作

   由此可以看出，TCC 模型对业务的侵入性较强，改造的难度较大

** TCC 缺点
   1. 应用侵入性强
      - TCC 由于基于在业务层面, 开发时需要在业务层面保证事务的有效性
      - 至使每个操作都需要有 Try, Confirm, Cancel 三个接口
   2. 开发难度大
      - 代码开发量很大
      - Confirm 和 Cancel 接口还必须实现幂等性才能保证数据一致性
