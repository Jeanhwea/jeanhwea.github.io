#+TITLE: BASE 理论
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-27 Tue 18:19:44>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: BASE CAP


* BASE 理论
  [[file:cap-theorem.org][文章]]介绍了分布式系统的 C (一致性), A (可用性) 和 P (分区容错性) 只能满足其二,
  本文中的 BASE 理论是基于 CAP 定理的前提, 提出的分布式系统的折中方案。

  BASE 理论是下列三个短语的缩写
  1. Basically Available (基本可用)
  2. Soft State（软状态）
  3. Eventually Consistent（最终一致）

* 基本可用
  基本可用指系统出现了不可预知的故障, 但还是能用, 相比较正常的系统而言
  1. *响应延长*: 正常情况下的搜索引擎 0.5 秒即返回给用户结果, 而基本可用的搜索引
     擎可以在 2 秒作用返回结果
  2. *服务降级*: 在一个电商网站上, 正常情况下, 用户可以顺利完成每一笔订单。但是
     到了大促期间, 为了保护购物系统的稳定性, 部分消费者可能会被引导到一个降级页面

* 软状态
  软状态指的是允许系统中的数据存在中间状态, 并认为该状态不影响系统的整体可用性,
  即允许系统在多个不同节点的数据副本存在数据延时

  例如：订单支付后不要求马上将状态改成 *已支付*, 而是引入一个 *支付中* 这样的中
  间状态, 只有最后支付成功收到款项再将状态改成 *已支付*

* 最终一致
  上面说软状态, 然后不可能一直是软状态, 必须有个时间期限。在期限过后, 应当保证所
  有副本保持数据一致性, 从而达到数据的最终一致性。这个时间期限取决于网络延时、系
  统负载、数据复制方案设计等等因素

  而在实际工程实践中, 最终一致性分为 5 种
  1. *因果一致性* Causal Consistency
     - 如果节点 A 在更新完某个数据后通知了节点 B, 那么节点 B 之后对该数据的访问
       和修改都是基于 A 更新后的值。于此同时, 和节点 A 无因果关系的节点 C 的数据
       访问则没有这样的限制
  2. *会话一致性* Session Consistency
     - 系统能保证在同一个有效的会话中实现 Read Your Writes 的一致性, 也就是说,执
       行更新操作之后, 客户端能够在同一个会话中始终读取到该数据项的最新值
  3. *单调读* Monotonic Read Consistency
     - 如果一个节点从系统中读取出一个数据项的某个值后, 那么系统对于该节点后续的
       任何数据访问都不应该返回更旧的值
  4. *单调写* Monotonic Write Consistency
     - 一个系统要能够保证来自同一个节点的写操作被顺序的执行
  5. *读写一致性* Read Your Writes
     - 节点 A 更新一个数据后, 它自身总是能访问到自身更新过的最新值, 而不会看到旧
       值。其实也算一种因果一致性

* WARO 和 Quorum
  1. WARO (Write All Read One): 一种简单副本控制协议, 当写入多个副本时只有当所有
     副本都写入成功本次写入才算成功
  2. Quorum: 假设有 N 个副本, 更新操作 wi 在 W 个副本中更新成功之后, 则认为此次
     更新操作 wi 成功, 把这次成功提交的更新操作对应的数据叫做: "成功提交的数据"
     对于读操作而言, 至少需要读 ~R~ 个副本, 其中, ~W+R>N~, 即 W 和 R 有重叠, 一
     般, ~W+R=N+1~
     - N = 存储数据副本的数量
     - W = 更新成功所需的副本
     - R = 一次数据对象读取要访问的副本的数量
