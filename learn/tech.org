#+TITLE: 技术文档汇总
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-01-29 Sun 10:55:28>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+STARTUP: indent cache num inlineimages
#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
#+LATEX_HEADER: \usepackage[scheme=plain]{ctex}
#+BEAMER_THEME: boxes

* 学习计划
** 操作系统
*** 制作操作系统资源
1. os-tutorial 编写操作系统的入门代码 os-dev.pdf | [[https://github.com/cfenollosa/os-tutorial][link]]
2. rust 操作系统 [[https://rcore.gitbook.io/rust-os-docs/kai-fa-huan-jing-pei-zhi][rust os]] | [[https://github.com/rcore-os/rCore][rCore]]
3. Writing an OS in Rust [[https://os.phil-opp.com/zh-CN/][link]]
4. c/c++ 编写一个操作系统 [[https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-2][link]]
5. James kernel development tutorial [[http://www.jamesmolloy.co.uk/tutorial_html/index.html][link]]
6. 《x86 汇编语言：从实模式到保护模式》 [[http://www.lizhongc.com/index.php/archives/10/][BOOK]] | [[https://www.bilibili.com/video/BV1xE411N74T/?spm_id_from=333.337.search-card.all.click&vd_source=3a56932406d5df288a20eff532848982][BTV]] | [[http://www.lizhongc.com/][李忠]]
7. BUAA OS 2022 [[https://github.com/MaxLong2001/BUAA_OS_2022.git][link]]
*** 课程 [[https://pdos.csail.mit.edu/6.828/2019/index.html][MIT 6.828]]
1. riscv [[https://pdos.csail.mit.edu/6.828/2019/tools.html][工具链]]
2. 课程视频 [[https://www.bilibili.com/video/BV19k4y1C7kA][BTV]]
3. 中文课程整理 [[http://xv6.dgs.zone/][中文介绍]]
*** 实模式
**** 寄存器
| 分类         | 名称 | 全称                |
|--------------+------+---------------------|
| 通用寄存器   | AX   | Accumulator         |
| 通用寄存器   | BX   | Base                |
| 通用寄存器   | CX   | Counter             |
| 通用寄存器   | DX   | Data                |
| 指针寄存器   | SP   | Stack Pointer       |
| 指针寄存器   | BP   | Base Pointer        |
| 变地址寄存器 | SI   | Source Index        |
| 变地址寄存器 | DI   | Destination Index   |
| 控制寄存器   | IP   | Instruction Pointer |
| 控制寄存器   | FLAG | Flag                |
| 段寄存器     | CS   | Code Segment        |
| 段寄存器     | DS   | Data Segment        |
| 段寄存器     | SS   | Stack Segment       |
| 段寄存器     | ES   | Extra Segment       |

**** 栈 bp, sp
1. sp 指向栈的顶端 stack pointer
2. bp 指向栈的基地址 base pointer
3. push 操作时, sp = sp - 2, bp 不变
4. pop 操作时, sp = sp + 2, bp 不变

#+BEGIN_SRC asm
  .code16                         ; 16 bits mode

  ;;; 初始化栈指针
  mov bp, 0x8000
  mov sp, bp                      ; sp = bp 时, 栈为空

  ;;; 压入 3 个测试数据
  ;;; sp = 0x8000, bp = 0x8000
  push 'A'
  ;;; sp = 0x7ffe, bp = 0x8000
  push 'B'
  ;;; sp = 0x7ffc, bp = 0x8000
  push 'C'

  ;;; 查看数据
  mov bx, bp
  mov al, [bx-2]
  int 0x10                        ; 打印 A

  mov bx, spp
  mov al, [bx]
  int 0x10                        ; 打印 C

  ;;; 弹出数据
  pop bx
  ;;; sp = 0x7ffc, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 C

  pop bx
  ;;; sp = 0x7ffe, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 B

  pop bx
  ;;; sp = 0x8000, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 A
#+END_SRC
**** 中断
BIOS 通过中断提供一下操作硬件的基本程序，具体中断参考手册见 [[https://stanislavs.org/helppc/idx_interrupt.html][link]]

**** 分支
~jmp $~, $ 表示当前标号, 该指令会死循环

通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  cmp ax, 4      ; if ax = 4
  je ax_is_four  ; do something (by jumping to that label)
  jmp else       ; else, do another thing
  jmp endif      ; finally, resume the normal flow

  ax_is_four:
      .....
      jmp endif

  else:
      .....
      jmp endif  ; not actually necessary but printed here for completeness

  endif:
#+END_SRC

函数调用也属于简单的跳转指令, 例如
#+BEGIN_SRC asm
  mov al, 'X'
  jmp print
  endprint:

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      jmp endprint                ; 返回
#+END_SRC

由于函数调用非常常见, 会有一些指令来简化函数调用实现过程
#+BEGIN_SRC asm
  mov al, 'X'
  call print

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      ret
#+END_SRC

**** 分段
8086 寄存器是 16 位的, 真实地址 = 段地址 << 4 + address
#+BEGIN_SRC asm
  ;;; 设置 ds 段寄存器
  mov bx, 0x7c0
  mov ds, bx
  ;;; 默认使用 ds 段寄存器作为基地址
  mov al, [msg]
  int 0x10

  ;;; 使用 es 段寄存器进行寻址
  mov bx, 0x7c0
  mov es, bx
  mov al, [es:the_secret]
  int 0x10
#+END_SRC

**** 磁盘
磁盘加载数据到内存采用 CHS 的寻址方式 (cylinder-head-sector), 读取磁盘的指令需要
将 ~al~ 设置成 ~0x02~ , 通过寄存器传入起始 CHS 地址和需要读取到的扇区数量，然后
调用中断 ~int 0x13~, 其中详细的中断参数见 [[https://stanislavs.org/helppc/int_13-2.html][link]]

#+BEGIN_SRC text
  AH = 02                                        读取操作的编码
  AL = number of sectors to read	(1-128 dec.)
  CH = track/cylinder number  (0-1023 dec., see below)
  CL = sector number  (1-17 dec.)
  DH = head number  (0-15 dec.)
  DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
  ES:BX = pointer to buffer                      数据装载的内存起始地址


  on return:
  AH = status  (see INT 13,STATUS)
  AL = number of sectors read
  CF = 0 if successful
     = 1 if error


  - BIOS disk reads should be retried at least three times and the
    controller should be reset upon error detection
  - be sure ES:BX does not cross a 64K segment boundary or a
    DMA boundary error will occur
  - many programming references list only floppy disk register values
  - only the disk number is checked for validity
  - the parameters in CX change depending on the number of cylinders;
    the track/cylinder number is a 10 bit value taken from the 2 high
    order bits of CL and the 8 bits in CH (low order 8 bits of track):

    |F|E|D|C|B|A|9|8|7|6|5-0|  CX
     | | | | | | | | | |	`-----	sector number
     | | | | | | | | `---------  high order 2 bits of track/cylinder
     `------------------------  low order 8 bits of track/cyl number
#+END_SRC

~carry bit~ 是用来记录操作是否溢出，例如
#+BEGIN_SRC asm
  mov ax, 0xFFFF
  add ax, 1                       ; ax = 0x0000 and carry = 1, 设置了溢出位
  jc label                        ; 如果溢出位设置了则跳转
#+END_SRC

加载磁盘数据的汇编代码
#+BEGIN_SRC asm
  ; load 'dh' sectors from drive 'dl' into ES:BX
  disk_load:
      pusha
      ; reading from disk requires setting specific values in all registers
      ; so we will overwrite our input parameters from 'dx'. Let's save it
      ; to the stack for later use.
      push dx

      mov ah, 0x02 ; ah <- int 0x13 function. 0x02 = 'read'
      mov al, dh   ; al <- number of sectors to read (0x01 .. 0x80)
      mov cl, 0x02 ; cl <- sector (0x01 .. 0x11)
                   ; 0x01 is our boot sector, 0x02 is the first 'available' sector
      mov ch, 0x00 ; ch <- cylinder (0x0 .. 0x3FF, upper 2 bits in 'cl')
      ; dl <- drive number. Our caller sets it as a parameter and gets it from BIOS
      ; (0 = floppy, 1 = floppy2, 0x80 = hdd, 0x81 = hdd2)
      mov dh, 0x00 ; dh <- head number (0x0 .. 0xF)

      ; [es:bx] <- pointer to buffer where the data will be stored
      ; caller sets it up for us, and it is actually the standard location for int 13h
      int 0x13      ; BIOS interrupt
      jc disk_error ; if error (stored in the carry bit)

      pop dx
      cmp al, dh    ; BIOS also sets 'al' to the # of sectors read. Compare it.
      jne sectors_error
      popa
      ret


  disk_error:
      mov bx, DISK_ERROR
      call print
      call print_nl
      mov dh, ah ; ah = error code, dl = disk drive that dropped the error
      call print_hex ; check out the code at http://stanislavs.org/helppc/int_13-1.html
      jmp disk_loop

  sectors_error:
      mov bx, SECTORS_ERROR
      call print

  disk_loop:
      jmp $

  DISK_ERROR: db "Disk read error", 0
  SECTORS_ERROR: db "Incorrect number of sectors read", 0
#+END_SRC
*** 保护模式
**** 保护模式下的字符显示
1. 保护模式是 32 位运行的
2. 可以直接通过显存写入数据来显示字符
   - 显存地址 0xb8000
   - 一次显示需要两个参数，低 16 位传入字符, 高 16 位传入显示模式

#+BEGIN_SRC asm
  [bits 32] ; using 32-bit protected mode

  ; this is how constants are defined
  VIDEO_MEMORY equ 0xb8000
  WHITE_ON_BLACK equ 0x0f ; the color byte for each character

  print_string_pm:
      pusha
      mov edx, VIDEO_MEMORY

  print_string_pm_loop:
      mov al, [ebx] ; [ebx] is the address of our character
      mov ah, WHITE_ON_BLACK

      cmp al, 0 ; check if end of string
      je print_string_pm_done

      mov [edx], ax ; store character + attribute in video memory
      add ebx, 1 ; next char
      add edx, 2 ; next video memory position

      jmp print_string_pm_loop

  print_string_pm_done:
      popa
      ret
#+END_SRC

**** 保护模式下的 GDT
1. GDT 主要保护以下信息, 总共 64 位, [[https://files.osdev.org/mirrors/geezer/os/pm.htm][link]]
   - base  = low(16) + middle(8) + high(8)
   - limit = low(16) + high(4)
   - flags = (12)
2. GDT 的第一项必须全是 ~0x00~
3. GDT 加载通过 ~lgdt~ 指令

下面是一个初始化的 gdt 内存定义，这里先将代码段和数据段合并在一起
#+BEGIN_SRC asm
  gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
      ; the GDT starts with a null 8-byte
      dd 0x0 ; 4 byte
      dd 0x0 ; 4 byte

  ; GDT for code segment. base = 0x00000000, length = 0xfffff
  gdt_code:
      dw 0xffff    ; segment length, bits 0-15                    | limit_low(16)
      dw 0x0       ; segment base, bits 0-15                      | base_low(16)
      db 0x0       ; segment base, bits 16-23                     | base_middle(8)
      db 10011010b ; flags (8 bits)                               | flags1(8)
      db 11001111b ; flags (4 bits) + segment length, bits 16-19  | limit_high(4), flags2(4)
      db 0x0       ; segment base, bits 24-31                     | base_high(8)

  gdt_data:
      dw 0xffff
      dw 0x0
      db 0x0
      db 10010010b
      db 11001111b
      db 0x0

  gdt_end:

  ; GDT descriptor, via lgdt [gdt_descriptor]
  gdt_descriptor:
      dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
      dd gdt_start               ; address (32 bit)

  ; define some constants for later use
  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start
#+END_SRC

**** 实模式到 32 位保护模式切换过程
1. 关闭中断
2. 加载 gdt
3. 设置控制寄存器 ~cr0~
4. 通过远程调整来 flush 流水线
5. 更新所以的段寄存器
6. 更新系统栈
7. 跳转到 32 位指令出执行

#+BEGIN_SRC asm
  ;;; real mode
  [bits 16]
  switch_to_pm:
      cli                         ; 1. disable interrupts
      lgdt [gdt_descriptor]       ; 2. load the GDT descriptor
      mov eax, cr0
      or eax, 0x1                 ; 3. set 32-bit mode bit in cr0
      mov cr0, eax
      jmp CODE_SEG:init_pm        ; 4. far jump by using a different segment

  ;;; protected mode is enabled
  [bits 32]
  init_pm:
      mov ax, DATA_SEG            ; 5. update the segment registers
      mov ds, ax
      mov ss, ax
      mov es, ax
      mov fs, ax
      mov gs, ax

      mov ebp, 0x90000    ; 6. update the stack right at the top of the free space
      mov esp, ebp

      call BEGIN_PM               ; 7. Call a well-known label with useful code
#+END_SRC

*** Minix
**** 配置环境
[[https://wiki.minix3.org/doku.php?id=developersguide:crosscompiling][交叉编译文档]]

下载代码
#+BEGIN_SRC sh
  mkdir minix
  cd minix
  git clone git://git.minix3.org/minix src
  cd src
#+END_SRC

安装依赖
#+BEGIN_SRC sql
  sudo apt-get install build-essential curl git zlibc zlib1g zlib1g-dev g++
#+END_SRC

编译内存镜像
#+BEGIN_SRC sh
  JOBS=8 ./releasetools/x86_hdimage.sh
#+END_SRC

启动镜像
#+BEGIN_SRC sh
  cd ../obj.i386/destdir.i386/boot/minix/.temp

  qemu-system-i386 -display none \
                   -serial stdio \
                   -kernel kernel \
                   -append "console=tty00 rootdevname=c0d0p1" \
                   -initrd "mod01_ds,mod02_rs,mod03_pm,mod04_sched,mod05_vfs,mod06_memory,mod07_tty,mod08_mfs,mod09_vm,mod10_pfs,mod11_init" \
                   -hda /opt/local/hack/minix/src/minix_x86.img --enable-kvm
#+END_SRC

[[file:../static/image/2023/0315/112736.png]]

**** 安装 Minix 操作系统
操作系统安装 [[https://wiki.minix3.org/doku.php?id=usersguide:runningonqemu][link]]
#+BEGIN_SRC sh
  # 解压
  bzip2 -d minix_R3.3.0-588a35b.iso.bz2
  # 新建硬盘镜像
  qemu-img create minix.img 8G
  # 安装启动
  qemu-system-x86_64 -net user -net nic -m 256 -cdrom minix_R3.3.0-588a35b.iso -hda minix.img -boot d
  # 启动
  qemu-system-x86_64 -net user -net nic -m 256 -hda minix.img
#+END_SRC

安装后设置 [[https://wiki.minix3.org/doku.php?id=usersguide:postinstallation][link]]
#+BEGIN_SRC sh
  hostname minix3

  pkgin update
  pkgin install openssh
  cp /usr/pkg/etc/rc.d/sshd /etc/rc.d/
  printf 'sshd=YES\n' >> /etc/rc.conf
  /etc/rc.d/sshd start
#+END_SRC
*** 实验环境准备
1. AUR 编译说明文档 [[https://wiki.manjaro.org/index.php/Arch_User_Repository/zh-cn][link]]
   #+BEGIN_SRC sh
     # clone build repository
     git clone https://aur.archlinux.org/i386-elf-binutils.git
     # make binary package
     makepkg -s
     # install package
     sudo pacman -U i386-elf-binutils-2.40-1-x86_64.pkg.tar.zst
   #+END_SRC

2. c 语言交叉编译
   #+BEGIN_SRC sh
     # 交叉编译, -ffreestanding 不需要标准库支持，生成目标是一个独立环境
     i386-elf-gcc -ffreestanding -c function.c -o function.o
     # 反汇编
     i386-elf-objdump -d function.o

     # 链接, -Ttext 0x0 表示代码段的起始地址
     i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o

     # 反汇编测试生成的二进制文件
     ndisasm -b 32 function.bin
   #+END_SRC

3. gdb 调试内核
   #+BEGIN_SRC sh
     # -s 让 qemu 停止并监听 1234 端口等待调试
     qemu-system-i386 -s -fda os-image.bin &
     # 创建连接符号文件
     i386-elf-ld -o kernel.elf -Ttext 0x1000 kernel.o obj1.o obj2.o
     # gdb 执行命令进行调试
     i386-elf-gdb -ex "target remote localhost:1234" -ex "symbol-file kernel.elf"
   #+END_SRC

*** 自制操作系统
1. nasm 手册 [[https://www.nasm.us/doc/nasmdoc2.html][link]]
** Linux
*** Linux 资源链接
1. Linux 源码在线导读 bootlin [[https://elixir.bootlin.com/linux/0.12/source/kernel/fork.c][link]]
2. Linux 内核完全注释 [[http://www.oldlinux.org/download/CLK-5.0-WithCover.pdf][book]]
3. linux inside [[https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-1.html][link]]
4. Linux Documentation Project Guides [[https://tldp.org/guides.html][TLDP]] | [[https://tldp.org/LDP/khg/HyperNews/get/khg.html][Linux Kernel Hackers' Guide]]
5. Linux From Scratch [[https://www.linuxfromscratch.org/][LFS]]
6. 老版本 Linux 研究网站 [[http://www.oldlinux.org/][oldlinux]]
*** 编译内核示例
1. 一些依赖安装
   #+BEGIN_SRC sh
     sudo apt install ncurses-dev flex bison libelf-dev libssl-dev dwarves
   #+END_SRC

2. 定制内核 [[https://wiki.centos.org/HowTos/Custom_Kernel][CentOS Wiki]]
#+BEGIN_SRC sh
  # 下载源码
  wget -c https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.115.tar.gz
  tar xvzf linux-5.15.115.tar.gz
  cd linux-5.15.115

  # 准备配置文件
  cp /boot/config-`uname -r` .config
  # 开启或关闭配置选项
  make menuconfig

  # 确保 CONFIG_SYSTEM_TRUSTED_KEYS 为空
  # cat .config | grep CONFIG_SYSTEM_TRUSTED_KEYS
  # CONFIG_SYSTEM_TRUSTED_KEYS=""

  # 编译内核
  make -j12

  # 安装模块
  sudo make modules_install

  # 安装内核
  sudo make install

  # 重启系统, 查看内核是否运行正常
  reboot
  uname -r
#+END_SRC

修改 grub 代码
#+BEGIN_SRC sh
  # 查看默认的 grub 选项
  grub2-editenv list
  # 更改默认启动选项
  grub2-set-default '5.16.0-1.el7.elrepo.x86_64) 7 (Core)'
#+END_SRC

*** 编译 Linux 0.11 需要的工具
#+BEGIN_SRC sh
  # as86 ld86
  sudo yum install -y dev86
  sudo apt install bin86
#+END_SRC

*** TODO 内存检测工具 valgrind

** Rust
*** 资源链接
1. [X] The Rust Programming Language 视频教程 | [[https://www.bilibili.com/video/BV1K34y1x7F9][BTV]] | [[https://rust-book.cs.brown.edu/][link]]
2. [X] Rust by Example | [[https://doc.rust-lang.org/rust-by-example/index.html][link]]
3. [X] 如何快速掌握新的 crates | [[https://www.bilibili.com/video/BV12K4y1X7qw/][BTV]]
4. [ ] CIS 198: Rust Programming | [[http://cis198-2016s.github.io/schedule/][Schedule]]
5. [ ] Rust by Practice | [[https://zh.practice.rs/why-exercise.html][ZH]]
** 极客时光
*** 专栏 [[https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/22%20%E8%AE%B2%E9%80%9A%E5%85%B3%20Go%20%E8%AF%AD%E8%A8%80-%E5%AE%8C][22 讲通关 Go 语言]]
*** 专栏 [[https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C][24 讲吃透分布式数据库]]
*** 专栏 [[https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E6%89%8B%E8%AF%BE][消息队列高手课]]
**** 分布式事务
1. 订单系统在消息队列上开启一个事务
2. 然后订单系统给消息服务器发送一个 *半消息*
3. 这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通
   消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的
4. 半消息发送成功后，订单系统就可以执行本地事务

[[file:../static/image/2023/0308/224741.png]]

如果 *半消息* 提交失败，不同队列会有不同处理方式
1. Kafka 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代
   码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿
2. RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题

   [[file:../static/image/2023/0308/225054.png]]

   为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，
   告知 RocketMQ 本地事务是成功还是失败
**** 重复消费
在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到
高依次是：

1. At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什
   么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使
   用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。
2. At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消
   息，但是允许有少量重复消息出现。
3. Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，
   这个是最高的等级。

用幂等性解决重复消息问题
1. 利用数据库的唯一约束实现幂等
2. 为更新的数据设置前置条件
3. 记录并检查操作

**** 消息积压
1. 优化消息收发性能，预防消息积压的方法有两种，
   - 增加批量或者是增加并发，在发送端这两种方法都可以使用
   - 在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的
2. 对于系统发生消息积压的情况，需要先解决积压，再分析原因
   - 快速解决积压的方法就是通过水平扩容增加 Consumer 的实例数量

** 数据结构
1. Leetcode 刷题 [[https://github.com/jeanhwea/golang_tutor][golang]] | [[https://github.com/jeanhwea/annotry][java]]
2. 红黑树 [[https://www.cs.usfca.edu/~galles/visualization/RedBlack.html][rbtree]]
* 编程工具
** Tool Chain
*** ohmyzsh
1. 源码安装 [[https://ohmyz.sh][ohmyz.sh]]
   #+BEGIN_SRC sh
     git clone https://githubfast.com/ohmyzsh/ohmyzsh.git
     ./tools/install.sh
   #+END_SRC
2. 一些配置备忘
   #+BEGIN_SRC sh
     source ~/code/jeanhwea/dome/env/env.sh
   #+END_SRC
*** HomeBrew
1. 安装 [[https://brew.sh][brew.sh]]
   #+BEGIN_SRC sh
     # 方案一
     /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
     # 方案二
     git clone https://github.com/Homebrew/install.git
     ./install/install.sh
   #+END_SRC
2. 清华镜像 [[https://mirrors.tuna.tsinghua.edu.cn/help/homebrew-bottles/][tuna]]
   #+BEGIN_SRC sh
     export HOMEBREW_BOTTLE_DOMAIN="https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles"
   #+END_SRC
*** LSP
Java LSP 服务
#+BEGIN_SRC sh
  # 安装 jdtls
  git clone https://github.com/eruizc-dev/jdtls-launcher.git
  ./install.sh

  # 更新 jdtls
  jdtls --update
  jdtls --version

  # 清理 jdtls 缓存目录
  rm -rvf ~/.cache/jdtls-workspace
#+END_SRC

Python LSP 服务
#+BEGIN_SRC sh
  pip install --user yapf
  pip install --user "python-lsp-server[yapf]"
  # 一次安装所有的 LSP 依赖
  pip install --user "python-lsp-server[all]"
  # 文件格式化
  pip install --user black
  pip install --user isort
#+END_SRC

MacOS 上安装过后出现一些诡异问题, pylsp 命令找不到，发现是 brew install python3
时对应的 bin 文件夹在一个奇怪的位置
#+BEGIN_SRC sh
  $ pylsp
  zsh: command not found: pylsp
  $ pip uninstall  "python-lsp-server[all]"

  Found existing installation: python-lsp-server 1.7.4
  Uninstalling python-lsp-server-1.7.4:
    Would remove:
      /Users/hujinghui/Library/Python/3.11/bin/pylsp
      /Users/hujinghui/Library/Python/3.11/lib/python/site-packages/pylsp/*
      /Users/hujinghui/Library/Python/3.11/lib/python/site-packages/python_lsp_server-1.7.4.dist-info/*
  Proceed (Y/n)? n
  $ ls /Users/hujinghui/Library/Python/3.11/bin/
  autopep8  flake8     get_objgraph  isort-identify-imports  pydocstyle  pylint         pylsp      symilar  yapf
  epylint   get_gprof  isort         pycodestyle             pyflakes    pylint-config  pyreverse  undill   yapf-diff
  $
#+END_SRC

修改 PATH 解决
#+BEGIN_SRC sh
  export PATH=~/Library/Python/3.11/bin:$PATH
#+END_SRC

** Java
*** Maven
**** 添加本地 JAR 包
在 pom.xml 文件中直接添加引用
#+BEGIN_SRC xml
  <!-- 添加数据库驱动安装包 -->
  <dependency>
    <groupId>com.oracle</groupId>
    <artifactId>ojdbc6</artifactId>
    <version>11.2.0.4.0</version>
    <scope>system</scope>
    <systemPath>${project.basedir}/src/main/resources/lib/ojdbc6.jar</systemPath>
  </dependency>
#+END_SRC

**** 添加项目过滤
在 pom.xml 文件中开启编译过滤
#+BEGIN_SRC xml
  <build>
    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
      </resource>
    </resources>
  </build>
#+END_SRC

引用 pom.xml 文件中的配置
#+BEGIN_SRC yaml
  spring:
    application:
      version: @project.version@
#+END_SRC
*** Spring Framework
1. 代码 [[https://github.com/spring-projects/spring-framework][Source]] | [[https://github.com/Jeanhwea/spring-framework/tree/jh/5.3.25][jh/5.3.25]]
2. 编译 [[https://github.com/spring-projects/spring-framework/wiki/Build-from-Source][BUILD]] => Java8 切到 5.3 分支
   #+BEGIN_SRC sh
     # 编译
     ./gradlew build
     # 跳过测试用例
     ./gradlew build -x test
   #+END_SRC
3. 编译文档, 依赖 asciidoctor
   #+BEGIN_SRC sh
     ./gradlew asciidoctor
   #+END_SRC
4. 查看 tasks
   #+BEGIN_SRC sh :results output :dir ../../spring-framework
     ./gradlew tasks
   #+END_SRC
5. 生成代码流量跳转 TAGS
   #+BEGIN_SRC sh
     # 生成跳转的 TAG
     ctags -e -R --languages=c,c++ .
   #+END_SRC
*** Kafka
CLOSED: [2023-06-03 Sat 23:39]
1. [[https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89][JVM 系列]]
**** 资源链接
1. 说明文档 [[https://kafka.apache.org/documentation/][link]]
**** 环境配置
***** 官网快速使用手册
1. [[https://kafka.apache.org/quickstart][quickstart]]
#+BEGIN_SRC sh
  # 启动 zk
  ./bin/zookeeper-server-start.sh config/zookeeper.properties
  # 启动 kafka
  ./bin/kafka-server-start.sh config/server.properties

  # 创建 topic
  ./bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic quickstart-events
  # 显示 topic 列表
  ./bin/kafka-topics.sh --bootstrap-server localhost:9092 --list
  # 查看指定 topic 状态
  ./bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic quickstart-events

  # 生产者 & 消费者
  ./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic quickstart-events
  ./bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic quickstart-events
#+END_SRC

配置相关
#+BEGIN_SRC sh
  ./bin/kafka-configs.sh --zookeeper localhost:2181 --all
#+END_SRC

***** docker 版本配置
1. [[https://hub.docker.com/r/bitnami/kafka/][docker hub]]
2. 配置文件 [[file:env-kafka/docker-compose.yaml][docker-compose.yaml]]
   #+BEGIN_SRC sh
     docker-compose up -d
   #+END_SRC

***** 源代码
跳过测试编译
#+BEGIN_SRC sh
  ./gradlew build -x test
#+END_SRC

编译发布包
#+BEGIN_SRC sh
  # 编译包
  ./gradlew clean releaseTarGz

  # 编译产物
  ls ./core/build/distributions/
#+END_SRC
*** RocketMQ
**** 资源链接
1. 官网文档 [[https://rocketmq.apache.org/docs/4.x/introduction/02quickstart][link]]
*** JVM
**** 编译 JDK
1. OpenJDK 编译说明 [[https://openjdk.org/groups/build/][link]]
2. JDK 8 编译说明 [[https://hg.openjdk.org/jdk8/jdk8/raw-file/tip/README-builds.html][link]]
#+BEGIN_SRC sh
  git clone git@github.com:openjdk/jdk.git
  git checkout -b jh/jdk8-b99 jdk8-b99

  # 配置 & 编译
  MAKE=/usr/bin/make ./configure
  JOBS=12 /usr/bin/make all
#+END_SRC
*** Hive
配置 [[https://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-common/SingleCluster.html#Standalone_Operation][hadoop]]
#+BEGIN_SRC sh
  export HADOOP_HOME=/opt/local/hack/hadoop-2.6.0
  export PATH="$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH"
  export HIVE_HOME=/opt/local/hack/apache-hive-1.2.2-bin
  export PATH="$HIVE_HOME/bin:$PATH"
#+END_SRC

配置 core-site.xml
#+BEGIN_SRC xml
  <configuration>
     <property>
        <name>fs.defaultFS</name>
        <value>hdfs://localhost:9000</value>
     </property>
  </configuration>
#+END_SRC

配置 hdfs-site.xml
#+BEGIN_SRC xml
  <configuration>
    <property>
      <name>dfs.replication</name>
      <value>1</value>
    </property>

    <property>
      <name>dfs.namenode.name.dir</name>
      <value>/opt/local/hdfs/namenode</value>
    </property>

    <property>
      <name>dfs.datanode.data.dir</name>
      <value>/opt/local/hdfs/datanode</value>
    </property>
  </configuration>
#+END_SRC

初始化命令
#+BEGIN_SRC sh
  # 格式化 namenode
  hdfs namenode -format
  # 启动/关闭 dfs
  start-dfs.sh
  stop-dfs.sh
#+END_SRC

[[https://cwiki.apache.org/confluence/display/Hive/GettingStarted#GettingStarted-InstallationandConfiguration][hive]] 需要有 /tmp, /user/hive/warehouse 目录, 并且配置 g+w 权限
- 配置元数据存放目录 hive.metastore.warehouse.dir
#+BEGIN_SRC sh
  hadoop fs -mkdir       /tmp
  hadoop fs -mkdir -p    /user/hive/warehouse
  hadoop fs -chmod g+w   /tmp
  hadoop fs -chmod g+w   /user/hive/warehouse
#+END_SRC

解决 [ERROR] Terminal initialization failed; falling back to unsupported 问题
#+BEGIN_SRC sh
  export HADOOP_USER_CLASSPATH_FIRST=true
#+END_SRC
*** SDK Man
1. 官网 [[https://sdkman.io/][link]]
#+BEGIN_SRC sh
  # 安装 SDK Man
  curl -s "https://get.sdkman.io" | bash

  # 安装 JDK
  sdk list java
  sdk install java 11.0.19-tem
  sdk install java 8.0.372-tem
  sdk install java 17.0.7-tem

  # 离线安装, 创建 SDK 包为 8.0.191-online
  sdk install java 8.0.191-online /opt/admin/java
  export JAVA_HOME=/opt/admin/java

  # 修改默认 SDK 版本
  sdk list java | grep installed
  sdk default java 11.0.19-zulu

  # 环境
  # 初始化环境, 生成 .sdkmanrc
  sdk env init
  # 安装环境
  sdk env install
  # 切换环境
  sdk env
  # 清除环境
  sdk env clear


  # 安装其他 SDK 工具
  sdk install gradle
  sdk install java
  sdk install hadoop
  sdk install ant

  # 强制更新 SDK Man
  sdk selfupdate force
#+END_SRC

** Golang
*** go module 初始化项目
#+BEGIN_SRC sh
  mkdir genco
  cd genco
  go mod init genco
#+END_SRC

*** 使用私有仓库
配置私有仓库环境变量
#+BEGIN_SRC sh
  export GOINSECURE="gitana.jeanhwea.io"
  export GOPRIVATE="*.jeanhwea.io"
#+END_SRC

配置 ~/.gitconfig
#+BEGIN_SRC conf
  [url "ssh://git@gitana.jeanhwea.io/"]
      insteadOf = http://gitana.jeanhwea.io/
#+END_SRC

获取对应的包
#+BEGIN_SRC sh
  go get gitana.jeanhwea.io/stock/common
#+END_SRC

*** 使用本地仓库
参考官网介绍 [[https://go.dev/doc/modules/managing-dependencies#local_directory][link]]
#+BEGIN_SRC sh
  go mod edit -replace=example.com/theirmodule@v0.0.0-unpublished=../theirmodule
#+END_SRC

或者直接在 go.mod 文件中添加
#+BEGIN_SRC text
  replace gitana.jeanhwea.io/stock/common => ../common
#+END_SRC

*** IDL
定义的结果如下
1. [[https://thrift.apache.org/][Apache Thrift]]
2. [[https://diwakergupta.github.io/thrift-missing-guide/][Thrift: The Missing Guide]]
*** hertz
操作手册 [[https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/usage/usage-thrift/][link]]
#+BEGIN_SRC sh
  hz new -module github.com/jeanhwea/appname -idl idl/appname.thrift
  hz update -idl idl/appname.thrift
  go mod edit -replace github.com/apache/thrift=github.com/apache/thrift@v0.13.0
#+END_SRC

*** kitex
Kitex 微服务架构工具 [[https://www.cloudwego.io/zh/docs/kitex/][kitex]]
*** profile 性能分析
通过如下命令生成分析文件，官网工具介绍 [[https://go.dev/doc/diagnostics][diagnostics]]
#+BEGIN_SRC sh
  # cpu 性能分析
  go test -cpuprofile ./output/cpu.prof -run TestSched01 ./app/sched
  # 内存 性能分析
  go test -memprofile ./output/mem.prof -run TestSched01 ./app/sched
  # cpu 内存性能分析
  go test -cpuprofile ./output/cpu.prof -memprofile ./output/mem.prof -run TestSched01 ./app/sched
#+END_SRC

使用 go tool 查看文件
#+BEGIN_SRC sh
  go tool pprof ./output/cpu.prof
#+END_SRC

查看 cpu 性能分析结果
#+BEGIN_EXAMPLE
  $ go tool pprof ./output/cpu.prof
  File: sched.test
  Type: cpu
  Time: Aug 30, 2023 at 8:51am (CST)
  Duration: 201.60ms, Total samples = 70ms (34.72%)
  Entering interactive mode (type "help" for commands, "o" for options)
  (pprof) top 5
  Showing nodes accounting for 70ms, 100% of 70ms total
  Showing top 5 nodes out of 32
        flat  flat%   sum%        cum   cum%
        40ms 57.14% 57.14%       40ms 57.14%  runtime/internal/syscall.Syscall6
        10ms 14.29% 71.43%       10ms 14.29%  github.com/sirupsen/logrus.(*TextFormatter).Format
        10ms 14.29% 85.71%       10ms 14.29%  runtime.heapBitsSetType
        10ms 14.29%   100%       10ms 14.29%  time.Now
           0     0%   100%       60ms 85.71%  github.com/sirupsen/logrus.(*Entry).Info
  (pprof) top 5 -cum
  Showing nodes accounting for 0, 0% of 70ms total
  Showing top 5 nodes out of 32
        flat  flat%   sum%        cum   cum%
           0     0%     0%       70ms   100%  mtiisl.cn/gitlab/xifei/patok/app/sched.(*Sched).StartSched
           0     0%     0%       70ms   100%  mtiisl.cn/gitlab/xifei/patok/app/sched.TestSched01
           0     0%     0%       70ms   100%  testing.tRunner
           0     0%     0%       60ms 85.71%  github.com/sirupsen/logrus.(*Entry).Info (inline)
           0     0%     0%       60ms 85.71%  github.com/sirupsen/logrus.(*Entry).Log
  (pprof)
#+END_EXAMPLE

查看内存性能分析结果
#+BEGIN_EXAMPLE
  $ go tool pprof ./output/mem.prof
  File: sched.test
  Type: alloc_space
  Time: Aug 30, 2023 at 8:47am (CST)
  Entering interactive mode (type "help" for commands, "o" for options)
  (pprof) top
  Showing nodes accounting for 3693.94kB, 100% of 3693.94kB total
  Showing top 10 nodes out of 29
        flat  flat%   sum%        cum   cum%
   1184.27kB 32.06% 32.06%  1184.27kB 32.06%  runtime/pprof.StartCPUProfile
    902.59kB 24.43% 56.49%  1485.59kB 40.22%  compress/flate.NewWriter (inline)
    583.01kB 15.78% 72.28%   583.01kB 15.78%  compress/flate.newDeflateFast (inline)
    512.07kB 13.86% 86.14%   512.07kB 13.86%  fmt.Sprintf
    512.01kB 13.86%   100%   512.01kB 13.86%  fmt.Sprint
           0     0%   100%   583.01kB 15.78%  compress/flate.(*compressor).init
           0     0%   100%  1485.59kB 40.22%  compress/gzip.(*Writer).Write
           0     0%   100%  1024.08kB 27.72%  github.com/sirupsen/logrus.(*Entry).Info
           0     0%   100%  1024.08kB 27.72%  github.com/sirupsen/logrus.(*Entry).Log
           0     0%   100%   512.07kB 13.86%  github.com/sirupsen/logrus.(*Entry).log
  (pprof) top -cum
  Showing nodes accounting for 2086.86kB, 56.49% of 3693.94kB total
  Showing top 10 nodes out of 29
        flat  flat%   sum%        cum   cum%
    902.59kB 24.43% 24.43%  1485.59kB 40.22%  compress/flate.NewWriter (inline)
           0     0% 24.43%  1485.59kB 40.22%  compress/gzip.(*Writer).Write
           0     0% 24.43%  1485.59kB 40.22%  runtime/pprof.(*profileBuilder).build
           0     0% 24.43%  1485.59kB 40.22%  runtime/pprof.profileWriter
           0     0% 24.43%  1184.27kB 32.06%  main.main
           0     0% 24.43%  1184.27kB 32.06%  runtime.main
   1184.27kB 32.06% 56.49%  1184.27kB 32.06%  runtime/pprof.StartCPUProfile
           0     0% 56.49%  1184.27kB 32.06%  testing.(*M).Run
           0     0% 56.49%  1184.27kB 32.06%  testing.(*M).before
           0     0% 56.49%  1184.27kB 32.06%  testing/internal/testdeps.TestDeps.StartCPUProfile
  (pprof)
#+END_EXAMPLE

产出 PDF 性能分析报告
#+BEGIN_SRC sh
  # 安装图像生成工具
  sudo apt install graphviz
  sudo brew install graphviz
  # 生成 PDF 报告
  go tool pprof --pdf ./output/cpu.prof > cpu.pdf
  go tool pprof --pdf ./output/mem.prof > mem.pdf
#+END_SRC

*** 泛型写法
#+BEGIN_SRC go
  import (
          "sort"
  )

  // ~string 表示底层时 string 类型的集合
  func IterMap[K ~string, V any](m map[K]V, fn func(k K, v V)) {
          keys := make([]string, 0, len(m))
          for k := range m {
                  keys = append(keys, string(k))
          }
          sort.Strings(keys)
          for _, k := range keys {
                  fn(K(k), m[K(k)])
          }
  }
#+END_SRC
** Perl
*** 环境配置
**** 包管理工具配置 CPAN
1. 官网 [[https://metacpan.org/][CPAN]]
2. 镜像 [[https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/][TUNA]]
   #+BEGIN_SRC sh
     PERL_MM_USE_DEFAULT=1 perl -MCPAN -e 'CPAN::HandleConfig->edit("pushy_https", 0); CPAN::HandleConfig->edit("urllist", "unshift", "https://mirrors.tuna.tsinghua.edu.cn/CPAN/"); mkmyconfig'
   #+END_SRC
3. CPAN 的配置文件: =~/.cpan/CPAN/MyConfig.pm=
**** 包管理命令
#+BEGIN_SRC sh
  perl -MCPAN -e 'install Excel::Writer::XLSX'
#+END_SRC
*** 基本使用
**** Hello world
创建 =hello.pl= 文件写以下代码
#+BEGIN_SRC perl :results output
  print("hello world\n");
#+END_SRC

#+RESULTS:
: hello world

使用 perl 命令运行代码
#+BEGIN_SRC sh
  perl hello.pl
#+END_SRC
[[file:../static/image/2023/0129/192740.png]]

**** 过滤 MySQL trace 日志
#+BEGIN_SRC perl :results file
  use strict;
  use warnings;

  my $cid = 8;
  my $fout = "/tmp/mysqld-thd-$cid.txt";
  open(FIN, '<:encoding(UTF-8)', "/tmp/mysqld.trace") or die;
  open(FOUT, '>', $fout) or die;

  while (my $line = <FIN>) {
      if ($line =~ /^T\@$cid/) {
          print FOUT $line;
      }
  }

  close(FOUT);
  $fout;
#+END_SRC

#+RESULTS:
[[file:/tmp/mysqld-thd-8.txt]]

** Python
安装 python 的开发包
#+BEGIN_SRC sh
  pip install --user pandas
  pip install --user sqlalchemy
  pip install --user pymysql
#+END_SRC

源码编译安装
#+BEGIN_SRC sh
  wget -c https://www.python.org/ftp/python/3.11.5/Python-3.11.5.tgz
  tar xzvf ~/Python-3.11.5.tgz

  sudo yum install openssl openssl-devel
  sudo yum install libffi libffi-devel

  ./configure prefix=/opt/python3
  make
  sudo make install
#+END_SRC

** Ruby
1. 配置国内 GEM 镜像 [[https://gems.ruby-china.com/][Ruby China]]
** Rust
*** 安装配置
1. 安装页面 [[https://www.rust-lang.org/tools/install][link]]
   #+BEGIN_SRC sh
     curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
     # 安装工具链
     rustup component add rust-src
   #+END_SRC

*** 使用笔记
#+BEGIN_SRC rust
  #![allow(dead_code)]
  #![allow(unused_variables)]
#+END_SRC

结构体
#+BEGIN_SRC rust
  struct Point {
      x: f64,
      y: f64,
  }

  struct Line {
      beg: Point,
      end: Point,
  }

  impl Line {
      // 方法
      fn len(&self) -> f64 {
          let dx = self.end.x - self.beg.x;
          let dy = self.end.y - self.beg.y;
          (dx * dx + dy * dy).sqrt()
      }
  }
#+END_SRC

匿名函数及闭包
#+BEGIN_SRC rust
  fn use_closure() {
      let plus_one = |x| -> i32 { x + 1 };
      let x = 1;
      println!("{} + 1 = {}", x, plus_one(x));
  }
#+END_SRC

match 关键字
#+BEGIN_SRC rust
  fn match_statement(x: i32) -> &'static str {
      return match x {
          8 => "China",
          1..=10 => "VALID",
          _ => "INVALID",
      };
  }
#+END_SRC

使用 trait
#+BEGIN_SRC rust
  trait Animal {
      fn name(&self) -> &'static str;

      fn talk(&self) {
          println!("{} cannot talk!", self.name());
      }
  }

  struct Cat {
      name: &'static str,
  }

  struct Human {
      name: &'static str,
  }

  impl Animal for Cat {
      fn name(&self) -> &'static str {
          self.name
      }
  }

  impl Animal for Human {
      fn name(&self) -> &'static str {
          self.name
      }

      fn talk(&self) {
          println!("{} says hello.", self.name());
      }
  }

  fn use_trait() {
      let john = Human { name: "John" };
      john.talk();

      let pet = Cat { name: "MiMi" };
      pet.talk();
  }
#+END_SRC

*** cargo
创建项目
#+BEGIN_SRC sh
  cargo new myapp
  cargo new --lib mylib
#+END_SRC

添加包
#+BEGIN_SRC sh
  cargo add config
  cargo add clap --features derive
#+END_SRC

编译运行
#+BEGIN_SRC sh
  cargo build
  cargo build --release
  cargo run -- -h
#+END_SRC

** GDB & LLDB
*** 参考资料及链接
1. [[https://lldb.llvm.org/use/map.html][LLDB <-> GDB]]
2. [[https://github.com/hellogcc/100-gdb-tips][GDB 小技巧]] | [[https://sourceware.org/gdb/onlinedocs/gdb/][GDB 在线手册]]
3. 视频 [[https://www.youtube.com/watch?v=svG6OPyKsrw][GDB Tutorial]]
*** TUI
1. 开启汇编窗口 layout asm
2. 开启寄存器窗口 layout regs
3. 布局循环 layout next/prev
4. 打印 32 个汇编指令 x/32i $pc
*** 进程启动: run & attach
方法一：使用 attach 模式调试。首先正常启动重新，然后使用 attach 命令附属到进程上
#+BEGIN_SRC sh
  (lldb) attach -p 18616
  (gdb) attach 18616
#+END_SRC

方法二：直接 run 启动进程
#+BEGIN_SRC sh
  # 指定启动文件
  (lldb/gdb) file <binary>

  # 直接 run 启动进程
  (lldb/gdb) r
  # 添加启动参数
  (lldb/gdb) r args1 args2 ...
  # 查看参数
  (gdb) show args
  (lldb) settings show target.run-args
#+END_SRC
[[file:../static/image/2023/0205/131917.png]]

*** 调试流程控制
**** 设置断点 breakpoint
#+BEGIN_SRC sh
  # 普通断点
  b main
  b main.cc:12
  b 12
  # 条件断点
  (gdb) b 34 if i = 10
  (gdb) break foo if strcmp(y,"hello") == 0
  (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0'
  (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
  (lldb) br s -n read_page -c 'm_page_id.space()==56'
  # 临时断点: 临时断点执行一次后自动销毁
  tb main
#+END_SRC

**** 流程控制 step & next & continue
1. step 单步调试，不进入函数
2. next 单步调试，进入函数
3. continue 继续执行
   #+BEGIN_SRC sh
     s # step
     n # next
     c # continue

     # until 直接执行到行数
     (gdb) until 12
     (lldb) thread until 12
   #+END_SRC
4. 跳转到指定行
   - 条件断点 ~tb~ temp breakpoint
   - until ~until <line>~
5. 返回当前值
   #+BEGIN_SRC sh
     (gdb) return <return expression>
     (lldb) thread return <return expression>
   #+END_SRC

*** 保持断点 & 现场恢复
GDB 保存断点的方式比较方便，直接保持成一个文本文件后，再应用代码
#+BEGIN_SRC sh
  # 保持断点到文件中
  (gdb) save breakpoint mybreak.txt
  # 重新加载保存的断点
  (gdb) source mybreak.txt
#+END_SRC

LLDB 保存断点也有类似的命令，但是保存结果是一个 JSON
#+BEGIN_SRC sh
  # 保存断点到 json 格式文件
  (lldb) breakpoint write -f dbg001
  # 读取断点到 json 格式文件
  (lldb) breakpoint read -f dbg001
#+END_SRC

也可以参考这个答案优化流程 [[https://stackoverflow.com/questions/24638515/save-breakpoints-in-lldb][SO]]

[[file:../static/image/2023/0205/100837.png]]

*** 查看/修改变量和内存数据
1. 打印变量 print / [[https://visualgdb.com/gdbreference/commands/x ][x-command]]
   #+BEGIN_SRC text
     (lldb) p thd->m_thread_id
     (my_thread_id) $1 = 10
     (lldb) x/w &$1
     0x7fbdc1240188: 0x0000000a
     (lldb)
   #+END_SRC
   - o octal
   - x hexadecimal
   - d decimal
   - u unsigned decimal
   - t binary
   - f floating point
   - a address
   - c char
   - s string
   - i instruction
   - b byte
   - h halfword (16-bit value)
   - w word (32-bit value)
   - g giant word (64-bit value)
2. 查看内存地址中的数据
   #+BEGIN_SRC sh
     (lldb) x/8w $0 => 打印地址的数据, 打印 8 条数据, [w, b] 表示不同的打印方式
     0x7fbdc123dc00: 0x0916f4d8 0x00000001 0x0916f548 0x00000001
     0x7fbdc123dc10: 0x00000000 0x00000000 0xc1240440 0x00007fbd
     (lldb) x/8b $0
     0x7fbdc123dc00: 0xd8 0xf4 0x16 0x09 0x01 0x00 0x00 0x00
     (lldb) x/8x $0
     0x7fbdc123dc00: 0xd8 0xf4 0x16 0x09 0x01 0x00 0x00 0x00
   #+END_SRC
3. 查看 frame 中变量
   #+BEGIN_SRC sh
     # 查看局部变量
     (lldb) frame variable
     (lldb) fr v
     # 查看全局变量
     (lldb) target variable
     (lldb) ta v
     # 查看调用栈 thread backtrace
     (lldb/gdb) bt
   #+END_SRC

*** 调试时显示下一条汇编
开启显示下一条汇编
#+BEGIN_EXAMPLE
  set disassemble-next-line on
#+END_EXAMPLE

查看是否开启成功
#+BEGIN_EXAMPLE
  show disassemble-next-line
#+END_EXAMPLE

*** 命令行启动时执行命令 -ex
#+BEGIN_SRC sh
  gdb -ex "target remote :1234" -ex "b *0x7c00" -ex "c"
#+END_SRC

** Git
1. taobao git 下载 [[https://registry.npmmirror.com/binary.html?path=git-for-windows/][git-for-windows]]
2. taobao 二进制下载 [[https://registry.npmmirror.com/binary.html][taobao binary]]
3. github 加速
   - [[https://githubfast.com/Jeanhwea/jeanhwea.github.io.git][githubfast]]
   - [[https://github.com/Jeanhwea/jeanhwea.github.io.git][ghproxy]]
   #+BEGIN_SRC conf
     # ~/.gitconfig
     [url "https://githubfast.com/"]
             insteadOf = https://github.com/
   #+END_SRC
*** 配置用户信息
#+BEGIN_SRC sh
  git config --global user.email "hujinghui@buaa.edu.cn"
  git config --global user.name "Jinghui Hu"
#+END_SRC

*** 递归克隆子模块
#+BEGIN_SRC sh
  git clone --recurse-submodules url
#+END_SRC

*** 忽略换行符 ^M
#+BEGIN_SRC sh
   git config core.autocrlf true
#+END_SRC

*** 代码发布相关
#+BEGIN_SRC sh
  # 动态生成标签
  git describe --tags --always --dirty='-dev'
  # 创建代码包
  git archive -o output.tgz HEAD
#+END_SRC

*** 添加添加生成 TAGS 的 git-hooks
#+BEGIN_SRC sh
  cp .git/hooks/pre-commit.sample .git/hooks/pre-commit
  echo 'ctags -e -R . >/dev/null 2>&1 &' > .git/hooks/pre-commit
#+END_SRC

** SSH
*** ~/.ssh/config
创建配置文件
#+BEGIN_SRC sh
  touch ~/.ssh/config
  chmod 600 ~/.ssh/config
#+END_SRC

查看配置文件
#+BEGIN_SRC sh
  man ssh_config 5
#+End_SRC

基本配置
- ServerAliveInterval 心跳时间
#+BEGIN_SRC conf
  Host *
      ServerAliveInterval 0
#+END_SRC

解决 ssh 一段时间后自动断线
#+BEGIN_SRC sh
  Host *
      ServerAliveInterval 60
      ServerAliveCountMax 1
#+END_SRC

*** 配置 host 别名
在配置文件 ~/.ssh/config 方便后续直接在 ssh 命令中使用
#+BEGIN_SRC conf
  Host gitana
      Hostname gitana.jeanhwea.io
      Port 2222
      User admin

  # match 123, 212 etc
  Host 1?? 2??
      Hostname 192.168.0.%h
      Port 22
      User admin

  # match all
  Host *
      Hostname 192.168.0.%h
      Port 22
      User admin
#+END_SRC

*** 直接转发远端流量
通过 ssh_config 的配置来转发远端 5432
#+BEGIN_SRC conf
  Host db
      HostName db.example.com
      LocalForward 5433 localhost:5432
#+END_SRC

登录到远端, 然后就可以在本地连接
- -f 后台运行命令
- -C 传输启用压缩
- -N 不登录主机
#+BEGIN_SRC sh
  ssh -fCN db
  psql -h localhost -p 5433 orders
#+END_SRC

*** 暴露本机服务配置, 两跳登录
#+BEGIN_SRC conf
  Host hoppin
      Hostname remote-server
      Port 22
      User root
      RemoteForward 2222 localhost:22
#+END_SRC

两跳登录配置
#+BEGIN_SRC conf
  Host gitana
      Hostname 127.0.0.1
      Port 2222
      User admin
      IdentityFile ~/.ssh/id_rsa
      ProxyCommand ssh -W %h:%p proxy-host
#+END_SRC

*** 代理登录
添加代理登录的配置, 需要通过 ProxyCommand 来设置代理命令
#+BEGIN_SRC conf
  Host gateway
      HostName proxy.example.com
      User root
  Host db
      HostName db.internal.example.com                  # 目标服务器地址
      User root                                         # 用户名
      # IdentityFile ~/.ssh/id_ecdsa                    # 认证文件
      ProxyCommand ssh gateway netcat -q 600 %h %p      # 代理命令
#+END_SRC


*** 连接 socket 重用
#+BEGIN_SRC conf
  Host example.org
    ControlMaster    auto
    ControlPath      ~/.ssh/cp-%r@%h:%p.sock
    ControlPersist   yes
#+END_SRC

*** forward 端口转发
本地转发
#+BEGIN_SRC sh
  # -N 不执行命令, -L local 转发 <remote-port>:<local-host>:<local-port>
  ssh -N -L 9092:127.0.0.1:9092 user@host
#+END_SRC

远端转发
#+BEGIN_SRC sh
  # -N 不执行命令, -R remote 转发 <local-port>:<remote-host>:<remote-port>
  ssh -N -R 9092:127.0.0.1:9092 user@host
#+END_SRC

*** ssh 双跳登录
#+BEGIN_SRC sh
  ssh -p9998 -i ~/.ssh/id_s1 user1@175.0.0.20 -t ssh -p9999 -i ~/.ssh/id_s2 user2@213.0.0.30
#+END_SRC

*** scp 双跳传输
#+BEGIN_SRC sh
  scp -o ProxyCommand="ssh -p9998 user1@175.0.0.20 nc 213.0.0.30 9999" \
      -o IdentityFile="~/.ssh/id_s2" /opt/file user2@213.0.0.30:/tmp/file
#+END_SRC

** Shell
*** 后台运行命令 cmd
#+BEGIN_SRC sh
  nohup cmd >/dev/null 2>&1 &
#+END_SRC

*** 比较 semver 版本号
#+BEGIN_SRC sh
  vge() {
      local v1=$1
      local v2=$2
      local small=$(printf "%s\n", $1, $2 | sort -V | head -n 1)
      if [ "$v1" == "$small" ]; then
          echo "true"
      else
          echo "false"
      fi
  }
#+END_SRC

*** heredoc 定义变量
#+BEGIN_SRC sh
  read -d '' TEXT <<EOF
  this is a
  multiple line
  text
  EOF

  echo $TEXT
#+END_SRC

*** 检测命令返回值是否正确
#+BEGIN_SRC sh
  # run a command or ./run.sh
  if [ "$?" != "0" ]; then
    exit $?
  fi
#+END_SRC

*** 检测当前是否 root 用户
#+BEGIN_SRC sh
  if [ $UID -ne 0 ]; then
      echo "permission deny, sudo ..."
      exit 13 # EACCES
  fi
#+END_SRC

*** 临时提权设置目录权限
#+BEGIN_SRC sh
  echo 'password' | sudo -S chmod -R a+rX dist
#+END_SRC

* 研发效率
** 交叉编译环境配置
安装前置依赖项目
#+BEGIN_SRC sh
  yum install -y texinfo
#+END_SRC

下载所需的依赖
#+BEGIN_SRC sh
  # 下载所需的安装包
  wget -c https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-11.4.0/gcc-11.4.0.tar.gz
  wget -c https://mirrors.tuna.tsinghua.edu.cn/gnu/binutils/binutils-2.40.tar.gz
  wget -c https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/gdb-11.2.tar.gz

  tar xzvf binutils-2.40.tar.gz
  tar xzvf gcc-11.4.0.tar.gz
  tar xzvf gdb-11.2.tar.gz

  # gcc 需要依赖 gmp mpfr libmpc 库, 可以直接使用 gcc 里面的辅助脚本下载
  cd gcc-11.4.0
  ./contrib/download_prerequisites
#+END_SRC

保存脚本开始编译
#+BEGIN_SRC sh
  export PREFIX="/opt/i386-elf-toolchain"
  export TARGET=i386-elf
  export PATH="$PREFIX/bin:$PATH"

  DIR=$PWD

  # rm -rf $DIR/build-binutils
  mkdir -p $DIR/build-binutils
  cd $DIR/build-binutils
  ../binutils-2.40/configure --target=$TARGET --prefix=$PREFIX --enable-interwork --enable-multilib --disable-nls --disable-werror |& tee configure.log
  make all -j4 |& tee make.log
  sudo make install |& tee install.log


  # rm -rf $DIR/build-gcc
  mkdir -p $DIR/build-gcc
  cd $DIR/build-gcc
  ../gcc-11.4.0/configure --target=$TARGET --prefix=$PREFIX --disable-nls --disable-libssp --enable-languages=c --without-headers |& tee configure.log
  make all-gcc -j4 |& tee make-all-gcc.log
  make all-target-libgcc -j4 |& tee make-all-target-libgcc.log
  sudo make install-gcc |& tee make-install-gcc.log
  sudo make install-target-libgcc |& tee make-install-target-libgcc.log


  # rm -rf $DIR/build-gdb
  mkdir -p $DIR/build-gdb
  cd $DIR/build-gdb
  ../gdb-11.2/configure --target=$TARGET --prefix=$PREFIX --program-prefix=i386-elf-
  make -j4 |& tee make.log
  sudo make install |& tee install.log
#+END_SRC

** Tmux 管理终端会话
基本配置 ~/.tmux.conf
#+BEGIN_SRC sh
  set -g mouse on
  set -g default-terminal "xterm-256color"
  set -g escape-time 0
#+END_SRC

使用 ~Ctrl-b :~ 可以进入命令模式执行命令
使用 ~Ctrl-b ?~ 可以进入查看快捷键绑定

** 处理 json 字符串
- fromjson 字符串 => 对象
- tojson 对象 => 字符串
#+BEGIN_SRC sh
  cat a.json | jq '.str | fromjson | .[0] | tojson'
#+END_SRC

unqoute string, jq 使用 =-r= 选项可以去掉字符串中的双引号, [[https://github.com/jqlang/jq/issues/1735][link]]
#+BEGIN_SRC sh :results output
  echo '{"a": "val01", "b": 1}' | jq '.a'
#+END_SRC

#+RESULTS:
: "val01"

#+BEGIN_SRC sh :results output
  echo '{"a": "val01", "b": 1}' | jq -r '.a'
#+END_SRC

#+RESULTS:
: val01

** qemu
- qemu 使用示例教程 [[https://www.poftut.com/qemu-tutorial/][link]]

安装 qemu
#+BEGIN_SRC sh
  apt install -y qemu-system
#+END_SRC

创建硬盘镜像文件
#+BEGIN_SRC sh
  qemu-img create myvm.qcow2 16G
#+END_SRC

安装 minix 系统
#+BEGIN_SRC sh
  qemu-system-x86_64 -boot d -cdrom minix_R3.3.0-588a35b.iso -m 1024 -hda myvm.qcow2
  # Ctrl-A x 退出 QEMU 界面
  qemu-system-x86_64 -nographic -boot d -cdrom minix_R3.3.0-588a35b.iso -m 1024 -hda myvm.qcow2
#+END_SRC

** bochs
*** bochs 安装及配置
源码编译安装 [[https://wiki.osdev.org/Bochs][OSDev link]] | [[https://github.com/bochs-emu/Bochs][Github]] | [[https://sourceforge.net/projects/bochs/files/bochs/2.7/][bochs 2.7]]
官方编译手册 [[https://bochs.sourceforge.io/doc/docbook/user/compiling.html][Compiling Bochs]] | [[https://rayanfam.com/topics/bochs-config-and-build-on-windows-and-os-x/][build on macosx]]

ubuntu 下编译
#+BEGIN_SRC sh
  wget -c https://jaist.dl.sourceforge.net/project/bochs/bochs/2.7/bochs-2.7.tar.gz

  sudo apt-get install libsdl2-dev

  ./configure --prefix=/opt/bochs \
              --enable-smp \
              --enable-cpu-level=6 \
              --enable-all-optimizations \
              --enable-x86-64 \
              --enable-pci \
              --enable-vmx \
              --enable-debugger \
              --enable-debugger-gui \
              --enable-logging \
              --enable-fpu \
              --enable-3dnow \
              --enable-sb16=dummy \
              --enable-ne2000 \
              --enable-cdrom \
              --enable-x86-debugger \
              --enable-iodebug \
              --disable-plugins \
              --disable-docbook \
              --with-x --with-x11 --with-term

  make

  sudo make install
#+END_SRC

macos 下编译
#+BEGIN_SRC sh
  wget -c https://jaist.dl.sourceforge.net/project/bochs/bochs/2.7/bochs-2.7.tar.gz

  brew install sdl2

  ./configure --prefix=/opt/bochs \
              --enable-smp \
              --enable-cpu-level=6 \
              --enable-all-optimizations \
              --enable-x86-64 \
              --enable-pci \
              --enable-vmx \
              --enable-debugger \
              --enable-debugger-gui \
              --enable-logging \
              --enable-fpu \
              --enable-3dnow \
              --enable-sb16=dummy \
              --enable-cdrom \
              --enable-x86-debugger \
              --enable-iodebug \
              --disable-plugins \
              --disable-docbook \
              --with-term --with-sdl2

  make
  sudo make install
#+END_SRC

添加共享配置
#+BEGIN_SRC sh
  export BXSHARE="/opt/bochs/share/bochs"
#+END_SRC

bochsrc 配置文件, 设置启动未 1.44 存软盘, 启动镜像名称为 Image
#+BEGIN_SRC text
  boot: floppy
  floppy_bootsig_check: disabled=0
  floppya: 1_44=Image, status=inserted
#+END_SRC

全部的配置文件参考如下说明
#+BEGIN_SRC sh
  vim /opt/bochs/share/doc/bochs/bochsrc-sample.txt
#+END_SRC

*** 开启图形调试器
修改配置文件 bochsrc.bxrc
#+BEGIN_SRC sh
  # Linux
  display_library: x, options="gui_debug"
  # Windows
  display_library: win32, options="gui_debug"
#+END_SRC

*** 提取系统文件
#+BEGIN_SRC text
  [/root]# mdir b:
   Volume in drive B has no label
   Directory for B:/

  FIND-3X2 TAZ      218243    2-24-105   2:49p
  COMPRESS           74756    2-27-105   2:54p
  BOOT     S           335    2-27-105   3:20p
  PS012    TAZ       75393    2-28-105  10:15p
  HELLO    C            74    7-23-123  12:18a
         5 File(s)     1086976 bytes free
  [/root]# mcopy hello.c b:
  File "HELLO.C" exists, overwrite (y/n) ? y
  Copying HELLO.C
  [/root]#
#+END_SRC

挂载文件镜像
#+BEGIN_SRC sh
  sudo mount -t msdos -o loop diskb.img /mnt
  sudo mount -t minix -o loop rootimage-hd.img /mnt
#+END_SRC

** pandoc 文档格式转换
#+BEGIN_SRC sh
  pandoc --pdf-engine=xelatex \
         --toc --number-sections \
         -V date="$(date +'%Y-%m-%d %H:%M:%S')" \
         -V author="Jinghui Hu" \
         -V mainfont="SimSun" \
         -V documentclass=ctexart \
         -V geometry:margin='1in' \
         -o tech.pdf tech.org
#+END_SRC
* 后端研发
** Oracle
*** 参考资料
1. Oracle 关系数据库 [[file:../database/oracle.org::*参考链接][参考链接]]
*** 开发环境配置
**** CentOS 7 镜像启动
1. [[https://hub.docker.com/_/centos/][docker container]]
2. 启动 centos7 镜像
   #+BEGIN_SRC sh
     docker run -d -it --restart always \
            -v ~/srv/pence/data:/data \
            --hostname pence --name pence centos:7
   #+END_SRC
3. 重新进入进行容器
   #+BEGIN_SRC sh
     docker exec -it pence bash
   #+END_SRC
4. 删除容器
   #+BEGIN_SRC sh
     docker rm -f pence
   #+END_SRC
**** 配置主机开发环境
安装一波系统依赖库
#+BEGIN_SRC sh
  yum update

  # common tools
  yum install -y net-tools vim tmux tree kernel-devel kernel-doc kernel-headers \
      samba samba-client ntp rsync curl git

  # for oracle 11g install
  yum install -y binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc \
      glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXi \
      libXtst make sysstat unixODBC unixODBC-devel oracleasm-support

  yum install -y gcc gcc-c++ cmake automake zip unzip python3 python3-devel \
      python-devel python rpm-build redhat-rpm-config asciidoc hmaccalc \
      perl-ExtUtils-Embed pesign xmlto audit-libs-devel binutils-devel \
      elfutils-devel elfutils-libelf-devel ncurses-devel bison-devel newt-devel \
      numactl-devel pciutils-devel python-devel zlib-devel readline-devel

  # for mysql
  yum install -y cmake ncurses ncurses-devel bison bison-devel openssl openssl-devel

  # for openGauss
  yum install -y libaio-devel flex bison bison-devel ncurses-devel glibc-devel \
      patch redhat-lsb-core readline-devel

#+END_SRC

**** 设置时区
#+BEGIN_SRC sh
  cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
#+END_SRC

**** 安装数据库的前置准备
1. [[file:../article/install-oracle-11g-on-linux.org][安装 Oracle 11g]]
2. 配置系统内存以及 swap

*** 运维相关
**** 表空间及数据文件
查看数据
#+BEGIN_SRC sh

#+END_SRC

修改数据
#+BEGIN_SRC sql
  -- 添加数据文件到表空间
  alter tablespace TBS_PART01 add datafile '/u01/part01.dbf' size 4G;
  -- 修改数据文件属性
  alter database datafile '/u01/part01.dbf' autoextend off;
  alter database datafile '/u01/part01.dbf' autoextend on next 100M maxsize 10G;
#+END_SRC
** MySQL
*** 参考资料
1. MySQL 开发文档 8.0.30  [[https://dev.mysql.com/doc/dev/mysql-server/8.0.30/PAGE_GET_STARTED.html#start_source][Source Code Documents]]
2. MySQL 使用文档 [[https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html][InnoDB Storage Engine]]
3. 专栏 [[https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2][MySQL 实战 45 讲]]
4. 三方库 [[https://gorm.io/docs/index.html][GORM]] | [[https://docs.spring.io/spring-data/jpa/docs/2.7.7/reference/html/][JPA]] | [[https://github.com/mybatis/mybatis-3][mybatis-3]]

*** 主从架构实验环境
**** 配置 Docker 环境
1. 安装 Docker Server
2. 参考文档 [[https://docs.docker.com/compose/install/other][Install the Compose standalone]] 安装 docker-compose
3. 编写启动配置文件 [[file:env-mysql/][MySQL 主备配置]]
4. docker hub [[https://hub.docker.com/_/mysql][mysql 镜像]]
5. 启动服务
#+BEGIN_SRC sh :dir env-mysql
  docker-compose up -d
#+END_SRC

**** 配置主备环境
***** 查看主备网络配置
#+BEGIN_SRC sh :results output
  docker inspect mysql-master | jq '.[0].NetworkSettings.Networks.dbnet.IPAddress'
  docker inspect mysql-slave  | jq '.[0].NetworkSettings.Networks.dbnet.IPAddress'
#+END_SRC

#+RESULTS:
: "172.20.0.100"
: "172.20.0.101"

查看主机网络
#+BEGIN_SRC sh
  docker network ls
#+END_SRC

#+RESULTS:
| NETWORK      | ID       | NAME   | DRIVER | SCOPE |
| e09faf7e7340 | dbnet    | bridge | local  |       |
| c21a61df1551 | none     | null   | local  |       |

***** 主库配置备库用户的访问权限
:properties:
:header-args:sql: :engine mysql :dbhost 127.0.0.1 :dbport 9001 :database test01 :dbuser root :dbpassword p111
:end:

#+BEGIN_SRC sql :results output
  create user "user02"@"%" identified by "user02";
  grant replication slave on *.* to "user02"@"%";
  flush privileges;
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql
  show master status
#+END_SRC

#+RESULTS:
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
|------------------+----------+--------------+------------------+-------------------|
| mysql-bin.000003 |      841 | test01       |                  |                   |

***** 备库同步配置
:properties:
:header-args:sql: :engine mysql :dbhost 127.0.0.1 :dbport 9002 :database test01 :dbuser root :dbpassword p222
:end:

#+BEGIN_SRC sql :results output
  # 这里的 host 等参数需要根据主库的配置修改
  -- change master to master_host='172.20.0.100', master_user='user02', master_password='user02', master_log_file='1.000003', master_log_pos=823;
  -- change master to master_host='mysql-master', master_user='user02', master_password='user02', master_log_file='mysql-bin.000003', master_log_pos=0;
  change master to master_host='mysql-master', master_user='user02', master_password='user02', master_log_file='mysql-bin.000003', master_log_pos=841;
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql :results output
   start slave;
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql :results output
  show slave status\G
#+END_SRC

#+RESULTS:
#+begin_example
,*************************** 1. row ***************************
               Slave_IO_State: Waiting for source to send event
                  Master_Host: mysql-master
                  Master_User: user02
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000003
          Read_Master_Log_Pos: 841
               Relay_Log_File: 1e8e597992df-relay-bin.000002
                Relay_Log_Pos: 326
        Relay_Master_Log_File: mysql-bin.000003
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 841
              Relay_Log_Space: 543
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 100
                  Master_UUID: 860a4dac-94f0-11ed-a2f3-0242ac140064
             Master_Info_File: mysql.slave_master_info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Replica has read all relay log; waiting for more updates
           Master_Retry_Count: 86400
                  Master_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Master_SSL_Crl:
           Master_SSL_Crlpath:
           Retrieved_Gtid_Set:
            Executed_Gtid_Set:
                Auto_Position: 0
         Replicate_Rewrite_DB:
                 Channel_Name:
           Master_TLS_Version:
       Master_public_key_path:
        Get_master_public_key: 0
            Network_Namespace:
#+end_example

如果出现这样的两行表示结果是正确的
#+begin_quote
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
#+end_quote

重置 slave
#+BEGIN_SRC sql :results output
  stop slave;
  reset slave;
#+END_SRC

***** 主库建表
:properties:
:header-args:sql: :engine mysql :dbhost 127.0.0.1 :dbport 9001 :database test01 :dbuser root :dbpassword p111
:end:

#+BEGIN_SRC sql :results output
  create table t (
    id int primary key auto_increment,
    c int
  );
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql :results output
  insert into t(c) values (1), (2), (3);
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql :results output
  delete from t where id < 10;
#+END_SRC

#+RESULTS:

***** 备库查询
:properties:
:header-args:sql: :engine mysql :dbhost 127.0.0.1 :dbport 9002 :database test01 :dbuser root :dbpassword p222
:end:

#+BEGIN_SRC sql
  select * from t;
#+END_SRC

**** 设置登录别名
#+BEGIN_SRC sh
  alias my1="MYSQL_PWD=p111   mysql -h127.0.0.1 -uroot -P9001"
  alias my2="MYSQL_PWD=p222   mysql -h127.0.0.1 -uroot -P9002"
  alias u01="MYSQL_PWD=user01 mysql -h127.0.0.1 -uuser01 -P9001 test01"
  alias u02="MYSQL_PWD=user02 mysql -h127.0.0.1 -uuser02 -P9002 test01"
  alias m100='docker exec -it mysql-master /bin/bash'
  alias m101='docker exec -it mysql-slave /bin/bash'
#+END_SRC

*** 运维主题
**** 创建用户 & 授权访问数据库
#+BEGIN_SRC sql
  create user 'jeffrey'@'%' identified by 'hello';
  grant all privileges on employees.* to 'jeffrey'@'%';
  flush privileges;
#+END_SRC

**** 查看当前用户权限
#+BEGIN_SRC sql
  select user, host from mysql.user;
#+END_SRC
**** 修改用户密码
#+BEGIN_SRC sql
  use mysql;
  set password for 'jeffrey'@'%' = password('root');
  update user set password = password('new.password') where user = 'jeffrey' and host = '%';
  update user set host = '%' where user = 'root';
  flush privileges;

  alter user 'jeffrey'@'%' identified by 'mypass';
#+END_SRC
**** 重建表
InnoDB 不支持直接优化表
#+BEGIN_EXAMPLE
  mysql> optimize table price_daily;
  +-----------------------------+----------+----------+-------------------------------------------------------------------+
  | Table                       | Op       | Msg_type | Msg_text                                                          |
  +-----------------------------+----------+----------+-------------------------------------------------------------------+
  | prod_alpen_dict.price_daily | optimize | note     | Table does not support optimize, doing recreate + analyze instead |
  | prod_alpen_dict.price_daily | optimize | status   | OK                                                                |
  +-----------------------------+----------+----------+-------------------------------------------------------------------+
#+END_EXAMPLE

InnoDB 需要重建后分析来优化表，对应 SQL 如下
#+BEGIN_SRC sql
  -- recreate
  alter table price_daily engine=innodb;
  -- analyze
  analyze table price_daily;
#+END_SRC

#+BEGIN_EXAMPLE
  mysql> alter table price_daily engine=innodb;
  Query OK, 0 rows affected (3 min 2.06 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  mysql> analyze table price_daily;
  +-----------------------------+---------+----------+----------+
  | Table                       | Op      | Msg_type | Msg_text |
  +-----------------------------+---------+----------+----------+
  | prod_alpen_dict.price_daily | analyze | status   | OK       |
  +-----------------------------+---------+----------+----------+
  1 row in set (0.04 sec)
#+END_EXAMPLE

*** 源码研究
1. 专栏 [[https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2][MySQL45]] | [[https://blog.jcole.us/innodb/][Data Structure]] | [[http://www.unofficialmysqlguide.com/introduction.html][Unofficial Optimizer Guide]]
2. [[file:mysql-source-code.org][MySQL 源码笔记]]
3. 示例数据库 [[https://dev.mysql.com/doc/employee/en/employees-installation.html][Employees Sample Database]] | [[https://github.com/datacharmer/test_db][Github]] | [[https://dev.mysql.com/doc/index-other.html][Example DB: world, sakila]]
4. 代码阅读分享
   - [[file:../mysql/share-01-mysql-group-by-analysis.org][GroupBy 语句实现原理探索]]
   - [[file:../mysql/share-02-mysql-optimize.org][MySQL 优化器实现原理探索]]
**** 安装编译调试环境
1. 系统依赖安装
   #+BEGIN_SRC sh
     # 安装依赖包
     yum update

     yum install -y net-tools vim tmux tree kernel-devel kernel-doc kernel-headers \
         samba samba-client ntp rsync curl git wget

     yum install -y binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc \
         glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXi \
         libXtst make sysstat unixODBC unixODBC-devel oracleasm-support zip unzip \
         python-devel python rpm-build redhat-rpm-config asciidoc hmaccalc \
         perl-ExtUtils-Embed pesign xmlto audit-libs-devel binutils-devel \
         elfutils-devel elfutils-libelf-devel ncurses-devel bison-devel newt-devel \
         python3 python3-devel \
         numactl-devel pciutils-devel python-devel zlib-devel readline-devel
   #+END_SRC
2. 编译工具安装 [[https://gcc.gnu.org/install/][GCC]] | [[https://www.sourceware.org/gdb/][GDB]]
   #+BEGIN_SRC sh
     # gcc
     wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-12.1.0/gcc-12.1.0.tar.gz
     # 下载 gcc 的依赖
     ./contrib/download_prerequisites
     # --enable-multilib 开启 32 位库支持
     ./configure --prefix=/usr/local/gcc --disable-multilib
     make
     make install

     # gdb
     wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/gdb-12.1.tar.gz
     ./configure --prefix=/usr/local/gdb
     make
     make install
   #+END_SRC
   添加环境变量
   #+BEGIN_SRC sh
     export PATH=/usr/local/gcc/bin:$PATH
     export LD_LIBRARY_PATH=/usr/local/gcc/lib64:$LD_LIBRARY_PATH
     export PATH=/usr/local/gdb/bin:$PATH
   #+END_SRC
4. cmake 安装 [[https://cmake.org/install/][CMake Install]]
   #+BEGIN_SRC sh
     # 下载代码
     curl -OL https://github.com/Kitware/CMake/releases/download/v3.25.2/cmake-3.25.2.tar.gz
     # 编译安装
     ./bootstrap --prefix=/usr/local/cmake
     make
     make install
   #+END_SRC
   添加环境变量
   #+BEGIN_SRC sh
     export PATH=/usr/local/cmake/bin:$PATH
   #+END_SRC
5. boost 下载并安装
   #+BEGIN_SRC sh
     wget -c https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.bz2
     tar xjvf boost_1_77_0.tar.bz2
   #+END_SRC
**** 编译代码及初始数据库
1. 参考资料 [[https://dev.mysql.com/doc/refman/8.0/en/source-installation.html][源代码安装文档]] | [[https://dev.mysql.com/doc/refman/8.0/en/making-trace-files.html][TRACE 文件]] | [[https://dev.mysql.com/doc/refman/8.0/en/using-gdb-on-mysqld.html][--gdb]] | [[https://dev.mysql.com/doc/dev/mysql-server/8.0.30/PAGE_OPT_TRACE.html][The Optimizer Trace]]
2. 配置文件 ~/etc/my.cnf~
   #+BEGIN_SRC conf
     # -* mode: Conf; -*-

     [mysqld]
     basedir=/opt/local/mysql
     datadir=/opt/local/mysql/data
     log-error=/tmp/mysql-error.log
     pid-file=/tmp/mysql.pid
     # debug=d,info,error,query,general,where:O,/tmp/mysqld.trace
     # debug=+d,info,error,query,general,enter,where:O,/tmp/mysqld.trace
     debug

     # autocommit=0
     innodb_lock_wait_timeout=3600
     # long_query_time = 0
     slow_query_log = on
     slow_query_log_file = /tmp/mysql-slow.log
     # secure_file_priv = /tmp

     [client]
     user=root
   #+END_SRC
2. 编译源代码
   #+BEGIN_SRC sh
     # 准备代码编译目录, 输出目录为 out
     mkdir out
     cd out
     cmake -DCMAKE_INSTALL_PREFIX=/opt/local/mysql -DWITH_BOOST=../../boost/boost_1_77_0 -DWITH_DEBUG=1 -DWITH_UNIT_TESTS=0 ..
     # 编译代码
     cd out
     make -j8
     make install
   #+END_SRC
3. 初始化数据库
   #+BEGIN_SRC sh
     # 初始化数据库
     mysqld --defaults-file=/etc/my.cnf --initialize-insecure

     # https://dev.mysql.com/doc/refman/8.0/en/starting-server.html
     # 启动数据库数据库, --gdb 是开启 gdb 调试支持
     # --debug=d,info,error,query,general,where:O,/tmp/mysqld.trace
     mysqld --gdb >/dev/null 2>&1 &

     # 链接数据库
     mysql
     # 关闭数据库
     mysqladmin shutdown
   #+END_SRC
**** 代码阅读配置
#+BEGIN_SRC sh
  # 生成跳转的 TAG
  ctags -e -R --languages=c,c++ .
#+END_SRC

** Postgres
*** 前置环境变量
#+BEGIN_SRC sh
  export PGDATA=/opt/local/pgsql/data
#+END_SRC
*** 编译调试 & 初始化数据
#+BEGIN_SRC sh
  # 配置调试环境
  ./configure --prefix=/opt/local/pgsql --enable-cassert --enable-debug CFLAGS="-ggdb -O0 -fno-omit-frame-pointer"
  # 编译, 安装
  make -j8
  make install
#+END_SRC

#+BEGIN_SRC sh
  # 初始化数据库
  initdb -D /opt/local/pgsql/data
  # 启动数据库
  pg_ctl -D /opt/local/pgsql/data -l logfile start
  # 创建库
  createdb test01
  # 链接库
  psql test01
#+END_SRC
*** 调试命令
找到对应的进程
#+BEGIN_SRC sh :results output :exports both
  $ ps aux | grep postgres
  jinghuihu        87208   0.0  0.0 34130524    676 s006  S+   12:13PM   0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox postgres
  jinghuihu        82329   0.0  0.2 34313316  36860   ??  Ss   10:51AM   0:00.16 postgres: jinghuihu test01 [local] idle
  jinghuihu        82278   0.0  0.0 34309036   1792   ??  Ss   10:51AM   0:00.00 postgres: logical replication launcher
  jinghuihu        82277   0.0  0.0 34310060   2136   ??  Ss   10:51AM   0:00.02 postgres: autovacuum launcher
  jinghuihu        82276   0.0  0.0 34307820   5152   ??  Ss   10:51AM   0:00.04 postgres: walwriter
  jinghuihu        82275   0.0  0.0 34307820   2212   ??  Ss   10:51AM   0:00.06 postgres: background writer
  jinghuihu        82274   0.0  0.0 34307820   2788   ??  Ss   10:51AM   0:00.01 postgres: checkpointer
  jinghuihu        80299   0.0  0.1 34309108  14920   ??  Ss   10:41AM   0:00.13 /opt/local/pgsql/bin/postgres -D /opt/local/pgsql/data
#+END_SRC

找到对应的进程，然后使用 lldb attach 上，打断点
#+BEGIN_SRC text
  (lldb) attach -p 82329
  Process 82329 stopped
  ,* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
      frame #0: 0x00007ff810e892fe libsystem_kernel.dylib`kevent + 10
  libsystem_kernel.dylib`kevent:
  ->  0x7ff810e892fe <+10>: jae    0x7ff810e89308            ; <+20>
      0x7ff810e89300 <+12>: movq   %rax, %rdi
      0x7ff810e89303 <+15>: jmp    0x7ff810e84dc2            ; cerror_nocancel
      0x7ff810e89308 <+20>: retq
  Target 0: (postgres) stopped.
  Executable module set to "/opt/local/pgsql/bin/postgres".
  Architecture set to: x86_64h-apple-macosx-.
  (lldb) b exec_simple_query
  Breakpoint 1: where = postgres`exec_simple_query + 29 at postgres.c:994:21, address = 0x000000010f17af6d
  (lldb) c
  Process 82329 resuming
  Process 82329 stopped
  ,* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
      frame #0: 0x000000010f17af6d postgres`exec_simple_query + 29 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/tcop/postgres.c:994
     991  static void
     992  exec_simple_query(const char *query_string)
     993  {
  -> 994      CommandDest dest = whereToSendOutput;
                                 ^
     995      MemoryContext oldcontext;
     996      List	   *parsetree_list;
     997      ListCell   *parsetree_item;
  Target 0: (postgres) stopped.
  (lldb)  bt
  ,* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    ,* frame #0: 0x000000010f17af6d postgres`exec_simple_query + 29 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/tcop/postgres.c:994
      frame #1: 0x000000010f17a633 postgres`PostgresMain + 2243 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/tcop/postgres.c:4593
      frame #2: 0x000000010f08d0d2 postgres`BackendRun + 50 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/postmaster/postmaster.c:4511
      frame #3: 0x000000010f08c6bc postgres`BackendStartup + 524 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/postmaster/postmaster.c:4239
      frame #4: 0x000000010f08b4ec postgres`ServerLoop + 716 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/postmaster/postmaster.c:1806
      frame #5: 0x000000010f088dc7 postgres`PostmasterMain + 6471 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/postmaster/postmaster.c:1478
      frame #6: 0x000000010ef6eda0 postgres`main + 816 at /Users/jinghuihu/code/jeanhwea/postgres/src/backend/main/main.c:202
      frame #7: 0x00007ff810b92310 dyld`start + 2432
  (lldb) c
  Process 82329 resuming
  (lldb) detach
  Process 82329 detached
  (lldb)
#+END_SRC

** ClickHouse
*** 安装步骤
1. 官方文档 [[https://clickhouse.com/docs/en/install][doc]]
#+BEGIN_SRC sh
  # https://clickhouse.com/docs/en/development/build-osx
  cmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo -S . -B build
#+END_SRC
** nginx
*** 文件配置
#+BEGIN_SRC conf
  location /api {
    client_max_body_size 30000M;
    client_body_buffer_size 200000k;
    proxy_pass  http://api/supercap/pipe;
    client_body_temp_path /media/ss/synology_office/server_Seq-Cap/tmp_nginx;
  }
#+END_SRC

* 系统运维
** Docker
*** Docker 安装过程
安装参考链接 [[https://docs.docker.com/engine/install/centos/#install-using-the-repository][link]]
#+BEGIN_SRC sh
  yum install -y yum-utils
  yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

  yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
#+END_SRC
*** Engine 配置
安装文档 [[https://docs.docker.com/engine/install/ubuntu/][link]]
#+BEGIN_SRC sh
  vim /etc/docker/daemon.json
  systemctl restart docker
#+END_SRC

daemon.json 配置
#+BEGIN_SRC json
  {
    "insecure-registries": [
      "gitana.jeanhwea.io:5000"
    ]
  }
#+END_SRC

*** 国内镜像
daemon.json 配置
#+BEGIN_SRC json
  {
    "registry-mirrors": [
      "https://registry.docker-cn.com",
      "https://docker.mirrors.ustc.edu.cn",
      "http://hub-mirror.c.163.com"
    ]
  }
#+END_SRC

** Kubernetes
*** minikube
1. [[https://minikube.sigs.k8s.io/docs/][文档中心]]
配置
#+BEGIN_SRC sh
  brew install minikube
  minikube start
#+END_SRC

#+BEGIN_SRC sh
  minikube dashboard
#+END_SRC
*** kubeadm
系统安装
#+BEGIN_SRC sh
  # 创建 master 集群
  kubeadm init --apiserver-advertise-address=192.168.0.210 \
          --pod-network-cidr=10.244.0.0/16 \
          --kubernetes-version 1.27.2 \
          --image-repository registry.aliyuncs.com/google_containers

  # 遇到错误重置
  kubeadm reset
#+END_SRC

查看使用到的镜像
#+BEGIN_SRC sh
  kubeadm config images list
  kubeadm config images pull --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
  kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers
#+END_SRC

新增 node 节点
#+BEGIN_SRC sh
  kubeadm token create --print-join-command
#+END_SRC

*** kubectl
**** 快速开始
快速启动一个测试服务
#+BEGIN_SRC sh
  # 创建部署
  kubectl create deployment sayhello --image=jeanhwea/sayhello:v1.0.0
  kubectl create deployment sayhello --image=jeanhwea/sayhello:v1.0.0 -r 4

  # 通过 NodePort 暴露服务
  kubectl expose deployment sayhello --port=80 --type=NodePort

  # 动态扩容
  kubectl scale  deployment sayhello --replicas=4
#+END_SRC

获取启动的 Service
#+BEGIN_SRC sh :results output
  kubectl get svc
#+END_SRC

#+RESULTS:
: NAME          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
: kubernetes    ClusterIP   10.96.0.1       <none>        443/TCP        122d
: web-gateway   NodePort    10.98.232.246   <none>        80:31151/TCP   8m1s

#+BEGIN_SRC sh
  # 登录到 minikube shell
  minikube ssh
  # 在 NameNode 中获取页面
  curl http://0.0.0.0:31151
#+END_SRC

#+BEGIN_SRC sh
  # Service 对象的域名完全形式是 "对象.名字空间.svc.cluster.local"
  wget -qO- sayhello.default.svc.cluster.local
#+END_SRC
**** 配置 DashBoard
#+BEGIN_SRC sh
  wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
  # 安装 dashboard
  kubectl apply -f recommended.yaml
  # 卸载 dashboard
  kubectl delete -f recommended.yaml
  kubectl get pods,svc -n kubernetes-dashboard
#+END_SRC

**** 查看 Pod
#+BEGIN_SRC sh :results output
  kubectl get pods -A
  # 登录到 pod 上排查问题
  kubectl exec -it sayhello-847d5df547-4bk9z -- /bin/bash
#+END_SRC

#+RESULTS:
: NAMESPACE     NAME                               READY   STATUS    RESTARTS      AGE
: kube-system   coredns-787d4945fb-g688w           1/1     Running   0             50s
: kube-system   etcd-minikube                      1/1     Running   0             65s
: kube-system   kube-apiserver-minikube            1/1     Running   0             57s
: kube-system   kube-controller-manager-minikube   1/1     Running   0             56s
: kube-system   kube-proxy-4ph9m                   1/1     Running   0             50s
: kube-system   kube-scheduler-minikube            1/1     Running   0             57s
: kube-system   storage-provisioner                1/1     Running   1 (18s ago)   54s

**** 创建 Job
获取一个基础的 yaml
#+BEGIN_SRC sh
  kubectl create job echo-job --image=busybox --dry-run=client -o yaml
#+END_SRC

修改得到配置
#+BEGIN_SRC yaml
  apiVersion: batch/v1
  kind: Job
  metadata:
    name: echo-job

  spec:
    template:
     spec:
        restartPolicy: OnFailure
        containers:
        - image: busybox
          name: echo-job
          imagePullPolicy: IfNotPresent
          command: ["/bin/echo"]
          args: ["hello", "world"]
#+END_SRC

**** 配置 ConfigMap
#+BEGIN_SRC sh
  kubectl get cm
  kubectl describe cm config01
#+END_SRC

*** 包管理工具 helm
1. k8s 包管理器: helm [[https://helm.sh/][link]]
   #+BEGIN_SRC sh
     helm repo add bitnami https://charts.bitnami.com/bitnami
     helm repo update
     helm install bitnami/mysql --generate-name
     helm show all bitnami/mysql
     helm list
     helm uninstall mysql-1686374196
   #+END_SRC

** 磁盘管理
*** 启动盘制作
1. 启动盘制作工具 rufus [[https://rufus.ie/zh/][link]] | [[https://github.com/pbatard/rufus][code]]
2. 光盘提取工具 InfraRecorder [[http://infrarecorder.org/][link]] | [[https://github.com/kindahl/infrarecorder][code]]
*** Ubuntu 磁盘分区扩容
使用 parted, resize2fs 命令行工具进行操作
#+BEGIN_SRC sh
  root@ubuntu201:/home/ubuntu# parted
  GNU Parted 3.4
  Using /dev/sda
  Welcome to GNU Parted! Type 'help' to view a list of commands.
  (parted) print                 # ==> 查看当前磁盘分区信息
  Model: VMware Virtual disk (scsi)
  Disk /dev/sda: 215GB
  Sector size (logical/physical): 512B/512B
  Partition Table: gpt
  Disk Flags:

  Number  Start   End     Size    File system  Name  Flags
   1      1049kB  2097kB  1049kB                     bios_grub
   2      2097kB  53.7GB  53.7GB  ext4

  (parted) resizepart            # ==> 扩容分区 2
  Partition number? 2
  Warning: Partition /dev/sda2 is being used. Are you sure you want to continue?
  Yes/No? Yes
  End?  [53.7GB]? 215GB          # ==> 这里扩容到最大可见分区
  (parted) print                 # ==> 扩容后的分区 2 变成 215G
  Model: VMware Virtual disk (scsi)
  Disk /dev/sda: 215GB
  Sector size (logical/physical): 512B/512B
  Partition Table: gpt
  Disk Flags:

  Number  Start   End     Size    File system  Name  Flags
   1      1049kB  2097kB  1049kB                     bios_grub
   2      2097kB  215GB   215GB   ext4

  (parted)

  Information: You may need to update /etc/fstab.

  root@ubuntu201:/home/ubuntu# df -h # ==> 文件系统并未扩容
  Filesystem      Size  Used Avail Use% Mounted on
  tmpfs           1.6G  1.2M  1.6G   1% /run
  /dev/sda2        49G   44G  3.1G  94% /
  tmpfs           7.8G     0  7.8G   0% /dev/shm
  tmpfs           5.0M     0  5.0M   0% /run/lock
  tmpfs           1.6G  4.0K  1.6G   1% /run/user/1000
  root@ubuntu201:/home/ubuntu# resize2fs /dev/sda2 # ==> 调整文件系统大小
  resize2fs 1.46.5 (30-Dec-2021)
  Filesystem at /dev/sda2 is mounted on /; on-line resizing required
  old_desc_blocks = 7, new_desc_blocks = 25
  The filesystem on /dev/sda2 is now 52428283 (4k) blocks long.

  root@ubuntu201:/home/ubuntu# df -h
  Filesystem      Size  Used Avail Use% Mounted on
  tmpfs           1.6G  1.2M  1.6G   1% /run
  /dev/sda2       197G   44G  145G  24% /
  tmpfs           7.8G     0  7.8G   0% /dev/shm
  tmpfs           5.0M     0  5.0M   0% /run/lock
  tmpfs           1.6G  4.0K  1.6G   1% /run/user/1000
  root@ubuntu201:/home/ubuntu# reboot
#+END_SRC
** 压缩/解压
解压
#+BEGIN_SRC sh
  tar xjvf node-v18.16.1-linux-x64.tar.bz2
  tar xzvf node-v18.16.1-linux-x64.tar.gz
  tar xJvf node-v18.16.1-linux-x64.tar.xz
  gzip -d app.log.2023-07-07.0.gz
#+END_SRC

压缩
#+BEGIN_SRC sh
  tar czvf pack.tar.gz pack
  gzip app.log.2023-07-07.0
#+END_SRC

* 前端研发
** Node
#+BEGIN_SRC sh
  sudo apt install nodejs npm
  mkdir ~/.local/node_modules
  npm config set prefix '~/.local/node_modules'
#+END_SRC

使用 nvm 管理 node
#+BEGIN_SRC sh
  export PATH=$HOME/.local/node_modules/bin:$PATH
  npm i -g nvm
  nvm install node
#+END_SRC

** Node Windows 配置
- 安装 node-v14.21.3-x64.msi [[https://npmmirror.com/mirrors/node/][link]]
- 配置环境变量
  #+BEGIN_SRC sh
    npm config set prefix "X:\Program Files\nodejs\node_global"
    npm config set cache  "X:\Program Files\nodejs\node_cache"
  #+END_SRC
- 安装 yarn
  #+BEGIN_SRC sh
    npm i -g yarn
  #+END_SRC

** 国内镜像
配置 taobao 镜像
- 旧版 https://registry.npm.taobao.org
- 新版 http://registry.npmmirror.com
- NPM MIRROR 镜像站 [[https://npmmirror.com/][link]]
#+BEGIN_SRC shell
  npm config set registry http://registry.npmmirror.com
  yarn config set registry http://registry.npmmirror.com
#+END_SRC

设置 electron 地址
#+BEGIN_SRC sh
  yarn config set electron_mirror=https://npm.taobao.org/mirrors/electron/
  yarn config set electron_builder_binaries_mirror=https://npm.taobao.org/mirrors/electron-builder-binaries/
#+END_SRC

#+BEGIN_SRC sh
  yarn config set electron_mirror https://mirrors.huaweicloud.com/electron/
  yarn config set electron_builder_binaries_mirror https://mirrors.huaweicloud.com/electron-builder-binaries/
#+END_SRC

** UI 库
1. [[https://pro.ant.design/zh-CN/docs/getting-started/][Ant Design Pro]]
   #+BEGIN_SRC sh
     npm i @ant-design/pro-cli -g
     pro create myapp
   #+END_SRC

* 操作系统
** WSL
*** Ubuntu 安装并迁移到其他盘
1. 安装说明 [[https://learn.microsoft.com/zh-cn/windows/wsl/install-manual][link]]
2. 移动数据文件到非系统盘
   #+BEGIN_SRC sh
     # 查看当前的 wsl 容器
     wsl -l -v

     wsl --export Ubuntu ubuntu2204.tar
     wsl --unregister Ubuntu

     mkdir data
     wsl --import Ubuntu-22.04 data ubuntu2204.tar
   #+END_SRC
*** Docker 无法启动
/usr/sbin/iptables-nft 网络管理 WSL2 不支持，需要修改一下
#+BEGIN_SRC sh
  $ sudo update-alternatives --config iptables
  There are 2 choices for the alternative iptables (providing /usr/sbin/iptables).

    Selection    Path                       Priority   Status
  ------------------------------------------------------------
  ,* 0            /usr/sbin/iptables-nft      20        auto mode
    1            /usr/sbin/iptables-legacy   10        manual mode
    2            /usr/sbin/iptables-nft      20        manual mode

  Press <enter> to keep the current choice[*], or type selection number: 1
  update-alternatives: using /usr/sbin/iptables-legacy to provide /usr/sbin/iptables (iptables) in manual mode
  $ sudo service docker start
   ,* Starting Docker: docker                                                                                                                                            [ OK ]
  $ docker ps
  CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
#+END_SRC
*** 缺失字体
默认添加 Windows 自带的字体来显示缺失字体
#+BEGIN_SRC sh
  sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/host
  fc-cache -fv
#+END_SRC

*** 挂载共享服务器
#+BEGIN_SRC sh
 sudo mount -t drvfs '\\192.168.0.201\开发服务器共享' /mnt/share
#+END_SRC
*** 解决提示符错误
Windows Terminal 在安装 zsh-autosuggestions 时会显示的有问题，这里修改一下 ~PS1~
#+BEGIN_SRC sh
  ZSH_THEME="none"
  export PS1='WSL(%3~)%# '
#+END_SRC
** CentOS
*** SCL (Software Collection)
SCL 提供一下较新的工具集 [[https://wiki.centos.org/AdditionalResources/Repositories/SCL][link]]
#+BEGIN_SRC sql
  yum install centos-release-scl

  yum makecache
  yum repolist
#+END_SRC

*** Red Hat Developer Toolset
1. 使用手册 [[https://access.redhat.com/documentation/en-us/red_hat_developer_toolset/11/html-single/user_guide/index#doc-wrapper][User Guide]]
   #+BEGIN_SRC sh
     yum install scl-utils centos-release-scl

     yum list all --enablerepo='centos-sclo-rh' | grep "devtoolset"
     yum install devtoolset-11-toolchain
   #+END_SRC
2. 配置并启用 scl 工具集
   #+BEGIN_SRC sh
     scl --list
     scl enable devtoolset-11 bash
   #+END_SRC
** Manjaro
* 日常使用
** Emacs
*** 参考资料
1. 精选插件列表 [[https://github.com/emacs-tw/awesome-emacs][Awesome Emcas]]
2. Emacs Windows Binary [[http://mirrors.ustc.edu.cn/gnu/emacs/windows/][emacs-windows]]
*** 任务管理
1. 表格 [[info:org#The Spreadsheet][org#The Spreadsheet]]
   - 单元格公式: 输入 ~:=~ 后在单元格中直接编辑公式，或者 ~C-u C-c =~
   - 列公式: 输入 ~=~ 后在单元格中直接编辑公式，或者 ~C-c =~
   - 显示坐标: ~C-c }~
2. 绘图 [[info:org#Org Plot][org#Org Plot]]
3. 待办实现管理 [[info:org#TODO dependencies][org#TODO dependencies]]
4. 标签系统 [[info:org#Tags][org#Tags]]
5. 代码管理 [[info:org#Working with Source Code][org#Working with Source Code]]
6. buffer 设置 [[info:org#In-buffer Settings][org#In-buffer Settings]]
   - #+STARTUP: 启动设置
     #+BEGIN_QUOTE
       #+STARTUP: indent cache num inlineimages
     #+END_QUOTE
*** 绘图
**** graphviz
***** 参考连接
1. 图库 [[http://graphviz.org/gallery/][Gallery]]
2. [[file:../article/drawing-graphs-with-dot.org::+TITLE: 使用 dot 画图工具][文章]] | 快速入门 [[https://www.graphviz.org/pdf/dotguide.pdf][Drawing graphs with dot]]
3. 属性参考文档 [[http://www.graphviz.org/doc/info/attrs.html][Attrs]]
***** 无向图
#+BEGIN_SRC dot :exports results :file ../static/image/2023/0201/000024.png
  graph {
    A -- B -- C -- D;
    A -- C;
  }
#+END_SRC

#+RESULTS:
[[file:../static/image/2023/0201/000024.png]]

***** 有向图
#+BEGIN_SRC dot :exports results :file ../static/image/2023/0201/000219.png
  digraph {
    A -> B;
    A -> C;
    A -> D;
    B -> D;
  }
#+END_SRC

#+RESULTS:
[[file:../static/image/2023/0201/000219.png]]

***** 支持中文
#+BEGIN_SRC dot :exports results :file ../static/image/2023/0201/001233.png
  digraph {
    node [fontname="Microsoft Yahei"];
    outsys [label="外部系统"];
    innersys [label="内部系统"];
    outsys -> innersys;
  }
#+END_SRC

#+RESULTS:
[[file:../static/image/2023/0201/001233.png]]

***** 系统交互图
#+BEGIN_SRC dot :exports results :file ../static/image/2023/0201/001954.png
    digraph {
      size="8,8";
      node [fontname="Microsoft Yahei"];

      subgraph cluster_metadata {
        label = "元数据管理模块"; color = "lightgray"; style = "filled";
        module_meta_data [shape=record label="治理数据 | {Servie | Module | Field}"];
        module_meta_status [label="治理状态"];
        module_work_order [label="工单管理"];
      }

      subgraph cluster_detector {
        label = "劣化探测模块"; color = "lightgray"; style = "filled";
        module_data_preload [label="数据准备"];
        module_intern_checker [label="内置检测器"];
        module_extern_checker [label="外置检测器"];
      }

      module_data_preload -> module_intern_checker;
      module_data_preload -> module_extern_checker;

      module_data_preload -> module_meta_data [label="取"];
    }
#+END_SRC

#+RESULTS:
[[file:../static/image/2023/0201/001954.png]]
**** plantuml
1. [[http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html][Tutor]] | [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-plantuml.html][Official]]
*** 批量删除 ^M 方法
#+BEGIN_EXAMPLE
  M-x replace-string RET C-q C-m RET RET
#+END_EXAMPLE
*** tramp ssh 到远程
配置远端 ~/.ssh/config, 添加别名
#+BEGIN_SRC text
  Host gitana
      Hostname gitana.jeanhwea.io
      Port 2222
      User admin
#+END_SRC

或者使用如下的 scheme 来访问, [[info:tramp#File name syntax][tramp#File name syntax]]
#+BEGIN_EXAMPLE
  M-x find-file /sshx:user@host#port:/path
#+END_EXAMPLE

*** 设置文件类型
#+BEGIN_SRC text
  # -*- mode: conf; -*-
#+END_SRC

*** 设置本地文件配置
.dir-locals.el
#+BEGIN_SRC elisp
  ((java-mode . ((eval . (eglot-ensure)))))
#+END_SRC
*** 编辑二进制文件
#+BEGIN_EXAMPLE
  M-x hexl-mode
#+END_EXAMPLE

*** elisp 函数增强
1. 增强 defadvice [[info:elisp#Advising Functions][elisp#Advising Functions]]
2. 闭包 [[info:elisp#Closures][elisp#Closures]]

*** 设置文件显示自动换行
#+BEGIN_EXAMPLE
  M-x toggle-truncate-lines
#+END_EXAMPLE

*** libvterm 编译失败
#+BEGIN_EXAMPLE
  -- System libvterm not found: libvterm will be downloaded and compiled as part of the build process
  CMake Error at CMakeLists.txt:71 (message):
    libtool not found.  Please install libtool


  -- Configuring incomplete, errors occurred!
  See also "/home/jeffrey/.emacs.d/elpa/vterm-20230417.424/build/CMakeFiles/CMakeOutput.log".
  make: *** No targets specified and no makefile found.  Stop.
  /home/jeffrey/.emacs.d/elpa/vterm-20230417.424
#+END_EXAMPLE

解决方法，安装对应库
#+BEGIN_SRC sh
  sudo apt install cmake libtool libtool-bin
#+END_SRC

** Linux
*** tar: time stamp XXX in the future
如果解压时发现待解压的机器的时间戳较慢，会出现如下报错
#+BEGIN_EXAMPLE
  tar: ./app.jar: time stamp 2023-08-21 08:17:50 is 223.674040911 s in the future
  tar: ./version: time stamp 2023-08-21 08:17:50 is 223.673692569 s in the future
#+END_EXAMPLE

可以在 tar 命令中添加 -m 来忽略时间戳问题
#+BEGIN_SRC sh
  tar xzmf file.tar.gz
#+END_SRC

** 前端
*** digital envelope routines::unsupported
OpenSSL3.0 对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响
#+BEGIN_SRC text
node:internal/crypto/hash:67
  this[kHandle] = new _Hash(algorithm, xofLen);
                  ^

Error: error:0308010C:digital envelope routines::unsupported
    at new Hash (node:internal/crypto/hash:67:19)
    at Object.createHash (node:crypto:130:10)
#+END_SRC

解决方法
#+BEGIN_SRC sh
  export NODE_OPTIONS=--openssl-legacy-provider
#+END_SRC

** 后端
*** RuntimeError: 'cryptography' package is required for sha256_password or caching_sha2_password auth methods
#+BEGIN_EXAMPLE
    File "/usr/local/lib/python3.11/site-packages/pymysql/_auth.py", line 143, in sha2_rsa_encrypt
      raise RuntimeError(
  RuntimeError: 'cryptography' package is required for sha256_password or caching_sha2_password auth methods
#+END_EXAMPLE

缺少 cryptography 包，安装一下
#+BEGIN_SRC sh
  pip install cryptography
#+END_SRC

** 科学上网
*** githubusercontent 链接失败
/etc/hosts
#+BEGIN_SRC sh
  185.199.108.133 raw.githubusercontent.com
#+END_SRC
** 使用体验
*** Esc 键有延迟
问题说明 [[https://www.johnhawthorn.com/2012/09/vi-escape-delays/][Eliminating delays on ESC in vim and zsh]]
尝试按照以下思路解决这个问题
vim
#+BEGIN_SRC text
  set timeoutlen=1000 ttimeoutlen=0
#+END_SRC
zsh
#+BEGIN_SRC sh
  # 10ms for key sequences
  KEYTIMEOUT=1
#+END_SRC
tmux
#+BEGIN_SRC sh
  # .tmux.conf
  set -s escape-time 0
  echo 'set -s escape-time 0' >> ~/.tmux.conf
#+END_SRC
** CentOS
*** 安装中文字体
修改配置文件
#+BEGIN_SRC sh
  vim /etc/fonts/fonts.conf
#+END_SRC

添加字体文件目录配置
#+BEGIN_SRC xml
  <!-- Font directory list -->

          <dir>/usr/share/fonts</dir>
          <dir>/usr/share/fonts/Fonts/</dir>
          <dir>/usr/share/X11/fonts/Type1</dir>
          <dir>/usr/share/X11/fonts/TTF</dir>
          <dir>/usr/local/share/fonts</dir>
          <dir prefix="xdg">fonts</dir>
          <!-- the following element will be removed in the future -->
          <dir>~/.fonts</dir>
#+END_SRC

使用命令刷新字体缓存
#+BEGIN_SRC sh
  cd /usr/share/fonts
  tar xzvf fonts.tar.gz
  fc-cache -fv
  # 查看中文字体
  fc-list :lang=zh
#+END_SRC

如果发现找不到字体配置文件，需要手工添加环境变量
Fontconfig error: Cannot load default config file
#+BEGIN_SRC sh
  export FONTCONFIG_PATH=/etc/fonts
#+END_SRC

*** 硬件时钟 hwclock
#+BEGIN_SRC sh
  # Display hwclock
  hwclock --show

  # Sync hwclock to system
  hwclock --hctosys

  # Save clock, for reboot
  clock -w
  hwclock -w
#+END_SRC

** MySQL
*** Public Key Retrieval is not allowed
在设置数据库添加如下的链接选项
#+BEGIN_SRC text
  allowPublicKeyRetrieval=true
#+END_SRC
** Docker
*** 文件夹递归复制
#+BEGIN_SRC dockerfile
  # 正确地递归复制文件夹方案
  COPY src/  target/

  # 以下两种不和递归复制
  COPY src/* target
  COPY src   target
#+END_SRC

** GDB
*** MacOS: 证书错误问题 [[https://timnash.co.uk/getting-gdb-to-semi-reliably-work-on-mojave-macos/][(^-^)]]
#+BEGIN_QUOTE
  please check gdb is codesigned - see taskgated(8)
#+END_QUOTE
手工编写 gdb.xml
#+BEGIN_SRC xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
      <key>com.apple.security.cs.allow-jit</key>
      <true/>
      <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
      <true/>
      <key>com.apple.security.cs.allow-dyld-environment-variables</key>
      <true/>
      <key>com.apple.security.cs.disable-library-validation</key>
      <true/>
      <key>com.apple.security.cs.disable-executable-page-protection</key>
      <true/>
      <key>com.apple.security.cs.debugger</key>
      <true/>
      <key>com.apple.security.get-task-allow</key>
      <true/>
  </dict>
  </plist>
#+END_SRC
使用命令给 gdb 添加证书
#+BEGIN_SRC sh
  codesign --entitlements gdb.xml -fs gdb-cert /usr/local/bin/gdb
#+END_SRC

官网说明 [[https://sourceware.org/gdb/wiki/PermissionsDarwin][gdb permission]]

*** Remote 'g' packet reply is too long
解决方法参考 [[https://wiki.osdev.org/QEMU_and_GDB_in_long_mode#:~:text=When%20the%20break%20point%20is%20hit%20and%20the,architecture%20names%20in%20those%20two%20%22set%20arch%22%20commands.][link]]

方案一，启动时配置
#+BEGIN_SRC sh
  $ gdb
  (gdb) set arch i386:x86-64:intel
  (gdb) target remote localhost:1234
  (gdb) symbol-file YOUR_KERNEL_FILE
  (gdb) break SOME_FUNCTION_IN_LONG_MODE
  (gdb) continue
#+END_SRC

方案二，修补源码, 修改 gdb/remote.c 的代码后重新编译
#+BEGIN_SRC text
  --- gdb/remote.c        2016-04-14 11:13:49.962628700 +0300
  +++ gdb/remote.c	2016-04-14 11:15:38.257783400 +0300
  @@ -7181,8 +7181,28 @@
     buf_len = strlen (rs->buf);

     /* Further sanity checks, with knowledge of the architecture.  */
  +// HACKFIX for changing architectures for qemu. It's ugly. Don't use, unless you have to.
  +  // Just a tiny modification of the patch of Matias Vara (http://forum.osdev.org/viewtopic.php?f=13&p=177644)
     if (buf_len > 2 * rsa->sizeof_g_packet)
  -    error (_("Remote 'g' packet reply is too long: %s"), rs->buf);
  +    {
  +      warning (_("Assuming long-mode change. [Remote 'g' packet reply is too long: %s]"), rs->buf);
  +      rsa->sizeof_g_packet = buf_len ;
  +
  +      for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
  +        {
  +          if (rsa->regs[i].pnum == -1)
  +            continue;
  +
  +          if (rsa->regs[i].offset >= rsa->sizeof_g_packet)
  +            rsa->regs[i].in_g_packet = 0;
  +          else
  +            rsa->regs[i].in_g_packet = 1;
  +        }
  +
  +      // HACKFIX: Make sure at least the lower half of EIP is set correctly, so the proper
  +      // breakpoint is recognized (and triggered).
  +      rsa->regs[8].offset = 16*8;
  +    }

     /* Save the size of the packet sent to us by the target.  It is used
        as a heuristic when determining the max size of packets that the
#+END_SRC
