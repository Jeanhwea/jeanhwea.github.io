#+TITLE: Spring全家桶
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2019-07-10 Wed 11:04:00>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: springboot web framework spring-boot spring-mvc jpa


* Spring Framework
  [[https://spring.io/projects/spring-framework][Spring Framework]] 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框
  架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE
  应用程序开发提供集成的框架。

  [[file:../static/image/2019/07/spring-projects.png]]

** Spring 的技术点和优点
   作为 Java Web 开发的龙头老大， Spring 的优点是不需要打广告了，Spring
   Framework 官网上给出了一下技术要点

   1. 核心技术：依赖注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP
   2. 测试：模拟对象，TestContext 框架，Spring MVC 测试，WebTestClient
   3. 数据访问：事务，DAO 支持，JDBC，ORM，编组 XML
   4. [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc][Spring MVC]] 和 SpringWebFlux Web 框架
   5. 整合：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存
   6. 语言：Kotlin，Groovy，动态语言
   [[file:../static/image/2019/08/springmvc-documentation.png]]

   Spring 的技术点很多，被很多人在工作中应用。这显然是离不开 Spring 团队优秀的设
   计，以下是 Spring Framework 的几个比较突出的优点：
   1. 轻量级：Spring 在大小和透明性方面绝对属于轻量级的，基础版本的 Spring 框架
      大约只有 2MB
   2. 控制反转(IoC)：Spring 使用控制反转技术实现了松耦合。依赖被注入到对象，而不
      是创建或寻找依赖对象
   3. 面向切面编程(AOP)： Spring 支持面向切面编程，同时把应用的业务逻辑与系统的
      服务分离开来
   4. 容器：Spring 包含并管理应用程序对象的配置及生命周期
   5. MVC 框架：Spring 的 Web 框架是一个设计优良的 Web MVC 框架，很好的取代了一
      些 Web 框架
   6. 事务管理：Spring 对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口
   7. 异常处理：Spring 提供一个方便的 API 将特定技术的异常(由 JDBC, Hibernate,或
      JDO 抛出)转化为一致的、Unchecked 异常

** IoC (Inversion of Control)
   - IoC 也被称为 DI (dependency injection)，是实现 bean 的依赖关系，即在初始化
     一个 IoC 容器时，先将其依赖的容器一并初始化，并注入的新的容器中。
   - IoC 的好处是可以自动管理 Java 类的示例，提升开发速度
   - Spring 管类的实例叫 Bean，Spring 提供了一系列方法来管理 Bean，其中包括：
     - BeanFactory Bean 的工厂，ApplicationContext 应用运行的上下文。注意：
       ApplicationContext 和 BeanFactory 都能实例化 Bean，但是一般尽量使用
       ApplicationContext，因为 ApplicationContext 还额外提供了一些其他功能，如：
       继承生命周期管理，BeanPostProcessor 自动注册，BeanFactoryPostProcessor 等
     - 还有一些 XML 配置类的解析，XML 配置相当于 Spring 构建 Bean 的蓝图，早期
       Spring 都用 XML 来配置类，但是由于太复杂，现在已经被 Java 的注解所代替

** 容器 Container 和 Bean
   Spring Framework 提供了管理 Bean 的接口 ApplicationContext，也就是说 Bean 的
   初始化都是在 ApplicationContext 的实现中处理的，比如：
   ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 都对
   ApplicationContext 进行实现，这些 ApplicationContext 是装在 Bean 的，所以被称
   为容器。

   Bean 其实是一种 Java 的对象，在 Spring 中，Bean 除了普通定义的 Java 代码以外，
   还需要一些其他的元信息，例如：定义的 XML，或者 ~@Component~ 注解。所以 Spring
   中的对象和普通 Java 对象是不一样的，为了体现 Spring 的高贵性，就将 Spring 中
   的对象称为 Bean。Bean 的 XML 配置非常恶心且繁琐，不需要记的，用的时候去[[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics][官网]]上
   查就行。

   关于 Bean 的使用需要掌握以下几个要点
   - Bean Class, Name, Alias, Constructor arguments, Properties
   - Bean Scope: singlenton, prototype, request, session, application,
     websocket
   - Reference: ~ref~ / ~refid~
   - Collections ~<list/>~, ~<set/>~, ~<map/>~
   - Autowiring: ~no~, ~byName~, ~byType~, constructor
   - ~*Aware~ Interfaces: ApplicationContextAware, ResourceLoaderAware,
     BeanFactoryAware
   - Bean Definition Inheritance: ~<parent/>~
   - Lazy initialization mode
   - Initialization method
   - Initialization/Destruction method
   - Annotation: ~@Required~, ~@Autowired~

** 资源 Resource
   Spring 秉承着一切皆资源，将可以被访问的东西都囊括在 Resource 接口中。并提供了
   以下一些实现，用户可以直接通过 URL 来获取: ~classpath:config.xml~,
   ~file:///data/config.xml~, ~http://myservice/logo.png~, ~/path/to/file.txt~
   - UrlResource
   - ClassPathResource
   - FileSystemResource
   - ServletContextResource
   - InputStreamResource
   - ByteArrayResource

** 面向切面编程 AOP
   AOP 框架创建的对象，代理就是目标对象的加强。Spring 中的 AOP 代理可以使 JDK 动态代理，
   也可以是 CGLIB 代理，前者基于接口，后者基于子类。
   - Aspect 通常是一个类，里面可以定义切入点和通知
   - Join Point 程序执行过程中明确的点，一般是方法的调用
   - Advice 在特定的切入点上执行的增强处理
   - Pointcut 带有通知的连接点，在程序中主要体现为书写切入点表达式

   #+BEGIN_SRC java
     package com.xyz.someapp;

     import org.aspectj.lang.annotation.Aspect;
     import org.aspectj.lang.annotation.Pointcut;

     @Aspect
     public class SystemArchitecture {

         /
          ,* A join point is in the web layer if the method is defined
          ,* in a type in the com.xyz.someapp.web package or any sub-package
          ,* under that.
          /
         @Pointcut("within(com.xyz.someapp.web..)")
         public void inWebLayer() {}

         /
          ,* A join point is in the service layer if the method is defined
          ,* in a type in the com.xyz.someapp.service package or any sub-package
          ,* under that.
          /
         @Pointcut("within(com.xyz.someapp.service..)")
         public void inServiceLayer() {}

         /
          ,* A join point is in the data access layer if the method is defined
          ,* in a type in the com.xyz.someapp.dao package or any sub-package
          ,* under that.
          /
         @Pointcut("within(com.xyz.someapp.dao..)")
         public void inDataAccessLayer() {}

         /
          ,* A business service is the execution of any method defined on a service
          ,* interface. This definition assumes that interfaces are placed in the
          ,* "service" package, and that implementation types are in sub-packages.
          ,*
          ,* If you group service interfaces by functional area (for example,
          ,* in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
          ,* the pointcut expression "execution(* com.xyz.someapp..service..(..))"
          ,* could be used instead.
          ,*
          ,* Alternatively, you can write the expression using the 'bean'
          ,* PCD, like so "bean(Service)". (This assumes that you have
          ,* named your Spring service beans in a consistent fashion.)
          ,*/
         @Pointcut("execution( com.xyz.someapp..service..(..))")
         public void businessService() {}

         /*
          ,* A data access operation is the execution of any method defined on a
          ,* dao interface. This definition assumes that interfaces are placed in the
          ,* "dao" package, and that implementation types are in sub-packages.
          ,*/
         @Pointcut("execution( com.xyz.someapp.dao..(..))")
         public void dataAccessOperation() {}

     }
   #+END_SRC

** 测试
   Spring 框架的一个特色就是提供测试 [[https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html][Spring Testing]] 的功能，对于日常工作测试，主
   要了解 ~@Transactional~, ~@Rollback~ 以及 ~@Commit~ 这样三个注解功能。Spring
   测试时默认开启事务，如果测试中修改或删除了数据，在测试后要求修改回来。

** 事务
*** ~@Transactional~
    事务不仅仅是 Spring 特有的特性，在数据库并发中普遍存在，具体事务的特性我在
    [[file:../database/oracle.org][Oracle]] 中事务一节中有详细地讨论，这里着重记录 Spring 中 ~@Transactional~ 标注的使
    用

    在 Spring 中，事务使用操作的相关讨论出现在 [[https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html][Data Access]] 一节中，
    ~@Transactional~ 开启一个事务，例如下面的 FooService 开启了事务管理，虽然
    Spring 也支持 XML 方式配置事务，但是比较麻烦，尽量避免使用
    #+BEGIN_SRC java
      @Transactional
      public class DefaultFooService implements FooService {

        Foo getFoo(String fooName) { /* ... */ }
        Foo getFoo(String fooName, String barName) { /* ... */ }
        void insertFoo(Foo foo) { /* ... */ }
        void updateFoo(Foo foo) { /* ... */ }

      }
    #+END_SRC

    事务显然有很多属性可以配置，例如：是否只读，是否传播，隔离级别，超时的时长，
    以及为何中异常回滚，因为属性多，所以需移步官网文档 [[https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-attransactional-settings][Transactional Settings]]
    #+BEGIN_SRC java
      @Transactional(readOnly = true)
      public class DefaultFooService implements FooService {
        public Foo getFoo(String fooName) { /* ... */ }

        // these settings have precedence for this method
        @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
        public void updateFoo(Foo foo) { /* ... */ }
      }
    #+END_SRC

    在 Spring 中，事务包含一个传播方式，大体上有如下几种：
    - ~PROPAGATION_REQUIRED~ 所有方法串在一个事务中执行
    - ~PROPAGATION_REQUIRES_NEW~ 每次进入子方法时，新开一个事务
    - ~PROPAGATION_NESTED~ 所有方法串在一个事务中，但是进入子方法时记录保存点
      (Save Point)

    Spring 也支持多事务管理员角色的注解，使用方法参考下面例子
    #+BEGIN_SRC java
      public class TransactionalService {

        @Transactional("order")
        public void setSomething(String name) { /* ... */ }

        @Transactional("account")
        public void doSomething() { /* ... */ }
      }
    #+END_SRC

    也可以自己定制的方式定义属于业务逻辑的事务管理注解，参考如下的例子
    #+BEGIN_SRC java
      @Target({ElementType.METHOD, ElementType.TYPE})
      @Retention(RetentionPolicy.RUNTIME)
      @Transactional("order")
      public @interface OrderTx {
      }

      @Target({ElementType.METHOD, ElementType.TYPE})
      @Retention(RetentionPolicy.RUNTIME)
      @Transactional("account")
      public @interface AccountTx {
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class TransactionalService {
        @OrderTx
        public void setSomething(String name) { /* ... */ }
        @AccountTx
        public void doSomething() { /* ... */ }
      }
    #+END_SRC

*** ~TransactionTemplate~
    Spring 实现了 TransactionTemplate 模版类，也可以很方便的操纵事务相关的业务
    #+BEGIN_SRC java
      public class SimpleService implements Service {

        // single TransactionTemplate shared amongst all methods in this instance
        private final TransactionTemplate transactionTemplate;

        // use constructor-injection to supply the PlatformTransactionManager
        public SimpleService(PlatformTransactionManager transactionManager) {
          this.transactionTemplate = new TransactionTemplate(transactionManager);
        }

        public Object someServiceMethod() {
          return transactionTemplate.execute(new TransactionCallback() {
              // the code in this method executes in a transactional context
              public Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                return resultOfUpdateOperation2();
              }
            });
        }
      }
    #+END_SRC

** 创建 Spring 项目
   创建一个 Maven 项目项目工程
   #+BEGIN_SRC sh
     mvn archetype:generate \
         -DarchetypeArtifactId=maven-archetype-quickstart \
         -DinteractiveMode=false -DgroupId=io.github.jeanhwea -DartifactId=mapp
   #+END_SRC

   添加 ~spring-context~ 的项目依赖到 ~pom.xml~ 文件中
   #+BEGIN_SRC xml
     <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-context</artifactId>
       <version>5.2.4.RELEASE</version>
     </dependency>
   #+END_SRC

   使用命令行的方式运行主类
   #+BEGIN_SRC java
     mvn exec:java -Dexec.mainClass="io.github.jeanhwea.App" -Dexec.classpathScope=runtime
   #+END_SRC
* Spring Web MVC
  [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc][Spring Web MVC]] 提供了开发 MVC 页面的框架，它期初是建立在 Servlet API 基础上。

** Spring Web MVC 项目包结构

   [[file:../static/image/2019/07/spring-mvc-module.png]]

* Spring Boot
  用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再
  需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发
  [[https://spring.io/projects/spring-boot/#overview][Spring Boot]] 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应
  领域成为领导者。Spring Boot 的文档见 [[https://docs.spring.io/spring-boot/docs/current/reference/html/][HTML]] ，源代码托管于 [[https://github.com/spring-projects/spring-boot][GitHub]]

** 创建项目
   可以直接通过 Spring Start 网站进行创建，创建一个 Spring Boot 模板工程
   #+BEGIN_SRC sh
     curl -s https://start.spring.io/starter.tgz \
            -d dependencies=mybatis,web \
            -d groupId=io.github.jeanhwea \
            -d artifactId=myapp -d name=myapp -d baseDir=myapp \
            | tar -xzvf -
   #+END_SRC

** 命令行工具
   Spring Boot 命令行工具参考 [[file:../tool/springboot-cli.org][Spring Boot CLI Tool]]

** 编译系统
*** 继承父 Starter
    Spring Boot 项目需要继承的父级 Starter，配置如下：
    #+BEGIN_SRC xml
    <!-- Inherit defaults from Spring Boot -->
    <parent>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-parent</artifactId>
     <version>2.1.0.RELEASE</version>
    </parent>
    #+END_SRC

*** Starters
    Starters 是 Spring Boot 对其依赖的再打包，官方的 Starter 都是以
    =spring-boot-starter= 开头，并且存放在 [[https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters][spring-boot-starters]] 中

    [[file:../static/image/2019/07/spring-boot-starters.png]]

    - ~spring-boot-starter~ : Core starter, including auto-configuration support,
      logging and YAML
    - ~spring-boot-starter-activemq~ : Starter for JMS messaging using Apache
      ActiveMQ
    - ~spring-boot-starter-amqp~ : Starter for using Spring AMQP and Rabbit MQ
    - ~spring-boot-starter-aop~ : Starter for aspect-oriented programming with
      Spring AOP and AspectJ
    - ~spring-boot-starter-cloud-connectors~ : Starter for using Spring Cloud
      Connectors which simplifies connecting to services in cloud platforms like
      Cloud Foundry and Heroku
    - ~spring-boot-starter-data-elasticsearch~ : Starter for using Elasticsearch
      search and analytics engine and Spring Data Elasticsearch
    - ~spring-boot-starter-data-jpa~ : Starter for using Spring Data JPA with
      Hibernate
    - ~spring-boot-starter-data-ldap~ : Starter for using Spring Data LDAP
    - ~spring-boot-starter-data-mongodb~ : Starter for using MongoDB
      document-oriented database and Spring Data MongoDB
    - ~spring-boot-starter-data-mongodb-reactive~ : Starter for using MongoDB
      document-oriented database and Spring Data MongoDB Reactive
    - ~spring-boot-starter-data-neo4j~ : Starter for using Neo4j graph database
      and Spring Data Neo4j
    - ~spring-boot-starter-data-redis~ : Starter for using Redis key-value data
      store with Spring Data Redis and the Lettuce client
    - ~spring-boot-starter-data-redis-reactive~ : Starter for using Redis
      key-value data store with Spring Data Redis reactive and the Lettuce client
    - ~spring-boot-starter-integration~ : Starter for using Spring Integration
    - ~spring-boot-starter-json~ : Starter for reading and writing json
    - ~spring-boot-starter-oauth2-client~ : Starter for using Spring Security's
      OAuth2/OpenID Connect client features
    - ~spring-boot-starter-oauth2-resource-server~ : Starter for using Spring
      Security's OAuth2 resource server features
    - ~spring-boot-starter-quartz~ : Starter for using the Quartz scheduler
    - ~spring-boot-starter-security~ : Starter for using Spring Security
    - ~spring-boot-starter-test~ : Starter for testing Spring Boot applications
      with libraries including JUnit, Hamcrest and Mockito
    - ~spring-boot-starter-web~ : Starter for building web, including RESTful,
      applications using Spring MVC. Uses Tomcat as the default embedded
      container
    - ~spring-boot-starter-web-services~ : Starter for using Spring Web Services
    - ~spring-boot-starter-webflux~ : Starter for building WebFlux applications
      using Spring Framework's Reactive Web support
    - ~spring-boot-starter-websocket~ : Starter for building WebSocket
      applications using Spring Framework's WebSocket support

** Spring Beans 和依赖注入
   Spring Framework 的相关技术在 Spring Boot 工程中都是支持的，常见的标注如下：
   - ~@ComponentScan~ : 查找 Beans
   - ~@Autowired~ : 注入的构造器
   - ~@Component~ : 组件
   - ~@Repository~ : 仓库
   - ~@Service~ : 服务
   - ~@Controller~ : 控制器

   下面是依赖注入的示例
   #+BEGIN_SRC java
   package com.example.service;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;

   @Service
   public class DatabaseAccountService implements AccountService {
     private final RiskAssessor riskAssessor;

     @Autowired
     public DatabaseAccountService(RiskAssessor riskAssessor) {
       this.riskAssessor = riskAssessor;
     }

     // ...
   }
   #+END_SRC

   #+BEGIN_SRC java
   @Service
   public class DatabaseAccountService implements AccountService {
     private final RiskAssessor riskAssessor;

     public DatabaseAccountService(RiskAssessor riskAssessor) {
       this.riskAssessor = riskAssessor;
     }

     // ...
   }
   #+END_SRC

** ~@SpringBootApplication~ 标注
   Spring Framework 提供了下面的基本标注
   - ~@EnableAutoConfiguration~ : 开启自动配置
   - ~@ComponentScan~ : 开启自动扫描组件
   - ~@Configuration~ : 允许在上下文中注册其它的 Bean 或导入其它的配置类

   ~@SpringBootApplication~ 相当于同时开启了上面三项配置
   #+BEGIN_SRC java
   package com.example.myapplication;
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;


   @SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
   public class Application {

     public static void main(String[] args) {
       SpringApplication.run(Application.class, args);
     }

   }
   #+END_SRC

** 外部配置
   Spring Boot 允许在 Web 应用中读取外部配置，方便程序在不同的环境下产生不同行为。
   常见的有两种配置方式，两种配置方式对比如下：

   | Feature           | ~@ConfigurationProperties~ | ~@Value~ |
   |-------------------+----------------------------+----------|
   | Relaxed binding   | Yes                        | No       |
   | Meta-data support | Yes                        | No       |
   | SpEL evaluation   | No                         | Yes      |

*** ~@Value~ 方式配置
    直接使用注释的方式即可将配置的值读入 Java Bean 中，示例如下：
    #+BEGIN_SRC java
    @Component
    public class MyBean {

      @Value("${name}")
      private String name;

      // ...
    }
    #+END_SRC

*** ~@ConfigurationProperties~ 方式配置
    该种配置方法比 ~@Value~ 更加安全

    先定义配置项的 Java Bean
    #+BEGIN_SRC java
    package com.example;

    import java.net.InetAddress;
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.List;

    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("acme")
    public class AcmeProperties {

      private boolean enabled;
      private InetAddress remoteAddress;
      private final Security security = new Security();

      public boolean isEnabled() { /* ... */ }
      public void setEnabled(boolean enabled) { /* ... */ }

      public InetAddress getRemoteAddress() { /* ... */ }
      public void setRemoteAddress(InetAddress remoteAddress) { /* ... */ }

      public Security getSecurity() { /* ... */ }

      public static class Security {
        private String username;
        private String password;
        private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

        public String getUsername() { /* ... */ }
        public void setUsername(String username) { /* ... */ }

        public String getPassword() { /* ... */ }
        public void setPassword(String password) { /* ... */ }

        public List<String> getRoles() { /* ... */ }
        public void setRoles(List<String> roles) { /* ... */ }
      }
    }
    #+END_SRC

    上述的配置类对应于配置文件中的这些配置项
    - ~acme.enabled~ 定义一个值，默认为空
    - ~acme.remote-address~ 能通过字符串强制转换的类型
    - ~acme.security.username~ 自带 Security 对象，用户名
    - ~acme.security.password~
    - ~acme.security.roles~ 字符串集合

    添加配置项，通过 ~@EnableConfigurationProperties~ 标注来扫描配置的 Java Bean
    #+BEGIN_SRC java
    @Configuration
    @EnableConfigurationProperties(AcmeProperties.class)
    public class MyConfiguration {
      // ...
    }
    #+END_SRC

    并且需要添加 ~@Configuration~ 到 Java Bean 中
    #+BEGIN_SRC java
    @Component
    @ConfigurationProperties(prefix="acme")
    public class AcmeProperties {
      // ... see the preceding example
    }
    #+END_SRC

    最后就可以将定义的 Java Bean 配置项注入到其它组件中
    #+BEGIN_SRC java
    @Service
    public class MyService {

      private final AcmeProperties properties;

      @Autowired
      public MyService(AcmeProperties properties) {
        this.properties = properties;
      }

      //...

      @PostConstruct
      public void openConnection() {
        Server server = new Server(this.properties.getRemoteAddress());
        // ...
      }

    }
    #+END_SRC

** 允许跨域
   Spring Boot 可以通过添加配置类的方法来启用跨域设置，具体参考下面的代码
   #+BEGIN_SRC java
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.servlet.config.annotation.CorsRegistry;
   import org.springframework.web.servlet.config.annotation.EnableWebMvc;
   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

   @Configuration
   @EnableWebMvc
   public class CorsConfiguration implements WebMvcConfigurer {

     private static final String[] CORS_METHODS =
         new String[] {"GET", "OPTIONS", "POST", "PUT", "DELETE"};

     private static final String[] CORS_HEADERS =
         new String[] {
           "Access-Control-Request-Headers",
           "Access-Control-Request-Method",
           "Accept",
           "Authorization",
           "Cache-Control",
           "Content-Type",
           "DNT",
           "If-Modified-Since",
           "Keep-Alive",
           "Origin",
           "Referer",
           "User-Agent",
           "X-Mx-ReqToken",
           "X-Requested-With"
         };

     @Override
     public void addCorsMappings(CorsRegistry registry) {
       registry
           .addMapping("/**")
           .allowedOrigins("*")
           .allowedMethods(CORS_METHODS)
           .allowedHeaders(CORS_HEADERS)
           .exposedHeaders(CORS_HEADERS)
           .allowCredentials(true)
           .maxAge(3600);
     }
   }

   #+END_SRC

** 日志
   Spring Boot 提供了一个统一的日志配置，可以兼容 Java Util Logging、Log4J2 和
   Logback 等日志系统作为后端。

*** 日志样式
    默认的输出样式如下：
    #+BEGIN_SRC text
    2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
    2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
    2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
    2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
    2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
    #+END_SRC
    包括以下几个部分：
    1. Date and Time: Millisecond precision and easily sortable
    2. Log Level: ERROR, WARN, INFO, DEBUG, or TRACE
    3. Process ID
    4. A --- separator to distinguish the start of actual log messages
    5. Thread name: Enclosed in square brackets (may be truncated for console
       output)
    6. Logger name: This is usually the source class name (often abbreviated)
    7. The log message

*** 控制台输出
    控制台输出默认记录 ERROR, WARN 和 INFO 基本的日志，可以使用 ~--debug~ 开启调
    试级别的输出。
    #+BEGIN_SRC sh
    java -jar myapp.jar --debug
    #+END_SRC

    也可以在配置文件 ~application.yml~ 中设置 ~debug=true~

    如果控制台支持彩色输出，那么还可以配置彩色输出日志
    - 开启配置文件中的 ~spring.output.ansi.enabled~ 选项
    - 使用 ~%clr(%5p)~ 可以根据日志基本来变换颜色。各级别对应的颜色： 红色
      (FATAL, ERROR)，黄色（INFO），绿色（INFO, DEBUG）
    - 设置日期的颜色 ~%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}~ ，默认支持以下几
      种色彩： blue cyan faint green magenta red yellow

*** 文件输出
    文件输出通过 ~logging.file~ 和 ~logging.path~ 来控制

    | logging.file  | logging.path       | Example  | Description                                  |
    |---------------+--------------------+----------+----------------------------------------------|
    | (none)        | (none)             |          | 仅开启控制台输出                             |
    | Specific file | (none)             | my.log   | 输出到文件，文件路径是当前文件夹的相对路径   |
    | (none)        | Specific directory | /var/log | 输出到文件，文件路径可以是相对路径或绝对路径 |

    - ~logging.file.max-size~ 设置文件的最大存储大小
    - ~logging.file.max-history~ 设置最大的历史文件数量

*** 日志级别
    日志级别可以通过 ~logging.level.<logger-name>=<level>~ 来设置，
    ~logging.level.root~ 是设置默认级别
    #+BEGIN_SRC conf
    logging.level.root=WARN
    logging.level.org.springframework.web=DEBUG
    logging.level.org.hibernate=ERROR
    #+END_SRC

*** 日志分组
    日志基本可以通过分组来设置，例如
    #+BEGIN_SRC conf
    logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat
    #+END_SRC

    Spring Boot 的默认分组有下面几个：
    - web : ~org.springframework.core.codec, org.springframework.http, org.springframework.web~
    - sql : ~org.springframework.jdbc.core, org.hibernate.SQL~

** 配置数据库
*** MySQL
    ~application.yml~ 配置文件中添加用户名、密码等相关信息
    #+BEGIN_SRC yaml
    spring:
      jpa:
        database-platform: org.hibernate.dialect.MySQL5Dialect
      datasource:
        platform: mysql
        username: username
        password: password
        url: jdbc:mysql://localhost:3306/database?useUnicode=true&characterEncoding=utf-8&useSSL=false
        driver-class-name: com.mysql.jdbc.Driver
    #+END_SRC

    ~pom.xml~ 文件中添加 MySQL 依赖
    #+BEGIN_SRC xml
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.38</version>
    </dependency>
    #+END_SRC

*** PostgreSQL
    ~application.yml~ 配置文件中添加用户名、密码等相关信息
    #+BEGIN_SRC yaml
    spring:
      jpa:
        database-platform: org.hibernate.dialect.PostgreSQL9Dialect
      datasource:
        platform: postgres
        username: username
        password: password
        url: jdbc:postgresql://localhost:5432/database
        driver-class-name: org.postgresql.Driver
    #+END_SRC

    ~pom.xml~ 文件中添加 PostgreSQL 依赖
    #+BEGIN_SRC xml
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>42.2.5</version>
    </dependency>
    #+END_SRC

*** Oracle
    ~application.yml~ 配置文件中添加用户名、密码等相关信息
    #+BEGIN_SRC yaml
    spring:
      jpa:
        database-platform: org.hibernate.dialect.Oracle10gDialect
      datasource:
        username: username
        password: password
        url: jdbc:oracle:thin:@//localhost:1521/database
        driver-class-name: oracle.jdbc.OracleDriver
    #+END_SRC

    ~pom.xml~ 文件中添加 PostgreSQL 依赖
    #+BEGIN_SRC xml
    <dependency>
      <groupId>com.oracle</groupId>
      <artifactId>ojdbc6</artifactId>
      <version>11.2.0.4.0</version>
      <scope>provided</scope>
    </dependency>
    #+END_SRC

    Oracle 的驱动是收费的，需要手工安装，默认在 ~$ORACLE_HOME/jdbc/lib/~ 文件夹
    中， 安装适配你项目的 jar 文件即可
    #+BEGIN_SRC sh
    mvn install:install-file -Dpackaging=jar \
      -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.4.0 \
      -Dfile=<path-to-jar>
    #+END_SRC

*** Tomcat 连接池配置
    如果你在项目中使用 [[https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes][Tomcat 连接池]] 作为数据库连接，可能还需要设置的相关参数
    #+BEGIN_SRC conf
    # Number of ms to wait before throwing an exception if no connection is available.
    spring.datasource.tomcat.max-wait=10000

    # Maximum number of active connections that can be allocated from this pool at the same time.
    spring.datasource.tomcat.max-active=50

    # Validate the connection before borrowing it from the pool.
    spring.datasource.tomcat.test-on-borrow=true
    #+END_SRC

** 开发工具
   Spring Boot 的提供了开发工具套件，可以实现自动加载，仅仅需要在 ~pom.xml~ 文件
   中加入下面依赖即可自动添加
   #+BEGIN_SRC xml
   <dependencies>
    <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-devtools</artifactId>
     <optional>true</optional>
    </dependency>
   </dependencies>
   #+END_SRC

* Spring Data
** Spring Data JPA
   JPA(Java Persistence API)意即 Java 持久化 API，是 Sun 官方在 JDK5.0 后提出的
   Java 持久化规范。JPA 的出现主要是为了简化持久层开发以及整合 ORM 技术，结束
   Hibernate、TopLink、JDO 等 ORM 框架各自为营的局面。JPA 是在吸收现有 ORM 框架
   的基础上发展而来，易于使用，伸缩性强。总的来说，JPA 包括以下 3 方面的技术：

   - ORM 映射元数据： 支持 XML 和注解两种元数据的形式，元数据描述对象和表之间的
     映射关系
   - API： 操作实体对象来执行 CRUD 操作
   - 查询语言： 通过面向对象而非面向数据库的查询语言（JPQL）查询数据，避免程序的
     SQL 语句紧密耦合

   [[https://spring.io/projects/spring-data-jpa#overview][Spring Data JPA ]]是 Spring Data 家族的一部分，可以轻松实现基于 JPA 的存储库。
   此模块处理对基于 JPA 的数据访问层的增强支持。 它使构建使用数据访问技术的
   Spring 驱动应用程序变得更加容易。其代码托管于 [[https://github.com/spring-projects/spring-data-jpa][GitHub]] ， 文档见 [[https://docs.spring.io/spring-data/jpa/docs/current/reference/html/][reference]] 。

*** 格式化 JSON 的时间字符串
    使用 JsonFormat 标注可以设置 JSON 字段序列化的格式
    #+BEGIN_SRC java
    import com.fasterxml.jackson.annotation.JsonFormat;
    import com.fasterxml.jackson.annotation.JsonProperty;

    class ExampleEntity {

      @Column(name = "BIRTHDAY")
      @JsonFormat(pattern = "yyyy-MM-dd")
      private Timestamp birthday; // 出生日期

      @JsonProperty("birthday")
      public Timestamp birthday() {
        return this.birthday;
      }

      public void birthday(Timestamp birthday) {
        this.birthday = birthday;
      }
    }
    #+END_SRC

* Spring Cloud
  [[https://spring.io/projects/spring-cloud][Spring Cloud]] 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化
  了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路
  器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。Spring
  Cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的
  服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，
  最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

** Spring Cloud Config
   [[https://spring.io/projects/spring-cloud-config][Spring Cloud Config]] 项目是一个解决分布式系统的配置管理方案。它包含了 Client
   和 Server 两个部分，Server 提供配置文件的存储、以接口的形式将配置文件的内容提
   供出去，Client 通过接口获取数据、并依据此数据初始化自己的应用。

   [[file:../static/image/2019/07/spring-cloud-config.png]]

*** 配置文件命名格式
    - 配置文件命名方式为: *{appname}-{profile}.yml*
      - appname 是微服务的名称
      - profile 是不同的环境，建议用: ~dev~ 表示开发环境， ~prod~ 表示线
        上运行环境
    - 对应请求的 URI 有以下几种格式
      - ~/{application}/{profile}[/{label}]~
      - ~/{application}-{profile}.yml~
      - ~/{label}/{application}-{profile}.yml~
      - ~/{application}-{profile}.properties~
      - ~/{label}/{application}-{profile}.properties~

*** Config Server
**** 项目依赖
     在 =pom.xml= 文件中添加如下的依赖项
     #+BEGIN_SRC xml
     <project>
       <dependencies>
         <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-config-server</artifactId>
         </dependency>
       </dependencies>

       <dependencyManagement>
         <dependencies>
           <dependency>
             <groupId>org.springframework.cloud</groupId>
             <artifactId>spring-cloud-dependencies</artifactId>
             <version>Greenwich.SR2</version>
             <type>pom</type>
             <scope>import</scope>
           </dependency>
         </dependencies>
       </dependencyManagement>
     </project>
     #+END_SRC

**** 引导类
     中心服务器的引导累着需要添加 ~@EnableConfigServer~ 来启用配置服务器
     #+BEGIN_SRC java
     import org.springframework.boot.SpringApplication;
     import org.springframework.boot.autoconfigure.SpringBootApplication;
     import org.springframework.cloud.config.server.EnableConfigServer;

     @SpringBootApplication
     @EnableConfigServer
     public class Application {

       public static void main(String[] args) {
         SpringApplication.run(Application.class, args);
       }

     }
     #+END_SRC

**** Git 远端配置项
     在中心配置服务器中的 =application.yml= 中添加相应的配置
     #+BEGIN_SRC yaml
     spring:
       profiles:
         active: default
       cloud:
         config:
           server:
             git:
               uri: http://github.com/avic/configfiles.git
               searchPaths:
                 - path1
                 - path2
               username: user
               password: pass
     #+END_SRC

*** Config Client
**** 配置相关文件
     首先修改 *pom.xml*, *application.yml* 和 *bootstrap.yml* 这三项配置文件
     #+BEGIN_SRC xml
     <!-- pom.xml -->
     <project>
       <!-- 1. 添加下面四个依赖项 -->
       <dependencies>
         <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-config</artifactId>
         </dependency>
         <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-actuator</artifactId>
         </dependency>
         <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
         </dependency>
         <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-test</artifactId>
           <scope>test</scope>
         </dependency>
       </dependencies>

       <!-- 2. 设置依赖管理 -->
       <dependencyManagement>
         <dependencies>
           <dependency>
             <groupId>org.springframework.cloud</groupId>
             <artifactId>spring-cloud-dependencies</artifactId>
             <!-- 这个 version 需要和你使用的 spring boot 版本适配，否则应用起不来 -->
             <version>Greenwich.SR2</version>
             <!-- 我的项目中 spring boot 版本是 2.1.0.RELEASE, 所以 cloud 的版本使用 Greenwich -->
             <type>pom</type>
             <scope>import</scope>
           </dependency>
         </dependencies>
       </dependencyManagement>

     </project>
     #+END_SRC
     #+BEGIN_SRC yaml
     # src/main/resources/application.yml
     management:
       endpoints:
         web:
           exposure:
             include: '*'
     #+END_SRC
     #+BEGIN_SRC yaml
     # src/main/resources/bootstrap.yml
     spring:
       application:
         name: appname # 这里写你项目的名称
       profiles:
         active: dev   # 这里配置你需要的 profile
       cloud:
         config:
           uri: http://192.168.0.231/peizhi
     #+END_SRC

**** 引导类
     在系统启动的引导类中添加 ~@RefreshScope~ 注解
     #+BEGIN_SRC java
     import org.springframework.boot.autoconfigure.SpringBootApplication;
     import org.springframework.cloud.context.config.annotation.RefreshScope;

     @SpringBootApplication
     @RefreshScope
     public class Application {
       public static void main(String[] args) {
         SpringApplication.run(Application.class, args);
       }
     }
     #+END_SRC

** Spring Cloud Netflix
   [[https://spring.io/projects/spring-cloud-netflix][Spring Cloud Netflix]] 是通过自动配置和绑定提供为 spring boot 应用提供 OSS 集成
   功能，它的子项目包括：
   - Eureka: 服务发现 (Service Discovery)
   - Hystrix : 断路器 (Circuit Breaker)
   - Zuul : 智能路由 (Intelligent Routing)
   - Ribbon : 客户端的负载均衡 (Client Side Load Balancing)

   官方是参考手册见 [[https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.2.0.M1/][2.2.0.M1]]

*** Eureka
    Eureka 是 [[https://spring.io/projects/spring-cloud-netflix][Spring Cloud Netflix]] 开发的服务发现框架，本身是一个基于 REST 的服
    务。Spring Cloud 将它集成在其子项目 spring-cloud-netflix 中，以实现 Spring
    Cloud 的服务发现功能。 Eureka 项目本身包括客户端和服务器两个子项目，具体配置
    如下：

**** Eureka Client
***** 配置相关文件
      =pom.xml= 添加 ~spring-cloud-starter-netflix-eureka-client~ 的依赖项
      #+BEGIN_SRC xml
      <!-- pom.xml -->
      <project>
        <dependencies>
          <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
          </dependency>
        </dependencies>
      </project>
      #+END_SRC

      =application.yml= 添加配置项
      #+BEGIN_SRC yaml
      eureka:
        instance:
          instanceId: app-instance-id
          hostname: my.app.host
          nonSecurePort: 8080 # http 请求的端口号
        client:
          fetchRegistry: true
          registerWithEureka: true
          serviceUrl:
            defaultZone: http://localhost:8761/eureka/
      #+END_SRC

      如果开启 ~preferIpAddress~ 就会忽略 ~hostname~ ，因为有的时候微服务被部署
      到 docker 容器中，主机名可能是随机分配的，不好管理可以考虑建立个 docker 的
      内网，使用 IP 直接注册。
      #+BEGIN_SRC yaml
      eureka:
        instance:
          preferIpAddress: true       # 使用 IP 地址注册，而不是使用主机名注册
      #+END_SRC


***** 配置引导类
      ~spring-cloud-starter-netflix-eureka-client~ 依赖项后会将当前项目自动注册
      到 Eureka Server 上
      #+BEGIN_SRC java
      @SpringBootApplication
      @RestController
      public class Application {

        @RequestMapping("/")
        public String home() {
          return "Hello world";
        }

        public static void main(String[] args) {
          new SpringApplicationBuilder(Application.class).web(true).run(args);
        }
      }
      #+END_SRC

      也可以使用 ~@EnableDiscoveryClient~ 的注解来显示激活

**** Eureka Server
***** 配置相关文件
      ~pom.xml~ 添加 ~spring-cloud-starter-netflix-eureka-server~ 的依赖项
      #+BEGIN_SRC xml
      <!-- pom.xml -->
      <project>
        <dependencies>
          <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
          </dependency>
        </dependencies>
      </project>
      #+END_SRC

      ~application.yml~ 添加配置项，下面是 Standalone 模式的配置方法
      #+BEGIN_SRC yaml
      eureka:
        instance:
          hostname: localhost
        client:
          fetchRegistry: false                # 不要在本地缓存注册表信息
          registerWithEureka: false
          serverUrl:
            defaultZone: http://localhost:8761/eureka/
        server:
          waitTimeInMsWhenSyncEmpty: 5      # 在服务器接收请求之前的等待时间
      #+END_SRC

      Peer Awareness 模式配置方法如下：
      #+BEGIN_SRC yaml
      ---
      spring:
        profiles: peer1
      eureka:
        instance:
          hostname: peer1
        client:
          serviceUrl:
            defaultZone: https://peer2/eureka/

      ---
      spring:
        profiles: peer2
      eureka:
        instance:
          hostname: peer2
        client:
          serviceUrl:
            defaultZone: https://peer1/eureka/
      #+END_SRC

***** 配置引导类
      使用 ~@EnableEurekaServer~ 来开启 Eureka Server
      #+BEGIN_SRC java
      @SpringBootApplication
      @EnableEurekaServer
      public class Application {

        public static void main(String[] args) {
          new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

      }
      #+END_SRC

*** Hystrix
    Hystrix 是 SOA 微服务架构中提供服务隔离、熔断、降级机制的工具/框架。Hystrix
    是断路器的一种实现，用于高微服务架构的可用性，是防止服务出现雪崩的利器。
    Hystrix 实现了 Martin Fowler 的 [[https://martinfowler.com/bliki/CircuitBreaker.html][Circuit Breaker]] 模式，熔断器的机制的思想很简
    单直白，即在 Client 和 Supplier 之间实现一个 Circuit Breaker 层，当 Supplier
    出现错误或超时，就对 Client 的请求进行截断

**** Hystrix Client
***** 配置相关文件
      ~pom.xml~ 添加 ~spring-cloud-starter-netflix-hystrix~ 的依赖项
      #+BEGIN_SRC xml
      <!-- pom.xml -->
      <project>
        <dependencies>
          <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
          </dependency>
          <dependency>
            <groupId>com.netflix.hystrix</groupId>
            <artifactId>hystrix-javanica</artifactId>
            <!-- <version>x.y.z</version> -->
          </dependency>
        </dependencies>
      </project>
      #+END_SRC

***** 配置引导类
      #+BEGIN_SRC java
      @SpringBootApplication
      @EnableCircuitBreaker
      public class Application {

        public static void main(String[] args) {
          new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

      }

      @Component
      public class StoreIntegration {

        @HystrixCommand(fallbackMethod = "defaultStores")
        public Object getStores(Map<String, Object> parameters) {
          //do stuff that might fail
        }

        public Object defaultStores(Map<String, Object> parameters) {
          return /* something useful */;
        }
      }
      #+END_SRC
      ~@HystrixCommand~ 由 [[https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica][javanica]] 库提供，该库可以自动代理一些熔断处理。
      ~@EnableCircuitBreaker~ 开启熔断器

***** 弹性模式
      Hystrix 的常见弹性模式有以下几种：
      - 断路器模式：确保客户端不会重复调用失败的服务
      - 后备模式：调用失败后，询问是否有可以执行的替代方案
      - 舱壁模式：隔断服务客户端上的不同服务调用，以确保表现不佳的服务不会耗尽客
        户端的所有资源

**** Hystrix Dashboard
     Hystrix 监控除了隔离依赖服务的调用以外，Hystrix 还提供了近实时的监控，
     Hystrix 会实时、累加地记录所有关于 HystrixCommand 的执行信息，包括每秒执行多
     少请求多少成功，多少失败等。Netflix 通过 ~hystrix-metrics-event-stream~ 项
     目实现了对以上指标的监控。

*** Zuul
    Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是
    设备和 Netflix 流应用的 Web 网站后端所有请求的前门

    [[file:../static/image/2019/07/netflix-zuul.png]]

***** 配置相关文件
      ~pom.xml~ 添加 ~spring-cloud-starter-netflix-zuul~ 的依赖项将 Zuul 引入项目
      #+BEGIN_SRC xml
      <!-- pom.xml -->
      <project>
        <dependencies>
          <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
          </dependency>
        </dependencies>
      </project>
      #+END_SRC

***** 配置引导类
      #+BEGIN_SRC java
      @SpringBootApplication
      @EnableZuulProxy
      public class Application {

        public static void main(String[] args) {
          new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

      }
      #+END_SRC
      ~@EnableZuulProxy~ 来开启 Zuul 服务

***** 配置反向代理
      Zuul 的反向代理使用的是以下几种方式进行设置
      - 通过服务发现自动映射路由
      - 通过服务发现手动映射路由
      - 通过静态 URL 手动映射路由

      使用 ~@EnableZuulProxy~ 开启 Zuul 服务后，如果正确地配置了 Eureka Client
      服务的话，不需要进行其它的配置就可以自动映射路由。根据惯例，Zuul 会自动给
      反向代理的微服务添加前缀，例如： 如果微服务的名字是 ~users~ ，则 Zuul 会将
      ~/users/**~ 的请求全部映射到 ~users~ 微服务中


      手动配置反向代理需要修改 ~application.yml~ 配置文件，例如下面的配置将
      ~/myusers/**~ 请求传递到 ~users~ 微服务中
      #+BEGIN_SRC yaml
      zuul:
       routes:
         users:
           path: /myusers/**
           serviceId: users_service
      #+END_SRC

      使用静态 URL 手动映射路由
      #+BEGIN_SRC yaml
      zuul:
       routes:
         users:
           path: /myusers/**
           url: https://example.com/users_service
      #+END_SRC

***** 忽略某些微服务
      Zuul 允许配置对一些微服务的忽略项
      #+BEGIN_SRC yaml
      # 忽略所有微服务
      zuul:
        ignoredServices: '*'
        routes:
          users: /myusers/**

      # 忽略某个微服务，微服务的名字为 appname
      zuul:
        ignoredServices: 'appname'
        routes:
          users: /myusers/**

      # 添加统一的前缀 /api
      zuul:
        ignoredServices: '*'
        prefix: /api
        routes:
          users: /myusers/**

      # 忽略所有带有 /admin/ 路由的调用接口
      zuul:
        ignoredPatterns: /**/admin/**
        routes:
          users: /myusers/**
      #+END_SRC

***** 头部的设置选项
      将 ~Cookies~, ~Set-Cookie~, ~Authorization~ 设置成敏感的头部，忽略一些头部
      #+BEGIN_SRC yaml
      zuul:
        routes:
          users:
            path: /myusers/**
            # Cookies 和敏感的头部
            sensitiveHeaders: Cookie,Set-Cookie,Authorization
            # 忽略的头部
            ignoredHeaders: Header1
            # 是否忽略安全头部
            ignoreSecurityHeaders: true
            url: https://downstream
      #+END_SRC

***** 管理端点 Endpoint
      Zuul 提供了一些管理路由的 RESTful 接口
      - ~GET /routes~ 获取所有解析的路由
      - ~GET /routes/detail~ 获取详细路由信息
      - ~POST /routes~ 强制刷新路由
      - ~GET /filter~ 获取所有的过滤器

      下面是一些示例
      #+BEGIN_SRC sh
      curl http://localhost/routes
      #+END_SRC
      #+BEGIN_SRC json
      {
        "/stores/**": "http://localhost:8081"
      }
      #+END_SRC

      #+BEGIN_SRC sh
      curl http://localhost/routes/detail
      #+END_SRC
      #+BEGIN_SRC json
      {
        "/stores/**": {
          "id": "stores",
          "fullPath": "/stores/**",
          "location": "http://localhost:8081",
          "path": "/**",
          "prefix": "/stores",
          "retryable": false,
          "customSensitiveHeaders": false,
          "prefixStripped": true
        }
      }
      #+END_SRC

***** 基本使用场景
      如下所示将相关路由反向代理到对应的 URL

      | 原始请求  | 代理后的请求                  |
      |-----------+-------------------------------|
      | /fisrt/1  | https://first.exmple.com/1    |
      | /second/2 | /second/2                     |
      | /third/3  | /3rd/3                        |
      | /no       | https://legacy.example.com/no |

      #+BEGIN_SRC yaml
      zuul:
       routes:
         first:
           path: /first/**
           url: https://first.example.com
         second:
           path: /second/**
           url: forward:/second
         third:
           path: /third/**
           url: forward:/3rd
         legacy:
           path: /**
           url: https://legacy.example.com
      #+END_SRC

      Zuul 的详细配置见 [[https://github.com/Netflix/zuul/wiki/How-it-Works][Zuul wiki]]

***** 过滤器
      前置过滤器（Pre Filter）的在请求之前先进行处理，设置 ~RequestContext~ 的相
      关参数提供后面的处理
      #+BEGIN_SRC java
      public class QueryParamPreFilter extends ZuulFilter {
        @Override
        public int filterOrder() {
          return PRE_DECORATION_FILTER_ORDER - 1; // run before PreDecoration
        }

        @Override
        public String filterType() {
          return PRE_TYPE;
        }

        @Override
        public boolean shouldFilter() {
          RequestContext ctx = RequestContext.getCurrentContext();
          return !ctx.containsKey(FORWARD_TO_KEY) // a filter has already forwarded
            && !ctx.containsKey(SERVICE_ID_KEY); // a filter has already determined serviceId
        }

        @Override
        public Object run() {
          RequestContext ctx = RequestContext.getCurrentContext();
          HttpServletRequest request = ctx.getRequest();
          if (request.getParameter("sample") != null) {
            // put the serviceId in `RequestContext`
            ctx.put(SERVICE_ID_KEY, request.getParameter("foo"));
          }
          return null;
        }
      }
      #+END_SRC

      路由过滤器（Route Filter）在前置过滤器之后，请求其它服务之前。通常路由过滤
      器用来转义请求和回复的数据，下面是一个例子
      #+BEGIN_SRC java
      public class OkHttpRoutingFilter extends ZuulFilter {
        @Autowired
        private ProxyRequestHelper helper;

        @Override
        public String filterType() {
          return ROUTE_TYPE;
        }

        @Override
        public int filterOrder() {
          return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1;
        }

        @Override
        public boolean shouldFilter() {
          return RequestContext.getCurrentContext().getRouteHost() != null
            && RequestContext.getCurrentContext().sendZuulResponse();
        }

        @Override
        public Object run() {
          OkHttpClient httpClient = new OkHttpClient.Builder()
            // customize
            .build();

          RequestContext context = RequestContext.getCurrentContext();
          HttpServletRequest request = context.getRequest();

          String method = request.getMethod();

          String uri = this.helper.buildZuulRequestURI(request);

          Headers.Builder headers = new Headers.Builder();
          Enumeration<String> headerNames = request.getHeaderNames();
          while (headerNames.hasMoreElements()) {
            String name = headerNames.nextElement();
            Enumeration<String> values = request.getHeaders(name);

            while (values.hasMoreElements()) {
              String value = values.nextElement();
              headers.add(name, value);
            }
          }

          InputStream inputStream = request.getInputStream();

          RequestBody requestBody = null;
          if (inputStream != null && HttpMethod.permitsRequestBody(method)) {
            MediaType mediaType = null;
            if (headers.get("Content-Type") != null) {
              mediaType = MediaType.parse(headers.get("Content-Type"));
            }
            requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream));
          }

          Request.Builder builder = new Request.Builder()
            .headers(headers.build())
            .url(uri)
            .method(method, requestBody);

          Response response = httpClient.newCall(builder.build()).execute();

          LinkedMultiValueMap<String, String> responseHeaders = new LinkedMultiValueMap<>();

          for (Map.Entry<String, List<String>> entry : response.headers().toMultimap().entrySet()) {
            responseHeaders.put(entry.getKey(), entry.getValue());
          }

          this.helper.setResponse(response.code(), response.body().byteStream(), responseHeaders);
          context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running
          return null;
        }
      }
      #+END_SRC

      后置路由器（Post Filter）主要处理回复，下面是一个添加 ~UUID~ 和 ~X-Sample~
      头的例子
      #+BEGIN_SRC java
      public class AddResponseHeaderFilter extends ZuulFilter {
        @Override
        public String filterType() {
          return POST_TYPE;
        }

        @Override
        public int filterOrder() {
          return SEND_RESPONSE_FILTER_ORDER - 1;
        }

        @Override
        public boolean shouldFilter() {
          return true;
        }

        @Override
        public Object run() {
          RequestContext context = RequestContext.getCurrentContext();
          HttpServletResponse servletResponse = context.getResponse();
          servletResponse.addHeader("X-Sample", UUID.randomUUID().toString());
          return null;
        }
      }
      #+END_SRC

*** Ribbon
    Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将
    Netflix 的中间层服务连接在一起。Ribbon 客户端组件提供一系列完善的配置项如连
    接超时，重试等。简单的说，就是在配置文件中列出 Load Balancer（简称 LB）后面
    所有的机器，Ribbon 会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连
    接这些机器。我们也很容易使用 Ribbon 实现自定义的负载均衡算法。

**** Ribbon Client
***** 配置相关文件
      ~pom.xml~ 添加 ~spring-cloud-starter-netflix-ribbon~ 的依赖项
      #+BEGIN_SRC xml
      <!-- pom.xml -->
      <project>
        <dependencies>
          <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
          </dependency>
        </dependencies>
      </project>
      #+END_SRC

      #+BEGIN_SRC yaml
      users:
        ribbon:
          NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList
          NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule
      #+END_SRC

***** 使用配置类来进行配置
      Ribbon 支持使用配置类来配置，使用 ~@RibbonClient~ 注解进行相关配置
      #+BEGIN_SRC java
      // 设置默认调用的配置类
      @RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)
      public class RibbonClientDefaultConfigurationTestsConfig {
        public static class BazServiceList extends ConfigurationBasedServerList {
          public BazServiceList(IClientConfig config) {
            super.initWithNiwsConfig(config);
          }
        }
      }

      // 客户端配置实现类
      @Configuration
      class DefaultRibbonConfig {

        @Bean
        public IRule ribbonRule() { return new BestAvailableRule(); }

        @Bean
        public IPing ribbonPing() { return new PingUrl(); }

        @Bean
        public ServerList<Server> ribbonServerList(IClientConfig config) {
          return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config);
        }

        @Bean
        public ServerListSubsetFilter serverListFilter() {
          ServerListSubsetFilter filter = new ServerListSubsetFilter();
          return filter;
        }
      }
      #+END_SRC

      Ribbon 客户端的配置, 如果不指定会使用默认的实现:
      1. ~IClientConfig~ 客户端相关配置
      2. ~IRule~ 定义负载均衡策略
      3. ~IPing~ 定义如何 ping 目标服务实例来判断是否存活, ribbon 使用单独的线程
         每隔一段时间(默认 10s)对本地缓存的 ~ServerList~ 做一次检查
      4. ~ServerList~ 定义如何获取服务实例列表. 两种实现基于配置的
         ~ConfigurationBasedServerList~ 和基于 Eureka 服务发现的
         ~DiscoveryEnabledNIWSServerList~
      5. ~ServerListFilter~ 用来使用期望的特征过滤静态配置动态获得的候选服务实例
         列表. 若未提供, 默认使用 ~ZoneAffinityServerListFilter~
      6. ~ILoadBalancer~ 定义了软负载均衡器的操作的接口. 一个典型的负载均衡器至少需
         要一组用来做负载均衡的服务实例, 一个标记某个服务实例不在旋转中的方法, 和
         对应的方法调用从实例列表中选出某一个服务实例.
      7. ~ServerListUpdater~ ~DynamicServerListLoadBalancer~ 用来更新实例列表的
         策略
         - 推 -> ~EurekaNotificationServerListUpdater~
         - 拉 -> ~PollingServerListUpdater~ 默认是拉

** Spring Cloud Gateway
   [[https://spring.io/projects/spring-cloud-gateway][Spring Cloud Gateway]] 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project
   Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有
   效的统一的 API 路由管理方式，官方的手册见 [[https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.0.M1/][2.2.0.M1]]

* 参考链接
  1. [[https://docs.spring.io/spring/docs/current/spring-framework-reference/][Spring Framework 文档]]
  2. [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html][Spring Web MVC文档]]
  3. [[https://docs.spring.io/spring-boot/docs/current/reference/html/][Spring Boot 文档]]
