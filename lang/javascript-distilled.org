#+TITLE: JavaScript 编程语言精粹
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2019-07-02 Tue 11:04:00>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+TAGS: javascript programming language distilled

* 基础知识
** 常量和变量
   定义常量使用 =const= 关键字，变量有 =var= 和 =let= ，其中 =var= 是旧版本的定
   义变量方法，它没有 scope，但是 =let= 是有 scope 的，所以无论如何 *定义变量请
   使用 let 关键字*

   #+BEGIN_SRC js
    > if (true) {
    ... var v1 = true;
    ... }
    > v1
    true
    > if (true) {
    ... let v2 = true;
    ... }
    > v2
    Thrown:
    ReferenceError: v2 is not defined
    >
   #+END_SRC

** null 和 undefined
   =null= 在 JavaScript 中表示空值， =undefined= 通常是为没有赋值的变量。通常变
   量为空的时候要使用 =null= ，尽量避免 =undefined=
   #+BEGIN_SRC js
     > null == undefined
     true
     > null === undefined
     false
     > undefined == undefined
     true
     > typeof undefined
     'undefined'
     > typeof null
     'object'
     > typeof true
     'boolean'
     > typeof 0
     'number'
     >
   #+END_SRC

** 类型
*** 基本类型
    JavaScript 的基本类型包括： ~string~, ~number~, ~boolean~, ~symbol~, ~null~
    和 ~undefined~
    - 普通对象都有相应的方法
    - ~null~ 和 ~undefined~ 没有方法

    JavaScript 的基本类型有以下 =包装类= ，例如： ~String~, ~Number~, ~Boolean~
    和 ~Symbol~

*** 类型转换
    转换成字符串
    #+BEGIN_SRC js
      > String(true)
      'true'
      > String(null)
      'null'
      > String(23)
      '23'
      >String(undefined)
      'undefined'
      > '' + 21
      '21'
      > 2 + 2 + '1'
      '41'
    #+END_SRC
    转换成数值
    #+BEGIN_SRC js
      > "6" / "3"
      2
      > Number("234")
      234
      > Number("str")
      NaN
      > Number(null)
      0
      > Number(undefined)
      NaN
      > Number(true)
      1
      > Number(false)
      0
      > +'12.3'
      12.3
      > parseInt('23')
      23
      > parseFloat('3.14')
      3.14
    #+END_SRC

* 控制流
** if 条件, switch case 多层条件控制
   #+BEGIN_SRC js
     if (year < 2015) {
       console.log( 'Too early...' );
     } else if (year > 2015) {
       console.log( 'Too late' );
     } else {
       console.log( 'Exactly!' );
     }

     let a = 2 + 2;

     switch (a) {
       case 3:
         console.log( 'Too small' );
         break;
       case 4:
         console.log( 'Exactly!' );
         break;
       case 5:
         console.log( 'Too large' );
         break;
       default:
         console.log( "I don't know such values" );
     }
   #+END_SRC

** while for 循环
   #+BEGIN_SRC js
     let i = 0;
     while (i < 3) { // shows 0, then 1, then 2
       console.log( i );
       i++;
     }

     do {
       console.log( i );
       i++;
     } while (i < 3);

     for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
       console.log(i);
     }
   #+END_SRC

** try catch 处理异常
   异常一般用到的比较少，这里先记上
   #+BEGIN_SRC js
     try {
       console.log( 'try' );
       if (confirm('Make an error?')) BAD_CODE();
     } catch (e) {
       console.log( 'catch' );
     } finally {
       console.log( 'finally' );
     }
   #+END_SRC

* 函数
** 函数定义
   函数是 JavaScript 的重要工具，定义函数有以下几种方法
   #+BEGIN_SRC js
     function sum(a, b) {
       let result = a + b;
       return result;
     }
     let sum = function(a, b) {
       let result = a + b;
       return result;
     }

     // expression at the right side
     let sum = (a, b) => a + b;
     // or multi-line syntax with { ... }, need return here:
     let sum = (a, b) => {
       // ...
       return a + b;
     }

     // without arguments
     let sayHi = () => console.log("Hello");
     // with a single argument
     let double = n => n * 2;
   #+END_SRC

   箭头函数绑定了上下文，所以箭头函数有以下特点：
   - 没有 ~this~
   - 没有 ~arguments~
   - 不能使用 ~new~ 来创建对象
   - 没有 ~super~

** 带默认值的函数
   #+BEGIN_SRC js
     function showMessage(from, text) {
       console.log(from + ': ' + text);
     }
     function showMessage2(from, text='hello') {
       console.log(from + ': ' + text);
     }
   #+END_SRC

** Rest 参数和 =...= 操作符
*** Rest 参数
    JavaScript 中的三点操作符 =...= 可以定义变长的参数
    #+BEGIN_SRC js
      function sumAll(...args) { // args is the name for the array
        let sum = 0;
        for (let arg of args) sum += arg;
        return sum;
      }

      sumAll(1); // 1
      sumAll(1, 2); // 3
      sumAll(1, 2, 3); // 6
    #+END_SRC

*** ~arguments~ 变量
    JavaScript 的每个函数中都默认传入一个 Array-like 的 ~arguments~ 变量，用于处
    理函数的对象。使用 ~arguments~ 主要是兼容以前 JavaScript 不支持 Rest 参数
    #+BEGIN_SRC js
      function showName() {
        console.log(arguments.length);
        console.log(arguments[0]);
        console.log(arguments[1]);

        // it's iterable
        // for(let arg of arguments) console.log(arg);
      }

      // shows: 2, Julius, Caesar
      showName("Julius", "Caesar");
      // shows: 1, Ilya, undefined (no second argument)
      showName("Ilya");
    #+END_SRC

*** =...= 操作符
    =...= 可以将数组中作为变长参数传入函数中
    #+BEGIN_SRC js
      > arr = [1, 2, 5]
      [ 1, 2, 5 ]
      > Math.max(1,2,5)
      5
      > Math.max(arr)
      NaN
      > Math.max(...arr)
      5
    #+END_SRC

    =...= 可以合并数组
    #+BEGIN_SRC js
      > let a = [1, 3, 5];
      > let b = [2, 4, 6];
      > [...a, ...b]
      [ 1, 3, 5, 2, 4, 6 ]
      > Math.max(9, ...a, ...b)
      9
      >
    #+END_SRC

** 函数对象和 NFE
   JavaScript 中函数也是一种对象，所以函数都是 ~Function~ 的实例。NFE 是命名函数
   表达式（Named Function Expression）。

*** 函数对象
    - 函数对象都包含 =name= 属性，表示函数的名称
    - 函数对象包含 =length= 属性，表示函数的参数的长度
    #+BEGIN_SRC js
      > function sayHi() { console.log('hello'); }
      > sayHi.name
      'sayHi'
      > sayHi.length
      0
      >
    #+END_SRC

*** NFE
    NFE 在函数定义赋值前重新添加一个函数名称，具体如下：
    #+BEGIN_SRC js
      let sayHi = function func(who) { // additional func as name
        console.log(`Hello, ${who}`);
      };
    #+END_SRC
    这样定义的好处是：
    - func 函数名对函数内部可见
    - func 函数名对函数外部不可见
    #+BEGIN_SRC js
      let sayHi = function func(who) {
        if (who) {
          console.log(`Hello, ${who}`);
        } else {
          func("Guest"); // use func to re-call itself
        }
      };

      sayHi(); // Hello, Guest
      // But this won't work:
      func(); // Error, func is not defined (not visible outside of the function)
    #+END_SRC

** 调度 setTimeout/setInterval
   - ~setTimeout~ 设置一定计时后运行
   - ~setInterval~ 设置一定周期运行函数
   - ~clearTimeout/clearInterval~ 取消计时器

*** setTimeout
    #+BEGIN_SRC js
      let timerId = setTimeout(func|code, delay[, arg1, arg2...])
    #+END_SRC
    - ~func~ 回调函数
    - ~delay~ 延迟毫秒数
    - ~arg1, arg2, ...~ 回调函数的参数
    #+BEGIN_SRC js
      function sayHi() {
        console.log('Hello');
      }

      setTimeout(sayHi, 1000);
    #+END_SRC

    ~setTimeout(func,0)~ 是在定义后里面运行函数，这个可以实现异步调用，例如下面
    的例子中会在显示 Hello 过后立马显示 World
    #+BEGIN_SRC js
      setTimeout(() => console.log("World"), 0);

      console.log("Hello");
    #+END_SRC
    另外使用 ~setTimeout(func,0)~ 可以将高消耗 CPU 的工作放在初始化过后进行

*** clearTimeout
    #+BEGIN_SRC js
      let timerId = setTimeout(...);
      clearTimeout(timerId);
    #+END_SRC

*** setInterval
    #+BEGIN_SRC js
      let timerId = setInterval(func|code, delay[, arg1, arg2...])
    #+END_SRC
    参数和 ~setTimeout~ 类似

    #+BEGIN_SRC js
      // repeat with the interval of 2 seconds
      let timerId = setInterval(() => console.log('tick'), 2000);

      // after 5 seconds stop
      setTimeout(() => { clearInterval(timerId); console.log('stop'); }, 5000);
    #+END_SRC

** 函数 ~this~ 绑定
   - ~func.bind(context, ...args)~ 绑定 func 的 ~this~ 到 context，详见 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind][bind]]
   - ~func.call(context, ...args)~ 绑定 func 的 ~this~ 到 context, 然后调用函数
     func，将 =...args= 作为参数传入，详见 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call][call]]
   - ~func.apply(context, args)~ 绑定 func 的 ~this~ 到 context, 然后调用函数
     func，将 Array-like 的 =args= 作为参数传入，详见 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply][apply]]

** Currying
   Currying 将 ~f(a,b,c)~ 转化成 ~f(a)(b)(c)~ 这样的调用。一个简单的 curry 实现如
   下：
   #+BEGIN_SRC js
     function curry(func) {

       return function curried(...args) {
         if (args.length >= func.length) {
           return func.apply(this, args);
         } else {
           return function(...args2) {
             return curried.apply(this, args.concat(args2));
           }
         }
       };

     }
   #+END_SRC

   lodash 库提供 [[https://lodash.com/docs/4.17.15#curry][_.curry]] 实现的工具函数
   #+BEGIN_SRC js
     var abc = function(a, b, c) {
       return [a, b, c];
     };

     var curried = _.curry(abc);

     curried(1)(2)(3);
     // => [1, 2, 3]

     curried(1, 2)(3);
     // => [1, 2, 3]

     curried(1, 2, 3);
     // => [1, 2, 3]

     // Curried with placeholders.
     curried(1)(_, 3)(2);
     // => [1, 2, 3]
   #+END_SRC

* 标准内置对象
** Number 数字
*** 转化成数字
    - ~parseInt(str, base)~ 转化成整数
    - ~parseFloat(str)~ 转化成浮点数

*** 数字截断
    主要有： ~Math.floor~ , ~Math.ceil~, ~Math.round~, ~Math.trunc~ 这些方法，例
    子见下表

    |      | Math.floor | Math.ceil | Math.round | Math.trunc |
    |------+------------+-----------+------------+------------|
    |  3.1 |          3 |         4 |          3 |          3 |
    |  3.6 |          3 |         4 |          4 |          3 |
    | -1.1 |         -2 |        -1 |         -1 |         -1 |
    | -1.6 |         -2 |        -1 |         -2 |         -1 |

*** 其它函数
    - ~Math.random()~ 取 0 到 1 之间的随机数
    - ~Math.max(a, b, c, ..)~ 和 ~Math.min(a, b, c, ..)~ 取最值
    - ~Math.pow(n, power)~

*** 特殊数字测试
    - ~isFinite~ 如果不是无穷大，返回真；否则返回假。 ~Infinity~ 和 ~-Infinity~
      表示无穷大和无穷小
    - ~isNaN~ 测试是否是一个数字

    #+BEGIN_SRC js
      > isFinite(NaN)
      false
      > isFinite(-Infinity)
      false
      > isFinite(Infinity)
      false
      > isFinite(12)
      true
      > isNaN(NaN)
      true
      > isNaN(2)
      false
      > isNaN("ss")
      true
      >
    #+END_SRC

** String 字符串
   String 对象在 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String][MDN]] 中有详细的介绍
*** 定义字符串
    注意使用 =${...}= 表达式
    #+BEGIN_SRC js
      > "Double quote"
      'Double quote'
      > 'Single quote'
      'Single quote'
      > let name = 'Jack'
      > `Hi, ${name}`
      'Hi, Jack'
      > `1 + 2 = ${1 + 2}`
      '1 + 2 = 3'
    #+END_SRC

*** 字符串长度
    ~str.length~ ，字符串长度是一个对象中的属性
    #+BEGIN_SRC js
      > 'hello'.length
      5
    #+END_SRC

*** 获取子字符串
    - ~[]~ 和 ~str.charAt(idx)~: 通过下标索引获取字符
    - ~str.slice(beginIndex[,endIndex])~ 获取子字符串，如果 beginIndex 或
      endIndex 是负表示反向索引
    - ~str.substring(indexStart[,indexEnd])~ 和 slice 和类似，但是 substring 支
      持 indexEnd 小于 indexStart
    #+BEGIN_SRC js
      > 'abcd'.substring(1,3)
      'bc'
      > 'abcd'.substring(3,1)
      'bc'
      > 'abcd'.slice(1,3)
      'bc'
      > 'abcd'.slice(3,1)
      ''
      >
    #+END_SRC

*** 字符串查找
    - ~str.indexOf(searchValue,fromIndex)~ : 查找字符串中是否包含 searchValue，
      并返回下标
    - ~str.lastIndexOf(searchValue,fromIndex)~ : 反向查找字符串中是否包含
      searchValue，并返回下标
    - ~str.includes(searchString,[position])~ : 查找字符串，返回布尔值
    - ~str.startsWith(searchString[,position])~ 和
      ~str.endsWith(searchString[,length])~
    #+BEGIN_SRC js
      > 'abaa'.indexOf('a')
      0
      > 'abaa'.indexOf('b')
      1
      > 'abaa'.lastIndexOf('a')
      3
      > 'abaa'.includes('b')
      true
      > 'hello'.startsWith('h')
      true
      > 'hello'.startsWith('a')
      false
      > 'hello'.endsWith('a')
      false
      >
    #+END_SRC

*** 字符串替换/正则表达式
    - ~str.replace(regexp|substr,newSubstr|function)~
    - ~str.match(regexp)~ : 匹配 regexp 返回数组，如果 regexp 是 null 则返回空
    - ~str.search(regexp)~
    #+BEGIN_SRC js
      > 'abaa'.replace('a', '$')
      '$baa'
      > 'abaa'.replace(/a/g, '$')
      '$b$$'
      >
    #+END_SRC

    #+BEGIN_SRC js
      > 'abaa'.match(/a/g)
      [ 'a', 'a', 'a' ]
      > 'abaa'.match(/a/)
      [ 'a', index: 0, input: 'abaa', groups: undefined ]
      > 'abaa'.match(/^a/)
      [ 'a', index: 0, input: 'abaa', groups: undefined ]
      > 'For more information, see Chapter 3.4.5.1'.match(/see (chapter \d+(\.\d)*)/i)
      [ 'see Chapter 3.4.5.1',
        'Chapter 3.4.5.1',
        '.1',
        index: 22,
        input: 'For more information, see Chapter 3.4.5.1',
        groups: undefined ]
      > 'abaa'.match(null)
      null
    #+END_SRC

*** 其它字符串函数
    - ~str.padStart()~, ~str.padEnd()~
    - ~str.repeat()~
    - ~str.trim()~, ~str.trimStart()~, ~str.trimEnd()~
    - ~str.toUpperCase()~, ~str.toLowerCase()~
    - ~str.split()~
    #+BEGIN_SRC js
      > 'abaa'.split()
      [ 'abaa' ]
      > 'abaa'.split('')
      [ 'a', 'b', 'a', 'a' ]
    #+END_SRC

** Array 数组
   数组是具有固定长度 (~arr.length~) 的同一类元素的集合，具体参考 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array][MDN]] 中的定义。

*** 创建
    #+BEGIN_SRC js
      > let fruits = ['Apple', 'Banana', 'Orange']
      undefined
      > fruits.length
      3
    #+END_SRC

*** 修改元素：添加/删除
    - ~push(...items)~ : 添加元素到数组结尾
    - ~pop()~ : 移除结尾的元素
    - ~shift()~ : 删除起始的元素
    - ~unshift(...items)~ : 添加元素到数组起始
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      > fruits.push('Grape')
      4
      > fruits
      [ 'Apple', 'Banana', 'Orange', 'Grape' ]
      > fruits.pop()
      'Grape'
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      > fruits.shift()
      'Apple'
      > fruits
      [ 'Banana', 'Orange' ]
      > fruits.unshift('Apple')
      3
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      >
    #+END_SRC

    - ~splice(pos, deleteCount, ...items)~ : 在 ~pos~ 位置删除 ~deleteCount~ 个元
      素然后插入 ~items~
    - ~slice(start, end)~ : 创建一个新的数组, 复制 ~start~ 到 ~end~ (不包含) 到新
      的数组中
    - ~concat(...items)~ : 返回一个新的数组: 拷贝当前数组的所有元素然后添加
      ~items~ 到新的数组中. 如果任何 ~items~ 是一个数组, 数组里面的元素都会添加的
      新的数组中
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      > let new_fruits = fruits.slice(0, 2)
      > new_fruits
      [ 'Apple', 'Banana' ]
      > fruits.splice(1, 1)
      [ 'Banana' ]
      > fruits
      [ 'Apple', 'Orange' ]
      > fruits
      [ 'Apple', 'Orange' ]
      > fruits.splice(1, 0, 'Pear')
      []
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.concat('Banana')
      [ 'Apple', 'Pear', 'Orange', 'Banana' ]
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      >
    #+END_SRC

*** 查找
    - ~indexOf/lastIndexOf(item, pos)~ : 查找 ~item~ , 起始位置是~pos~ , 如果没有
      找到则返回 ~-1~
    - ~includes(value)~ : 返回 ~true~ 如果数组包含 ~value~ , 否则 ~false~
    - ~find/filter(func)~ : 使用谓词函数过滤数组, 返回第一个/所有的使得谓词函数成
      立的元素
    - ~findIndex(func)~ : 和 ~find~ 相似, 但是返回下标索引而不是数组元素
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.indexOf('Pear')
      1
      > fruits.indexOf('Banana')
      -1
      > fruits.find(function (e) { return e.length >= 5;})
      'Apple'
      > fruits.filter(function (e) { return e.length >= 5;})
      [ 'Apple', 'Orange' ]
      > fruits.includes('Banana')
      false
      > fruits.includes('Pear')
      true
      > 'Banana' in fruits
      false
      > 'Pear' in fruits
      false
    #+END_SRC

*** 迭代
    - ~forEach(func)~ : 调用 ~func~ 处理所有的数组里的元素, 但是不返回
    #+BEGIN_SRC js
      ['Apple', 'Banana', 'Orange'].forEach(function(e, i, arr) {
        console.log(i + " : " + e)
      })
    #+END_SRC

*** 数组变换
    - ~map(func)~ : 调用 ~func~ 处理所有数组里的元素，返回处理结果集构成的新数组
    - ~sort(func)~ : 使用 ~func~ 排序数组，然后返回
    - ~reverse()~ : 返回逆序的数组
    - ~split/join~ : 在字符串和数组之间转换
    - ~reduce(func, initial)~ : 计算得出一个值， 通过调用 ~func~ 函数处理起始值和
      中间值
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.map(function(e) { return e.toUpperCase();})
      [ 'APPLE', 'PEAR', 'ORANGE' ]
      > fruits.reduce(function(a, e) { return a+':'+e;}, '')
      ':Apple:Pear:Orange'
      > fruits.join(':')
      'Apple:Pear:Orange'
      > 'Apple:Pear:Orange'.split(':')
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.sort()
      [ 'Apple', 'Orange', 'Pear' ]
      > fruits
      [ 'Apple', 'Orange', 'Pear' ]
      > fruits.sort(function(a,b) {return a.length>b.length?1:-1;})
      [ 'Pear', 'Apple', 'Orange' ]
      > fruits.reverse()
      [ 'Orange', 'Apple', 'Pear' ]
      >
    #+END_SRC

*** 其它
    - ~Array.isArray(arr)~ : 检查 ~arr~ 是否是数组对象
    - ~arr.some(fn)~ / ~arr.every(fn)~ : 调用 ~fn~ 作用于数组所有元素，如果任何/
      所有的都返回 ~true~, 则返回 ~true~, 否则返回 ~false~
    - ~arr.fill(value, start, end)~ : 使用 ~value~ 填充数组 ~start~ 到 ~end~ 位置
      的元素
    - ~arr.copyWithin(target, start, end)~ : 复制数组 ~start~ 到 ~end~ 位置中的元
      素到自身 ~target~ 位置中, 注意会覆盖已存在的元素

** 迭代器/数组类似物
*** Iterable 和 Array-like
    - =Iterable= 是实现了 =Symbol.iterator= 方法的对象
      + =Symbol.iterator= 必须包含 =next()= 方法
      + =next()= 方法必须返回像 ~{done: Boolean, value: any}~ 这样的对象，done 为
        ~true~ 表示迭代器结束
      + =Iterable= 主要是使用 =for..of= 迭代器进行迭代
    - =Array-like= 是含义 =length= 属性和可索引的对象

    #+BEGIN_SRC js
      let arrayLike = { // has indexes and length => array-like
        0: "Hello",
        1: "World",
        length: 2
      };

      let iterable = {
        from: 1,
        to: 5,
        // 1. call to for..of initially calls this
        [Symbol.iterator]() {
          this.current = this.from;
          // 2. ...it returns the iterator:
          return this;
        },
        // 3. next() is called on each iteration by the for..of loop
        next() {
          // 4. it should return the value as an object {done:.., value :...}
          if (this.current <= this.to) {
            return { done: false, value: this.current++ };
          } else {
            return { done: true };
          }
        }
        }
      }

      for (let num of iterable) { console.log(num); } // => prints 1, 2, 3, 4, 5
    #+END_SRC

*** ~Array.from~
    ~Array.from(arrayLike[,mapFn[,thisArg]])~ 通过 Array-like 的对象来新建一个真
    的 Array，例如字符串 ~'foo'~ 是 Array-like 对象，因此可以建立一个新的数组
    #+BEGIN_SRC js
      > Array.from('foo');
      [ 'f', 'o', 'o' ]
    #+END_SRC

** Map/Set 等标准内置对象
   [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map][Map]] , WeakMap, [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set][Set]], WeakSet 等都是常用的 Javascript 对象，具体参考 MDN 中的定
   义 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects][ Standard built-in objects]]

   Map 对象操作
   #+BEGIN_SRC js
     let map = new Map();

     map.set('1', 'str1');   // a string key
     map.set(1, 'num1');     // a numeric key
     map.set(true, 'bool1'); // a boolean key

     // remember the regular Object? it would convert keys to string
     // Map keeps the type, so these two are different:
     console.log( map.get(1)   ); // 'num1'
     console.log( map.get('1') ); // 'str1'

     console.log( map.size ); // 3

     let recipeMap = new Map([
       ['cucumber', 500],
       ['tomatoes', 350],
       ['onion',    50]
     ]);

     // iterate over keys (vegetables)
     for (let vegetable of recipeMap.keys()) {
       console.log(vegetable); // cucumber, tomatoes, onion
     }

     // iterate over values (amounts)
     for (let amount of recipeMap.values()) {
       console.log(amount); // 500, 350, 50
     }

     // iterate over [key, value] entries
     for (let entry of recipeMap) { // the same as of recipeMap.entries()
       console.log(entry); // cucumber,500 (and so on)
     }
   #+END_SRC

   Set 集合函数
   #+BEGIN_SRC js
     let set = new Set();

     let john = { name: "John" };
     let pete = { name: "Pete" };
     let mary = { name: "Mary" };

     // visits, some users come multiple times
     set.add(john);
     set.add(pete);
     set.add(mary);
     set.add(john);
     set.add(mary);

     // set keeps only unique values
     console.log( set.size ); // 3

     for (let user of set) {
       console.log(user.name); // John (then Pete and Mary)
     }

     let set = new Set(["oranges", "apples", "bananas"]);

     for (let value of set) console.log(value);

     // the same with forEach:
     set.forEach((value, valueAgain, set) => {
       console.log(value);
     });
   #+END_SRC

** Object 对象
   [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object][Object]] 是 JavaScript 中的对象

*** 定义对象
    #+BEGIN_SRC js
      > let user1 = new Object()
      > user1
      {}
      > let user2 = {}
      > user2
      {}
      > let user3 = {name: 'Tom', age: 22}
      > user3
      { name: 'Tom', age: 22 }
      > user3.name
      'Tom'
      > user3['name']
      'Tom'
      >
    #+END_SRC

*** 对象基本操作
    - 引用对象中的值
      + 点方式： ~obj.key~
      + 方括号方式： ~obj['key']~
    - 删除对象中的值 ~delete obj.key~
    - 判断对象中是否存在键 ~'key' in obj~
    #+BEGIN_SRC js
      let usr = {name: 'Tom', age: 22}
      > 'name' in usr
      true
      > 'birthday' in usr
      false
      >
    #+END_SRC

*** 对象引用/复制
    ~=~ 赋值是引用
    #+BEGIN_SRC js
      > obj1 = {a:'Apple', b:1}
      { a: 'Apple', b: 1 }
      > obj2 = obj1
      { a: 'Apple', b: 1 }
      > obj2.b = 7
      7
      > obj1
      { a: 'Apple', b: 7 }
      >
    #+END_SRC

    ~Object.assign(...)~ 可以实现复制传值，或者使用 lodash 库中的
    [[https://lodash.com/docs#cloneDeep][_.cloneDeep(obj)]]
    #+BEGIN_SRC js
      > obj3 = Object.assign({}, obj1)
      { a: 'Apple', b: 7 }
      > obj3.b = 9
      9
      > obj1
      { a: 'Apple', b: 7 }
      >
    #+END_SRC

    下面是更多的传值的示例
    #+BEGIN_SRC js
      > usr
      { name: 'Tom', age: 22, foo: undefined }
      > usr1 = usr
      { name: 'Tom', age: 22, foo: undefined }
      > usr1 == usr
      true
      > usr1 === usr
      true
      > let _usr = {}
      > for (k in usr) { _usr[k] = usr[k]; }
      > _usr
      { name: 'Tom', age: 22, foo: undefined }
      > _usr == usr
      false
      > _usr === usr
      false
      > usr
      { name: 'Jackson', age: 22, foo: undefined }
      > delete usr.foo
      true
      > usr
      { name: 'Jackson', age: 22 }
      > 'foo' in usr
      false
      >
    #+END_SRC

*** 更新对象
    ~Object.assign(dest[, src1, src2, src3...])~ 可以批量更新对象中的数值。
    #+BEGIN_SRC js
      > usr
      { name: 'Tom', age: 22, foo: undefined }
      > Object.assign(usr, {name: 'Jackson'})
      { name: 'Jackson', age: 22, foo: undefined }
      >
    #+END_SRC

*** 对象的键和值
    - ~Object.keys(obj)~ 返回 obj 的键
    - ~Object.values(obj)~ 返回 obj 的值
    - ~Object.entries(obj)~ 返回 obj 的 [key, value] 对

    #+BEGIN_SRC js
      > let o1 = {apple:1, banana:2, orange:3}
      > o1
      { apple: 1, banana: 2, orange: 3 }
      > Object.keys(o1)
      [ 'apple', 'banana', 'orange' ]
      > o1.keys()
      TypeError: o1.keys is not a function
      > Object.values(o1)
      [ 1, 2, 3 ]
      > Object.entries(o1)
      [ [ 'apple', 1 ], [ 'banana', 2 ], [ 'orange', 3 ] ]
      >
    #+END_SRC

** Date 时间和日期
   [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date][Date]] 是表示时间和日期的内置对象。个人感觉 JavaScript 原始提供的时间日期操作函数
   并不是很好用，如果有条件的话可以移步时间工具库 [[http://momentjs.cn/][momentjs]]

*** 创建日期对象
    ~new Date()~, ~new Date(milliseconds)~ 和 ~new Date(date_str)~ 可以创建日期
    对象
    #+BEGIN_SRC js
      > new Date()
      2019-07-30T06:58:04.792Z
      > new Date(123124123)
      1970-01-02T10:12:04.123Z
      > new Date("2017-01-26")
      2017-01-26T00:00:00.000Z
    #+END_SRC

*** 时间函数
    具体见下面的样例
    #+BEGIN_SRC js
      > let now = new Date()
      > now.getFullYear()
      2019
      > now.getYear()
      119
      > now.getMonth()
      6
      > now.getDate()
      30
      > now.getHours()
      15
      > now.getMinutes()
      5
      > now.getSeconds()
      21
      > now.getMilliseconds()
      725
      > now.getDay()
      2
      >
    #+END_SRC

*** 时间戳
    时间戳有以下函数
    #+BEGIN_SRC js
      // get timestamp
      > now
      2019-07-30T07:05:21.725Z
      > now.getTime()
      1564470321725
      > +now
      1564470321725
      > Date.now()
      1564470538021

      // time diff
      > new Date() - now
      260547
    #+END_SRC

*** 字符串和 Date 互转
    ~Date.parse(str)~, str 应满足 =YYYY-MM-DDTHH:mm:ss.sssZ= 格式
    #+BEGIN_SRC js
      > Date.parse('2012-01-26T13:51:50.417-07:00');
      1327611110417
    #+END_SRC

    Date 转字符串有以下方法
    #+BEGIN_SRC js
      > now.toJSON()
      '2019-07-30T07:05:21.725Z'
      > now.toDateString()
      'Tue Jul 30 2019'
      > now.toISOString()
      '2019-07-30T07:05:21.725Z'
      > now.toString()
      'Tue Jul 30 2019 15:05:21 GMT+0800 (GMT+08:00)'
      > now.toTimeString()
      '15:05:21 GMT+0800 (GMT+08:00)'
      > now.toUTCString()
      'Tue, 30 Jul 2019 07:05:21 GMT'
      >
    #+END_SRC

** JSON
   - ~JSON.stringify(obj)~ 将数组或对象转成 JSON 字符串
   - ~JSON.parse(str)~ 解析 JSON 字符串
   #+BEGIN_SRC js
     > let student = {
     ...   name: 'John',
     ...   age: 30,
     ...   isAdmin: false,
     ...   courses: ['html', 'css', 'js'],
     ...   wife: null
     ... };
     undefined
     > JSON.stringify(student)
     '{"name":"John","age":30,"isAdmin":false,"courses":["html","css","js"],"wife":null}'
     > JSON.stringify([1,2,3])
     '[1,2,3]'
     > JSON.parse('[1,2,3,2,3]')
     [ 1, 2, 3, 2, 3 ]
     >
   #+END_SRC

* 面向对象知识
** ~new~ 关键字和构造器
*** 构造器
    JavaScript 中没有所谓的构造器，它的构造器实际上是一个函数，该函数满足以下两
    点：
    1. 函数名称使用 Pascal case 命名
    2. 函数只能使用 ~new~ 操作符来执行

    例如：
    #+BEGIN_SRC js
      function User(name) {
        this.name = name;
        this.isAdmin = false;
      }

      let user = new User("Jack");

      console.log(user.name); // Jack
      console.log(user.isAdmin); // false
    #+END_SRC

*** ~new~ 操作符
    ~new~ 操作符做了以下的事情:
    1. 新建了函数作用域的 ~this~ 对象
    2. 并且将新创建的 ~this~ 对象返回
    该过程大致如下面代码所示：
    #+BEGIN_SRC js
      function User(name) {
        // this = {};  (implicitly)

        // add properties to this
        this.name = name;
        this.isAdmin = false;

        // return this;  (implicitly)
      }
    #+END_SRC
** 属性的 flag 和描述符
   ~Object.getOwnPropertyDescriptor(obj,propertyName)~ 方法可以获取对象属性的描
   述符
   #+BEGIN_SRC js
     > let user = { name: 'Jinghui', age: 18}
     > user
     { name: 'Jinghui', age: 18 }
     > Object.getOwnPropertyDescriptor(user, 'name')
     { value: 'Jinghui',
       writable: true,
       enumerable: true,
       configurable: true }
     >
   #+END_SRC

   - =writable= 如果为真，则为可写属性
   - =enumerable= 如果为真，则在循环中可以被迭代到
   - =configurable= 如果为真，则可以使用 ~delete~ 删除

   ~Object.defineProperty(obj,propertyName,descriptor)~ 方法可以修改对象属性描述
   符的属性值
   #+BEGIN_SRC js
     > user.name = 'XiaoHu'
     'XiaoHu'
     > user
     { name: 'XiaoHu', age: 18 }
     > Object.defineProperty(user, 'name', {writable:false})
     { name: 'XiaoHu', age: 18 }
     > Object.getOwnPropertyDescriptor(user, 'name')
     { value: 'XiaoHu',
       writable: false,
       enumerable: true,
       configurable: true }
     > user.name = 'Jinghu Hu'
     'Jinghu Hu'
     > user
     { name: 'XiaoHu', age: 18 }
     >
   #+END_SRC

   ~Object.getOwnPropertyDescriptors(obj)~ 方法可以批量获取属性的描述符
   #+BEGIN_SRC js
     > user
     { name: 'XiaoHu', age: 18 }
     > Object.getOwnPropertyDescriptors(user)
     { name:
        { value: 'XiaoHu',
          writable: false,
          enumerable: true,
          configurable: true },
       age:
        { value: 18,
          writable: true,
          enumerable: true,
          configurable: true } }
     >
   #+END_SRC

   ~Object.defineProperties(obj,descriptors)~ 方法可以批量定义对象描述符的属性值
   #+BEGIN_SRC js
     Object.defineProperties(user, {
       name: { value: "John", writable: false },
       surname: { value: "Smith", writable: false },
       // ...
     });
   #+END_SRC

** 属性的 Getter 和 Setter
   #+BEGIN_SRC js
     let user = {
       name: "John",
       surname: "Smith",

       get fullName() {
         return `${this.name} ${this.surname}`;
       },

       set fullName(value) {
         [this.name, this.surname] = value.split(" ");
       }
     };

     // set fullName is executed with the given value.
     user.fullName = "Alice Cooper";
   #+END_SRC

** 原型 =[Prototype]=
   JavaScript 的对象中都一个隐藏的 =[Prototype]= 属性，该属性被用来设置对象的原
   型关系和一些面向对象的方法

*** 对象的原型 ~obj.__proto__~
    可以通过 ~obj.__proto__~ 来访问它 =[Prototype]= 。JavaScript 的继承关系都是
    靠 ~__proto__~ 来实现的
    #+BEGIN_SRC js
      > let animal = { eats: true };
      > let rabbit = { jumps: true};
      > rabbit.__proto__ = animal;
      { eats: true }
      > rabbit.eats
      true
      > rabbit.jumps
      true
      >
    #+END_SRC

    ~__proto__~ 的值需要满足以下两点：
    - ~__proto__~ 要么是一个对象，要么是 ~null~
    - ~__proto__~ 不能循环依赖

*** 函数的原型 ~F.prototype~
    现代的 JavaScript 可以使用 ~new F()~ 来创建对象， ~F.prototype~ 和
    ~obj.__proto__~ 功能类似（略有不同）
    #+BEGIN_SRC js
      > let animal = { eats: true };
      > function Rabbit(name) { this.name = name; }
      > Rabbit.prototype = animal;
      { eats: true }
      > let r = new Rabbit('White Rabbit');
      > r
      { name: 'White Rabbit' }
      > r.eats
      true
      > r.constructor === Rabbit
      false
    #+END_SRC

    ~F.prototype~ 需要注意以下几点：
    - ~F.prototype~ 和 ~obj.__proto__~ 相似，但是在 new 对象的时候设置了对象的
      =[Prototype]= 属性
    - ~F.prototype~ 要不是一个对象，要不为 ~null~
    - ~F.prototype~ 除了设置了 ~obj.__proto__~ 之外还设置了对象的构造器，即对象
      的 ~obj.constructor~ 属性

*** 原型的 Getter/Setter 方法
    原型也有相应的 Getter 和 Setter 方法
    - ~Object.create(proto[,descriptors])~ 创建一个空的对象，并设置原型为 proto
    - ~Object.getPrototypeOf(obj)~ 获取 obj 的原型
    - ~Object.setPrototypeOf(obj,proto)~ – 设置 obj 的原型为 proto
    #+BEGIN_SRC js
      let animal = { eats: true };

      // create a new object with animal as a prototype
      let rabbit = Object.create(animal);
      rabbit.eats // true

      // get the prototype of rabbit
      Object.getPrototypeOf(rabbit) === animal

      // change the prototype of rabbit to {}
      Object.setPrototypeOf(rabbit, {});
    #+END_SRC

    下面是一些可以获取对象属性的函数
    - ~Object.getOwnPropertySymbols(obj)~
    - ~Object.getOwnPropertyNames(obj)~
    - ~Reflect.ownKeys(obj)~
    #+BEGIN_SRC js
      > animal
      { eats: true }
      > rabbit
      { jumps: true }
      > Object.getOwnPropertySymbols(rabbit)
      []
      > Object.getOwnPropertyNames(rabbit)
      [ 'jumps' ]
      > Object.keys(rabbit)
      [ 'jumps' ]
      > Reflect.ownKeys(rabbit)
      [ 'jumps' ]
      > rabbit.__proto__
      { eats: true }
      > r.__proto__
      { eats: true }
      > rabbit.hasOwnProperty('jumps')
      true
      > rabbit.hasOwnProperty('eats')
      false
      >
    #+END_SRC

** 类
*** 类定义
    JavaScript 中没有类，所有的类都是通过对象来模拟得到的，如示例
    #+BEGIN_SRC js
      function User(name) {
        this.sayHi = function() {
          console.log(name);
        };
      }

      let user = new User("John");
      user.sayHi(); // John
    #+END_SRC

    #+BEGIN_SRC js
      class User {

        constructor(name) {
          this.name = name;
        }

        sayHi() {
          console.log(this.name);
        }

      }

      let user = new User("John");
      user.sayHi();
    #+END_SRC

*** 基于原型的类定义
    JavaScript 中的原型被用于定义类，为了保证子类方法在调用时可以共享父类中的方
    法，类的方法都被定义在 prototype 中，下面是典型是示例
    #+BEGIN_SRC js
      function Animal(name) { this.name = name; }
      Animal.prototype.eat = function() { console.log(`${this.name} eats.`); };

      function Rabbit(name) { this.name = name; }
      Rabbit.prototype.jump = function() { console.log(`${this.name} jumps!`);};

      // 1. 将子类的 prototype.__proto__ 设置成父类的 prototype
      Rabbit.prototype.__proto__ = Animal.prototype;

      let rabbit = new Rabbit("White Rabbit");
      // 2. 子类在调用 eat() 是根据原型链向上查找得到 eat 方法
      rabbit.eat();
      rabbit.jump();
    #+END_SRC

*** 继承
    继承使用 ~extends~ 关键字
    #+BEGIN_SRC js
      class Animal {
        constructor(name) {
          this.speed = 0;
          this.name = name;
        }
        // ...
      }

      class Rabbit extends Animal {
        constructor(name, earLength) {
          super(name);
          this.earLength = earLength;
        }
        // ...
      }

      let rabbit = new Rabbit("White Rabbit", 10);
      console.log(rabbit.name); // White Rabbit
      console.log(rabbit.earLength); // 10
    #+END_SRC

    - ~super.method()~ 调用父类方法
    - ~super()~ 调用父类构造器
    #+BEGIN_SRC js
      class Animal {

        constructor(name) {
          this.speed = 0;
          this.name = name;
        }

        run(speed) {
          this.speed += speed;
          console.log(`${this.name} runs with speed ${this.speed}.`);
        }

        stop() {
          this.speed = 0;
          console.log(`${this.name} stopped.`);
        }

      }

      class Rabbit extends Animal {
        hide() {
          console.log(`${this.name} hides!`);
        }

        stop() {
          super.stop(); // call parent stop
          this.hide(); // and then hide
        }
      }

      let rabbit = new Rabbit("White Rabbit");

      rabbit.run(5); // White Rabbit runs with speed 5.
      rabbit.stop(); // White Rabbit stopped. White rabbit hides!
    #+END_SRC

    ~instanceof~ 检测 obj 是否是 Class 的一个实例
    #+BEGIN_SRC js
      obj instanceof Class
    #+END_SRC

*** Minix
    混入 (Mixin) 是一个比较常用的技巧，基本思路是建一个对象，然后将所需混入的对
    象的 prototype 通过 ~Object.assign(...)~ 方法放入 Mixin 的属性。下面是一个例
    子
    #+BEGIN_SRC js
      let sayHiMixin = {
        sayHi() {
          console.log(`Hello ${this.name}`);
        },
        sayBye() {
          console.log(`Bye ${this.name}`);
        }
      };

      // usage:
      class User {
        constructor(name) {
          this.name = name;
        }
      }

      Object.assign(User.prototype, sayHiMixin);

      new User("Dude").sayHi(); // Hello Dude!
    #+END_SRC
* 浏览器相关
  大部分 JavaScript 的应用是运行于浏览器中的，浏览器包括如下基本对象
  - DOM: Document Object Model
  - BOM: Browser Object Model, =navigator=, =screen=, =location=, =frames=,
    =history=, =XMLHttpRequest=, ...
  - JavaScript: =Object=, =Array=, =Function=, ...

** Document
*** 节点类型及相应对应关系
    DOM 中定义了 [[https://dom.spec.whatwg.org/#node][12 种节点]]，在实践中常用的有以下四种：
    - ~DOCUMENT_NODE~ 文档根节点, =document=
    - ~ELEMENT_NODE~ 元素节点
    - ~ATTRIBUTE_NODE~ 属性节点
    - ~TEXT_NODE~ 文本节点

    节点 DOM 和 HTML 对应关系表格
    | DOM                               | HTML                        |
    |-----------------------------------+-----------------------------|
    | =<html>=                          | ~document.documentElement~  |
    | =<body>=                          | ~document.body~             |
    | =<head>=                          | ~document.head~             |
    | =<tr>=                            | ~table.rows~                |
    |                                   | ~tr.cells~                  |
    |                                   | ~tr.rowIndex~               |
    |                                   | ~tr.sectionRowIndex~        |
    | =<td>=                            | ~td.cellIndex~              |
    | =<caption>=, =<thead>=, =<tfoot>= | ~table.caption/tHead/tFoot~ |
    | =<tbody>=                         | ~table.tBodies~             |

*** 节点工具函数
    DOM 提供了一些可以遍历 html 节点的函数，具体入下
    - 针对于所有类型节点方法: parentNode, childNodes, firstChild, lastChild,
      previousSibling, nextSibling.
    - 仅仅针对元素节点: parentElement, children, firstElementChild,
      lastElementChild, previousElementSibling, nextElementSibling

*** 节点选择器
    =getElementsBy*= 和 =querySelector*= 是选取 DOM 元素的基本方法，它的介绍见下表
    | 方法名                 | 传入参数     | 元素能否调用 | 返回实时结果 |
    |------------------------+--------------+--------------+--------------|
    | getElementById         | id           | -            | -            |
    | getElementsByName      | name         | -            | yes          |
    | getElementsByTagName   | tag or '*'   | yes          | yes          |
    | getElementsByClassName | class        | yes          | yes          |
    | querySelector          | CSS-selector | yes          | -            |
    | querySelectorAll       | CSS-selector | yes          | -            |

*** 节点属性
    节点的类的继承见下图，其中 EventTarget 是节点的抽象基类

    [[file:../static/image/2019/07/dom-node-class.png]]

    - nodeType 属性表明了 DOM 节点的属性，它是一个整数值：
      - =1= 表示元素节点
      - =3= 表示文本节点
      - =9= 表示 document 对象
    - nodeName/tagName
    - innerHTML
    - outerHTML
    - nodeValue/data
    - textContent
    - hidden 如果为 true，和 CSS 的 ~display:none~ 表示同一意思

*** 属性 Attribute 和 Properties
    Attribute 存在于 HTML 中，大小写不敏感，必须是字符串；Properties 存在于 DOM
    对象中，大小写敏感，可以是任何基础的值，一般使用点操作符来引用。例如：
    - ~elem.hasAttribute(name)~ – to check for existence.
    - ~elem.getAttribute(name)~ – to get the value.
    - ~elem.setAttribute(name, value)~ – to set the value.
    - ~elem.removeAttribute(name)~ – to remove the attribute.
    - ~elem.attributes~ is a collection of all attributes.

*** 创建/插入/删除 节点
    - ~document.createElement(tag)~ 通过 tag 创建新的节点
    - ~document.createTextNode(value)~ 创建文本节点
    - ~elem.cloneNode(deep)~ 克隆节点
    - ~parent.appendChild(node)~
    - ~parent.insertBefore(node, nextSibling)~
    - ~parent.removeChild(node)~
    - ~parent.replaceChild(newElem, node)~
    - ~node.append(...nodes or strings)~
    - ~node.prepend(...nodes or strings)~
    - ~node.before(...nodes or strings)~
    - ~node.after(...nodes or strings)~ –
    - ~node.replaceWith(...nodes or strings)~
    - ~node.remove()~
    - ~elem.insertAdjacentHTML(where, html)~
      - where: 可以是这些字符串值 beforebegin, afterbegin, beforeend, afterend

*** 样式和 css 类
    - 在 DOM properties 管理样式有两种方法
      - =elem.className= 字符串，方便管理全部的属性
      - =elem.classList= 对象，方便使用 ~add/remove/toggle~ 方法
    - css 样式的命名到 DOM 中的 properties 的命名有一点点区别例如：
      - =background-color= 对应 =elem.style.backgroundColor=
      - =z-index= 对应 =elem.style.zIndex=
      - =border-left-width=  对应 =elem.style.borderLeftWidth=
      - =-webkit-border-radius= 对应 =button.style.WebkitBorderRadius=
    - ~style.cssText~ 全部样式的字符串
    - 计算后的样式值通过调用 ~getComputedStyle(element[,pseudo])~ 函数获取，例如：
      ~getComputedStyle(document.body)~
      - =element= 读取的元素名
      - =pseudo= 伪元素名称，例如： =::before=

*** 元素/窗口的几何属性和滚动
    DOM 元素位置的几何属性主要有以下：
    - ~offsetParent~
    - ~offsetLeft/offsetTop~
    - ~offsetWidth/offsetHeight~
    - ~clientLeft/clientTop~
    - ~clientWidth/clientHeight~
    - ~scrollWidth/scrollHeight~
    - ~scrollLeft/scrollTop~

    窗口的几何属性如下：
    - ~document.documentElement.clientHeight/Width~
    - 滚动的高度 =scrollHeight=
      #+BEGIN_SRC js
        let scrollHeight = Math.max(
          document.body.scrollHeight, document.documentElement.scrollHeight,
          document.body.offsetHeight, document.documentElement.offsetHeight,
          document.body.clientHeight, document.documentElement.clientHeight
        );
      #+END_SRC
    - 读取当前滚动: ~window.pageYOffset/pageXOffset~
    - 改变当前滚动
      - ~window.scrollTo(pageX, pageY)~
      - ~window.scrollBy(x,y)~
      - ~elem.scrollIntoView(top/bottom)~

** 事件

** 表单和控制
