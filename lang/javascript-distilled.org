#+TITLE: JavaScript 编程语言精粹
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2019-07-02 Tue 11:04:00>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+TAGS: javascript programming language distilled

* 基础知识
** 常量和变量
   定义常量使用 =const= 关键字，变量有 =var= 和 =let= ，其中 =var= 是旧版本的定
   义变量方法，它没有 scope，但是 =let= 是有 scope 的，所以无论如何 *定义变量请
   使用 let 关键字*

   #+BEGIN_SRC js
    > if (true) {
    ... var v1 = true;
    ... }
    > v1
    true
    > if (true) {
    ... let v2 = true;
    ... }
    > v2
    Thrown:
    ReferenceError: v2 is not defined
    >
   #+END_SRC

** null 和 undefined
   =null= 在 JavaScript 中表示空值， =undefined= 通常是为没有赋值的变量。通常变
   量为空的时候要使用 =null= ，尽量避免 =undefined=
   #+BEGIN_SRC js
     > null == undefined
     true
     > null === undefined
     false
     > undefined == undefined
     true
     > typeof undefined
     'undefined'
     > typeof null
     'object'
     > typeof true
     'boolean'
     > typeof 0
     'number'
     >
   #+END_SRC

** 类型
*** 基本类型
    JavaScript 的基本类型包括： ~string~, ~number~, ~boolean~, ~symbol~, ~null~
    和 ~undefined~
    - 普通对象都有相应的方法
    - ~null~ 和 ~undefined~ 没有方法

    JavaScript 的基本类型有以下 =包装类= ，例如： ~String~, ~Number~, ~Boolean~
    和 ~Symbol~

*** 类型转换
    转换成字符串
    #+BEGIN_SRC js
      > String(true)
      'true'
      > String(null)
      'null'
      > String(23)
      '23'
      >String(undefined)
      'undefined'
      > '' + 21
      '21'
      > 2 + 2 + '1'
      '41'
    #+END_SRC
    转换成数值
    #+BEGIN_SRC js
      > "6" / "3"
      2
      > Number("234")
      234
      > Number("str")
      NaN
      > Number(null)
      0
      > Number(undefined)
      NaN
      > Number(true)
      1
      > Number(false)
      0
      > +'12.3'
      12.3
      > parseInt('23')
      23
      > parseFloat('3.14')
      3.14
    #+END_SRC

* 控制流
** if 条件, switch case 多层条件控制
   #+BEGIN_SRC js
     if (year < 2015) {
       alert( 'Too early...' );
     } else if (year > 2015) {
       alert( 'Too late' );
     } else {
       alert( 'Exactly!' );
     }

     let a = 2 + 2;

     switch (a) {
       case 3:
         alert( 'Too small' );
         break;
       case 4:
         alert( 'Exactly!' );
         break;
       case 5:
         alert( 'Too large' );
         break;
       default:
         alert( "I don't know such values" );
     }
   #+END_SRC

** while for 循环
   #+BEGIN_SRC js
     let i = 0;
     while (i < 3) { // shows 0, then 1, then 2
       alert( i );
       i++;
     }

     do {
       alert( i );
       i++;
     } while (i < 3);

     for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
       alert(i);
     }
   #+END_SRC

** try catch 处理异常
   异常一般用到的比较少，这里先记上
   #+BEGIN_SRC js
     try {
       alert( 'try' );
       if (confirm('Make an error?')) BAD_CODE();
     } catch (e) {
       alert( 'catch' );
     } finally {
       alert( 'finally' );
     }
   #+END_SRC

* 函数
** 函数定义
   函数是 JavaScript 的重要工具，定义函数有以下几种方法
   #+BEGIN_SRC js
     function sum(a, b) {
       let result = a + b;
       return result;
     }
     let sum = function(a, b) {
       let result = a + b;
       return result;
     }

     // expression at the right side
     let sum = (a, b) => a + b;
     // or multi-line syntax with { ... }, need return here:
     let sum = (a, b) => {
       // ...
       return a + b;
     }

     // without arguments
     let sayHi = () => alert("Hello");
     // with a single argument
     let double = n => n * 2;
   #+END_SRC

   箭头函数绑定了上下文，所以箭头函数有以下特点：
   - 没有 ~this~
   - 没有 ~arguments~
   - 不能使用 ~new~ 来创建对象
   - 没有 ~super~

** 带默认值的函数
   #+BEGIN_SRC js
     function showMessage(from, text) {
       alert(from + ': ' + text);
     }
     function showMessage2(from, text='hello') {
       alert(from + ': ' + text);
     }
   #+END_SRC

** Rest 参数和 =...= 操作符
*** Rest 参数
    JavaScript 中的三点操作符 =...= 可以定义变长的参数
    #+BEGIN_SRC js
      function sumAll(...args) { // args is the name for the array
        let sum = 0;
        for (let arg of args) sum += arg;
        return sum;
      }

      sumAll(1); // 1
      sumAll(1, 2); // 3
      sumAll(1, 2, 3); // 6
    #+END_SRC

*** ~arguments~ 变量
    JavaScript 的每个函数中都默认传入一个 Array-like 的 ~arguments~ 变量，用于处
    理函数的对象。使用 ~arguments~ 主要是兼容以前 JavaScript 不支持 Rest 参数
    #+BEGIN_SRC js
      function showName() {
        console.log(arguments.length);
        console.log(arguments[0]);
        console.log(arguments[1]);

        // it's iterable
        // for(let arg of arguments) alert(arg);
      }

      // shows: 2, Julius, Caesar
      showName("Julius", "Caesar");
      // shows: 1, Ilya, undefined (no second argument)
      showName("Ilya");
    #+END_SRC

*** =...= 操作符
    =...= 可以将数组中作为变长参数传入函数中
    #+BEGIN_SRC js
      > arr = [1, 2, 5]
      [ 1, 2, 5 ]
      > Math.max(1,2,5)
      5
      > Math.max(arr)
      NaN
      > Math.max(...arr)
      5
    #+END_SRC

    =...= 可以合并数组
    #+BEGIN_SRC js
      > let a = [1, 3, 5];
      > let b = [2, 4, 6];
      > [...a, ...b]
      [ 1, 3, 5, 2, 4, 6 ]
      > Math.max(9, ...a, ...b)
      9
      >
    #+END_SRC

** 函数对象和 NFE
   JavaScript 中函数也是一种对象，所以函数都是 ~Function~ 的实例。NFE 是命名函数
   表达式（Named Function Expression）。

*** 函数对象
    - 函数对象都包含 =name= 属性，表示函数的名称
    - 函数对象包含 =length= 属性，表示函数的参数的长度
    #+BEGIN_SRC js
      > function sayHi() { console.log('hello'); }
      > sayHi.name
      'sayHi'
      > sayHi.length
      0
      >
    #+END_SRC

*** NFE
    NFE 在函数定义赋值前重新添加一个函数名称，具体如下：
    #+BEGIN_SRC js
      let sayHi = function func(who) { // additional func as name
        alert(`Hello, ${who}`);
      };
    #+END_SRC
    这样定义的好处是：
    - func 函数名对函数内部可见
    - func 函数名对函数外部不可见
    #+BEGIN_SRC js
      let sayHi = function func(who) {
        if (who) {
          alert(`Hello, ${who}`);
        } else {
          func("Guest"); // use func to re-call itself
        }
      };

      sayHi(); // Hello, Guest
      // But this won't work:
      func(); // Error, func is not defined (not visible outside of the function)
    #+END_SRC

** 调度 setTimeout/setInterval
   - ~setTimeout~ 设置一定计时后运行
   - ~setInterval~ 设置一定周期运行函数
   - ~clearTimeout/clearInterval~ 取消计时器

*** setTimeout
    #+BEGIN_SRC js
      let timerId = setTimeout(func|code, delay[, arg1, arg2...])
    #+END_SRC
    - ~func~ 回调函数
    - ~delay~ 延迟毫秒数
    - ~arg1, arg2, ...~ 回调函数的参数
    #+BEGIN_SRC js
      function sayHi() {
        console.log('Hello');
      }

      setTimeout(sayHi, 1000);
    #+END_SRC

    ~setTimeout(func,0)~ 是在定义后里面运行函数，这个可以实现异步调用，例如下面
    的例子中会在显示 Hello 过后立马显示 World
    #+BEGIN_SRC js
      setTimeout(() => alert("World"), 0);

      alert("Hello");
    #+END_SRC
    另外使用 ~setTimeout(func,0)~ 可以将高消耗 CPU 的工作放在初始化过后进行

*** clearTimeout
    #+BEGIN_SRC js
      let timerId = setTimeout(...);
      clearTimeout(timerId);
    #+END_SRC

*** setInterval
    #+BEGIN_SRC js
      let timerId = setInterval(func|code, delay[, arg1, arg2...])
    #+END_SRC
    参数和 ~setTimeout~ 类似

    #+BEGIN_SRC js
      // repeat with the interval of 2 seconds
      let timerId = setInterval(() => alert('tick'), 2000);

      // after 5 seconds stop
      setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
    #+END_SRC

** 函数 ~this~ 绑定
   - ~func.bind(context, ...args)~ 绑定 func 的 ~this~ 到 context，详见 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind][bind]]
   - ~func.call(context, ...args)~ 绑定 func 的 ~this~ 到 context, 然后调用函数
     func，将 =...args= 作为参数传入，详见 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call][call]]
   - ~func.apply(context, args)~ 绑定 func 的 ~this~ 到 context, 然后调用函数
     func，将 Array-like 的 =args= 作为参数传入，详见 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply][apply]]

** Currying
   Currying 将 ~f(a,b,c)~ 转化成 ~f(a)(b)(c)~ 这样的调用。一个简单的 curry 实现如
   下：
   #+BEGIN_SRC js
     function curry(func) {

       return function curried(...args) {
         if (args.length >= func.length) {
           return func.apply(this, args);
         } else {
           return function(...args2) {
             return curried.apply(this, args.concat(args2));
           }
         }
       };

     }
   #+END_SRC

   lodash 库提供 [[https://lodash.com/docs/4.17.15#curry][_.curry]] 实现的工具函数
   #+BEGIN_SRC js
     var abc = function(a, b, c) {
       return [a, b, c];
     };

     var curried = _.curry(abc);

     curried(1)(2)(3);
     // => [1, 2, 3]

     curried(1, 2)(3);
     // => [1, 2, 3]

     curried(1, 2, 3);
     // => [1, 2, 3]

     // Curried with placeholders.
     curried(1)(_, 3)(2);
     // => [1, 2, 3]
   #+END_SRC

* 标准内置对象
** Number 数字
*** 转化成数字
    - ~parseInt(str, base)~ 转化成整数
    - ~parseFloat(str)~ 转化成浮点数

*** 数字截断
    主要有： ~Math.floor~ , ~Math.ceil~, ~Math.round~, ~Math.trunc~ 这些方法，例
    子见下表

    |      | Math.floor | Math.ceil | Math.round | Math.trunc |
    |------+------------+-----------+------------+------------|
    |  3.1 |          3 |         4 |          3 |          3 |
    |  3.6 |          3 |         4 |          4 |          3 |
    | -1.1 |         -2 |        -1 |         -1 |         -1 |
    | -1.6 |         -2 |        -1 |         -2 |         -1 |

*** 其它函数
    - ~Math.random()~ 取 0 到 1 之间的随机数
    - ~Math.max(a, b, c, ..)~ 和 ~Math.min(a, b, c, ..)~ 取最值
    - ~Math.pow(n, power)~

*** 特殊数字测试
    - ~isFinite~ 如果不是无穷大，返回真；否则返回假。 ~Infinity~ 和 ~-Infinity~
      表示无穷大和无穷小
    - ~isNaN~ 测试是否是一个数字

    #+BEGIN_SRC js
      > isFinite(NaN)
      false
      > isFinite(-Infinity)
      false
      > isFinite(Infinity)
      false
      > isFinite(12)
      true
      > isNaN(NaN)
      true
      > isNaN(2)
      false
      > isNaN("ss")
      true
      >
    #+END_SRC

** String 字符串
   String 对象在 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String][MDN]] 中有详细的介绍
*** 定义字符串
    注意使用 =${...}= 表达式
    #+BEGIN_SRC js
      > "Double quote"
      'Double quote'
      > 'Single quote'
      'Single quote'
      > let name = 'Jack'
      > `Hi, ${name}`
      'Hi, Jack'
      > `1 + 2 = ${1 + 2}`
      '1 + 2 = 3'
    #+END_SRC

*** 字符串长度
    ~str.length~ ，字符串长度是一个对象中的属性
    #+BEGIN_SRC js
      > 'hello'.length
      5
    #+END_SRC

*** 获取子字符串
    - ~[]~ 和 ~str.charAt(idx)~: 通过下标索引获取字符
    - ~str.slice(beginIndex[,endIndex])~ 获取子字符串，如果 beginIndex 或
      endIndex 是负表示反向索引
    - ~str.substring(indexStart[,indexEnd])~ 和 slice 和类似，但是 substring 支
      持 indexEnd 小于 indexStart
    #+BEGIN_SRC js
      > 'abcd'.substring(1,3)
      'bc'
      > 'abcd'.substring(3,1)
      'bc'
      > 'abcd'.slice(1,3)
      'bc'
      > 'abcd'.slice(3,1)
      ''
      >
    #+END_SRC

*** 字符串查找
    - ~str.indexOf(searchValue,fromIndex)~ : 查找字符串中是否包含 searchValue，
      并返回下标
    - ~str.lastIndexOf(searchValue,fromIndex)~ : 反向查找字符串中是否包含
      searchValue，并返回下标
    - ~str.includes(searchString,[position])~ : 查找字符串，返回布尔值
    - ~str.startsWith(searchString[,position])~ 和
      ~str.endsWith(searchString[,length])~
    #+BEGIN_SRC js
      > 'abaa'.indexOf('a')
      0
      > 'abaa'.indexOf('b')
      1
      > 'abaa'.lastIndexOf('a')
      3
      > 'abaa'.includes('b')
      true
      > 'hello'.startsWith('h')
      true
      > 'hello'.startsWith('a')
      false
      > 'hello'.endsWith('a')
      false
      >
    #+END_SRC

*** 字符串替换/正则表达式
    - ~str.replace(regexp|substr,newSubstr|function)~
    - ~str.match(regexp)~ : 匹配 regexp 返回数组，如果 regexp 是 null 则返回空
    - ~str.search(regexp)~
    #+BEGIN_SRC js
      > 'abaa'.replace('a', '$')
      '$baa'
      > 'abaa'.replace(/a/g, '$')
      '$b$$'
      >
    #+END_SRC

    #+BEGIN_SRC js
      > 'abaa'.match(/a/g)
      [ 'a', 'a', 'a' ]
      > 'abaa'.match(/a/)
      [ 'a', index: 0, input: 'abaa', groups: undefined ]
      > 'abaa'.match(/^a/)
      [ 'a', index: 0, input: 'abaa', groups: undefined ]
      > 'For more information, see Chapter 3.4.5.1'.match(/see (chapter \d+(\.\d)*)/i)
      [ 'see Chapter 3.4.5.1',
        'Chapter 3.4.5.1',
        '.1',
        index: 22,
        input: 'For more information, see Chapter 3.4.5.1',
        groups: undefined ]
      > 'abaa'.match(null)
      null
    #+END_SRC

*** 其它字符串函数
    - ~str.padStart()~, ~str.padEnd()~
    - ~str.repeat()~
    - ~str.trim()~, ~str.trimStart()~, ~str.trimEnd()~
    - ~str.toUpperCase()~, ~str.toLowerCase()~
    - ~str.split()~
    #+BEGIN_SRC js
      > 'abaa'.split()
      [ 'abaa' ]
      > 'abaa'.split('')
      [ 'a', 'b', 'a', 'a' ]
    #+END_SRC

** Array 数组
   数组是具有固定长度 (~arr.length~) 的同一类元素的集合，具体参考 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array][MDN]] 中的定义。

*** 创建
    #+BEGIN_SRC js
      > let fruits = ['Apple', 'Banana', 'Orange']
      undefined
      > fruits.length
      3
    #+END_SRC

*** 修改元素：添加/删除
    - ~push(...items)~ : 添加元素到数组结尾
    - ~pop()~ : 移除结尾的元素
    - ~shift()~ : 删除起始的元素
    - ~unshift(...items)~ : 添加元素到数组起始
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      > fruits.push('Grape')
      4
      > fruits
      [ 'Apple', 'Banana', 'Orange', 'Grape' ]
      > fruits.pop()
      'Grape'
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      > fruits.shift()
      'Apple'
      > fruits
      [ 'Banana', 'Orange' ]
      > fruits.unshift('Apple')
      3
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      >
    #+END_SRC

    - ~splice(pos, deleteCount, ...items)~ : 在 ~pos~ 位置删除 ~deleteCount~ 个元
      素然后插入 ~items~
    - ~slice(start, end)~ : 创建一个新的数组, 复制 ~start~ 到 ~end~ (不包含) 到新
      的数组中
    - ~concat(...items)~ : 返回一个新的数组: 拷贝当前数组的所有元素然后添加
      ~items~ 到新的数组中. 如果任何 ~items~ 是一个数组, 数组里面的元素都会添加的
      新的数组中
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Banana', 'Orange' ]
      > let new_fruits = fruits.slice(0, 2)
      > new_fruits
      [ 'Apple', 'Banana' ]
      > fruits.splice(1, 1)
      [ 'Banana' ]
      > fruits
      [ 'Apple', 'Orange' ]
      > fruits
      [ 'Apple', 'Orange' ]
      > fruits.splice(1, 0, 'Pear')
      []
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.concat('Banana')
      [ 'Apple', 'Pear', 'Orange', 'Banana' ]
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      >
    #+END_SRC

*** 查找
    - ~indexOf/lastIndexOf(item, pos)~ : 查找 ~item~ , 起始位置是~pos~ , 如果没有
      找到则返回 ~-1~
    - ~includes(value)~ : 返回 ~true~ 如果数组包含 ~value~ , 否则 ~false~
    - ~find/filter(func)~ : 使用谓词函数过滤数组, 返回第一个/所有的使得谓词函数成
      立的元素
    - ~findIndex(func)~ : 和 ~find~ 相似, 但是返回下标索引而不是数组元素
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.indexOf('Pear')
      1
      > fruits.indexOf('Banana')
      -1
      > fruits.find(function (e) { return e.length >= 5;})
      'Apple'
      > fruits.filter(function (e) { return e.length >= 5;})
      [ 'Apple', 'Orange' ]
      > fruits.includes('Banana')
      false
      > fruits.includes('Pear')
      true
      > 'Banana' in fruits
      false
      > 'Pear' in fruits
      false
    #+END_SRC

*** 迭代
    - ~forEach(func)~ : 调用 ~func~ 处理所有的数组里的元素, 但是不返回
    #+BEGIN_SRC js
      ['Apple', 'Banana', 'Orange'].forEach(function(e, i, arr) {
        console.log(i + " : " + e)
      })
    #+END_SRC

*** 数组变换
    - ~map(func)~ : 调用 ~func~ 处理所有数组里的元素，返回处理结果集构成的新数组
    - ~sort(func)~ : 使用 ~func~ 排序数组，然后返回
    - ~reverse()~ : 返回逆序的数组
    - ~split/join~ : 在字符串和数组之间转换
    - ~reduce(func, initial)~ : 计算得出一个值， 通过调用 ~func~ 函数处理起始值和
      中间值
    #+BEGIN_SRC js
      > fruits
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.map(function(e) { return e.toUpperCase();})
      [ 'APPLE', 'PEAR', 'ORANGE' ]
      > fruits.reduce(function(a, e) { return a+':'+e;}, '')
      ':Apple:Pear:Orange'
      > fruits.join(':')
      'Apple:Pear:Orange'
      > 'Apple:Pear:Orange'.split(':')
      [ 'Apple', 'Pear', 'Orange' ]
      > fruits.sort()
      [ 'Apple', 'Orange', 'Pear' ]
      > fruits
      [ 'Apple', 'Orange', 'Pear' ]
      > fruits.sort(function(a,b) {return a.length>b.length?1:-1;})
      [ 'Pear', 'Apple', 'Orange' ]
      > fruits.reverse()
      [ 'Orange', 'Apple', 'Pear' ]
      >
    #+END_SRC

*** 其它
    - ~Array.isArray(arr)~ : 检查 ~arr~ 是否是数组对象
    - ~arr.some(fn)~ / ~arr.every(fn)~ : 调用 ~fn~ 作用于数组所有元素，如果任何/
      所有的都返回 ~true~, 则返回 ~true~, 否则返回 ~false~
    - ~arr.fill(value, start, end)~ : 使用 ~value~ 填充数组 ~start~ 到 ~end~ 位置
      的元素
    - ~arr.copyWithin(target, start, end)~ : 复制数组 ~start~ 到 ~end~ 位置中的元
      素到自身 ~target~ 位置中, 注意会覆盖已存在的元素

** 迭代器/数组类似物
*** Array-like 和 Iterable
    - =Iterable= 是实现了 =Symbol.iterator= 方法的对象
      + =Symbol.iterator= 必须包含 =next()= 方法
      + =next()= 方法必须返回像 ~{done: Boolean, value: any}~ 这样的对象，done 为
        ~true~ 表示迭代器结束
      + =Iterable= 主要是使用 =for..of= 迭代器进行迭代
    - =Array-like= 是含义 =length= 属性和可索引的对象

    #+BEGIN_SRC js
      let arrayLike = { // has indexes and length => array-like
        0: "Hello",
        1: "World",
        length: 2
      };

      let iterable = {
        from: 1,
        to: 5,
        // 1. call to for..of initially calls this
        [Symbol.iterator]() {
          this.current = this.from;
          // 2. ...it returns the iterator:
          return this;
        },
        // 3. next() is called on each iteration by the for..of loop
        next() {
          // 4. it should return the value as an object {done:.., value :...}
          if (this.current <= this.to) {
            return { done: false, value: this.current++ };
          } else {
            return { done: true };
          }
        }
        }
      }

      for (let num of iterable) { console.log(num); } // => prints 1, 2, 3, 4, 5
    #+END_SRC

*** ~Array.from~
    ~Array.from(arrayLike[,mapFn[,thisArg]])~ 通过 Array-like 的对象来新建一个真
    的 Array，例如字符串 ~'foo'~ 是 Array-like 对象，因此可以建立一个新的数组
    #+BEGIN_SRC js
      > Array.from('foo');
      [ 'f', 'o', 'o' ]
    #+END_SRC

** Map/Set 等标准内置对象
   [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map][Map]] , WeakMap, [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set][Set]], WeakSet 等都是常用的 Javascript 对象，具体参考 MDN 中的定
   义 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects][ Standard built-in objects]]

   Map 对象操作
   #+BEGIN_SRC js
     let map = new Map();

     map.set('1', 'str1');   // a string key
     map.set(1, 'num1');     // a numeric key
     map.set(true, 'bool1'); // a boolean key

     // remember the regular Object? it would convert keys to string
     // Map keeps the type, so these two are different:
     alert( map.get(1)   ); // 'num1'
     alert( map.get('1') ); // 'str1'

     alert( map.size ); // 3

     let recipeMap = new Map([
       ['cucumber', 500],
       ['tomatoes', 350],
       ['onion',    50]
     ]);

     // iterate over keys (vegetables)
     for (let vegetable of recipeMap.keys()) {
       alert(vegetable); // cucumber, tomatoes, onion
     }

     // iterate over values (amounts)
     for (let amount of recipeMap.values()) {
       alert(amount); // 500, 350, 50
     }

     // iterate over [key, value] entries
     for (let entry of recipeMap) { // the same as of recipeMap.entries()
       alert(entry); // cucumber,500 (and so on)
     }
   #+END_SRC

   Set 集合函数
   #+BEGIN_SRC js
     let set = new Set();

     let john = { name: "John" };
     let pete = { name: "Pete" };
     let mary = { name: "Mary" };

     // visits, some users come multiple times
     set.add(john);
     set.add(pete);
     set.add(mary);
     set.add(john);
     set.add(mary);

     // set keeps only unique values
     alert( set.size ); // 3

     for (let user of set) {
       alert(user.name); // John (then Pete and Mary)
     }

     let set = new Set(["oranges", "apples", "bananas"]);

     for (let value of set) alert(value);

     // the same with forEach:
     set.forEach((value, valueAgain, set) => {
       alert(value);
     });
   #+END_SRC

** Object 对象
   [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object][Object]] 是 JavaScript 中的对象

*** 定义对象
    #+BEGIN_SRC js
      > let user1 = new Object()
      > user1
      {}
      > let user2 = {}
      > user2
      {}
      > let user3 = {name: 'Tom', age: 22}
      > user3
      { name: 'Tom', age: 22 }
      > user3.name
      'Tom'
      > user3['name']
      'Tom'
      >
    #+END_SRC

*** 对象基本操作
    - 引用对象中的值
      + 点方式： ~obj.key~
      + 方括号方式： ~obj['key']~
    - 删除对象中的值 ~delete obj.key~
    - 判断对象中是否存在键 ~'key' in obj~
    #+BEGIN_SRC js
      let usr = {name: 'Tom', age: 22}
      > 'name' in usr
      true
      > 'birthday' in usr
      false
      >
    #+END_SRC

*** 对象引用/复制
    ~=~ 赋值是引用
    #+BEGIN_SRC js
      > obj1 = {a:'Apple', b:1}
      { a: 'Apple', b: 1 }
      > obj2 = obj1
      { a: 'Apple', b: 1 }
      > obj2.b = 7
      7
      > obj1
      { a: 'Apple', b: 7 }
      >
    #+END_SRC

    ~Object.assign(...)~ 可以实现复制传值，或者使用 lodash 库中的
    [[https://lodash.com/docs#cloneDeep][_.cloneDeep(obj)]]
    #+BEGIN_SRC js
      > obj3 = Object.assign({}, obj1)
      { a: 'Apple', b: 7 }
      > obj3.b = 9
      9
      > obj1
      { a: 'Apple', b: 7 }
      >
    #+END_SRC

    下面是更多的传值的示例
    #+BEGIN_SRC js
      > usr
      { name: 'Tom', age: 22, foo: undefined }
      > usr1 = usr
      { name: 'Tom', age: 22, foo: undefined }
      > usr1 == usr
      true
      > usr1 === usr
      true
      > let _usr = {}
      > for (k in usr) { _usr[k] = usr[k]; }
      > _usr
      { name: 'Tom', age: 22, foo: undefined }
      > _usr == usr
      false
      > _usr === usr
      false
      > usr
      { name: 'Jackson', age: 22, foo: undefined }
      > delete usr.foo
      true
      > usr
      { name: 'Jackson', age: 22 }
      > 'foo' in usr
      false
      >
    #+END_SRC

*** 更新对象
    ~Object.assign(dest[, src1, src2, src3...])~ 可以批量更新对象中的数值。
    #+BEGIN_SRC js
      > usr
      { name: 'Tom', age: 22, foo: undefined }
      > Object.assign(usr, {name: 'Jackson'})
      { name: 'Jackson', age: 22, foo: undefined }
      >
    #+END_SRC

*** 对象的键和值
    - ~Object.keys(obj)~ 返回 obj 的键
    - ~Object.values(obj)~ 返回 obj 的值
    - ~Object.entries(obj)~ 返回 obj 的 [key, value] 对

    #+BEGIN_SRC js
      > let o1 = {apple:1, banana:2, orange:3}
      > o1
      { apple: 1, banana: 2, orange: 3 }
      > Object.keys(o1)
      [ 'apple', 'banana', 'orange' ]
      > o1.keys()
      TypeError: o1.keys is not a function
      > Object.values(o1)
      [ 1, 2, 3 ]
      > Object.entries(o1)
      [ [ 'apple', 1 ], [ 'banana', 2 ], [ 'orange', 3 ] ]
      >
    #+END_SRC

** Date 时间和日期
   [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date][Date]] 是表示时间和日期的内置对象

*** 创建日期对象
    ~new Date()~, ~new Date(milliseconds)~ 和 ~new Date(date_str)~ 可以创建日期
    对象
    #+BEGIN_SRC js
      > new Date()
      2019-07-30T06:58:04.792Z
      > new Date(123124123)
      1970-01-02T10:12:04.123Z
      > new Date("2017-01-26")
      2017-01-26T00:00:00.000Z
    #+END_SRC

*** 时间函数
    具体见下面的样例
    #+BEGIN_SRC js
      > let now = new Date()
      > now.getFullYear()
      2019
      > now.getYear()
      119
      > now.getMonth()
      6
      > now.getDate()
      30
      > now.getHours()
      15
      > now.getMinutes()
      5
      > now.getSeconds()
      21
      > now.getMilliseconds()
      725
      > now.getDay()
      2
      >
    #+END_SRC

*** 时间戳
    时间戳有以下函数
    #+BEGIN_SRC js
      // get timestamp
      > now
      2019-07-30T07:05:21.725Z
      > now.getTime()
      1564470321725
      > +now
      1564470321725
      > Date.now()
      1564470538021

      // time diff
      > new Date() - now
      260547
    #+END_SRC

*** 字符串和 Date 互转
    ~Date.parse(str)~, str 应满足 =YYYY-MM-DDTHH:mm:ss.sssZ= 格式
    #+BEGIN_SRC js
      > Date.parse('2012-01-26T13:51:50.417-07:00');
      1327611110417
    #+END_SRC

    Date 转字符串有以下方法
    #+BEGIN_SRC js
      > now.toJSON()
      '2019-07-30T07:05:21.725Z'
      > now.toDateString()
      'Tue Jul 30 2019'
      > now.toISOString()
      '2019-07-30T07:05:21.725Z'
      > now.toString()
      'Tue Jul 30 2019 15:05:21 GMT+0800 (GMT+08:00)'
      > now.toTimeString()
      '15:05:21 GMT+0800 (GMT+08:00)'
      > now.toUTCString()
      'Tue, 30 Jul 2019 07:05:21 GMT'
      >
    #+END_SRC

** JSON
   - ~JSON.stringify(obj)~ 将数组或对象转成 JSON 字符串
   - ~JSON.parse(str)~ 解析 JSON 字符串
   #+BEGIN_SRC js
     > let student = {
     ...   name: 'John',
     ...   age: 30,
     ...   isAdmin: false,
     ...   courses: ['html', 'css', 'js'],
     ...   wife: null
     ... };
     undefined
     > JSON.stringify(student)
     '{"name":"John","age":30,"isAdmin":false,"courses":["html","css","js"],"wife":null}'
     > JSON.stringify([1,2,3])
     '[1,2,3]'
     > JSON.parse('[1,2,3,2,3]')
     [ 1, 2, 3, 2, 3 ]
     >
   #+END_SRC

* 面向对象知识
** ~new~ 关键字和构造器
*** 构造器
    JavaScript 中没有所谓的构造器，它的构造器实际上是一个函数，该函数满足以下两
    点：
    1. 函数名称使用 Pascal case 命名
    2. 函数只能使用 ~new~ 操作符来执行

    例如：
    #+BEGIN_SRC js
      function User(name) {
        this.name = name;
        this.isAdmin = false;
      }

      let user = new User("Jack");

      alert(user.name); // Jack
      alert(user.isAdmin); // false
    #+END_SRC

*** ~new~ 操作符
    ~new~ 操作符做了以下的事情:
    1. 新建了函数作用域的 ~this~ 对象
    2. 并且将新创建的 ~this~ 对象返回
    该过程大致如下面代码所示：
    #+BEGIN_SRC js
      function User(name) {
        // this = {};  (implicitly)

        // add properties to this
        this.name = name;
        this.isAdmin = false;

        // return this;  (implicitly)
      }
    #+END_SRC
