#+TITLE: Oracle 关系数据库
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2019-07-08 Mon 11:04:00>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: oracle database 10g

* Oracle 数据库
  Oracle Database，又名 Oracle RDBMS，或简称 Oracle。是甲骨文公司的一款关系数据
  库管理系统。它是在数据库领域一直处于领先地位的产品。可以说 Oracle 数据库系统是
  目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各
  类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库解决方
  案。

** Oracle 数据库架构
*** Database 和 Instance
    - Database 指的是存放于磁盘中的一系列文件，Database 是独立于 Database Instance
    - Database Instance 指定是用于管理 Database 文件的一系列内存数据结构。Instance
      包含：
      - SGA (system global area) 全局共享内存
      - background processes

    下图展示了 Oracle 的数据库和 client process 交互的细节，每个 client 都有自己
    私有的会话内存，通常称之为 PGA (program global area)

    [[file:../static/image/2019/09/oracle-instance-and-database.png]]

*** 数据存储结构
    数据存可以分成物理存储好逻辑存储两个部分，两者的联系见下图

    [[file:../static/image/2019/09/oracle-segments-tablespaces-datafiles.png]]

**** 物理存储结构
     当执行 ~CREATE DATABASE~ 时，下面的文件将被创建
     - Data files 包含所有的数据库的数据，数据的逻辑结构例如表、索引都是存储在 Data files
     - Control files 包含物理结构的一些元信息，例如：数据库名称和数据库文件的路径
     - Online redo log files 包含 redo 的日志文件，每个 redo log 由一系列的 redo
       entires (也被称为 redo records)组成
     - 还一些其他的物理文件 例如：parameter files, diagnostic files, backup
       files, archived redo log files 等

**** 逻辑存储结构
     逻辑结构是存储在一系列 data blocks 中
     - Data blocks 由定长字节的文件组成的二进制文件
     - Extents 由定长的逻辑连续 Data blocks 构成。Extends 一次性分配，用来存储特
       定类型的信息
     - Segments 由一系列的 Extents 构成，可以对应一些用户的对象，例如：表、索引、
       undo data 和 temporary data
     - Tablespace 一个 Database 被分成多个逻辑的 Tablespace 单元。Tablespace 是
       Segments 的逻辑容器。 *每个 Tablespace 至少有一个 Data file 构成*

*** 数据库实例结构
    数据库实例是使用内存数据结构和进程来管理数据库，当应用需要连接数据库时，它将
    会首先连接到一个数据库实例中

**** Oracle 数据进程
     Oracle 数据库在启动时会启动一系列的数据库实例
     - client processes 用来运行软件或 Oracle 工具，大部分运行环境是在不同电脑上
     - background processes 用来处理多个 Oracle 数据库程序，可以进行异步 I/O 或
       者监控其它 Oracle 数据库。
     - server processes 和 client processes 与 Oracle 数据库交互，用来完成处理请
       求
     Oracle processes 包括 server processes 和 background processes。大多数情况
     下， Oracle processes 和 client processes 运行在不同电脑中。

**** 实例内存结构
     - SGA 是包含一个数据库实例的数据和控制信息的一组共享内存的。例如：SGA 包含
       cached data blocks 和 shared SQL area
     - PGA 是包含一个 background processes 和 server processes 实例的数据和控制
       信息的一组内存区域

** 数据库基本知识
*** SQL 语句的分类
    - DML 语句（数据库操作语言）： INSERT/UPDATE/DETETE/MERGE
    - DDL 语句（数据库定义语言）： CREATE/ALTER/DROP/TRUNCATE
    - DCL 语句（数据库控制语言）： GRANT/REVOKE
    - 事务控制语句： COMMIT/ROLLBACK/SAVEPOINT

*** Oracle 基本常识
    - Oracle 数据库中语句不区分大小写，包括登录名的用户名和密码都是不区分大小写的
    - 一般关键字要求大小
    - Oracle 的 SELECT 语句必须要加 FROM 语句，如果没有的话使用 dual 伪表

** Ubuntu 18.04 安装数据库
   安装依赖包
   #+BEGIN_SRC sh
     sudo apt-get install -y libaio1 libaio-dev net-tools
   #+END_SRC

   安装软件包
   #+BEGIN_SRC sh
     dpkg --install /assets/oracle-xe_11.2.0-1.0_amd64.deb
   #+END_SRC

** 参考材料
   Oracle 家的配套文档还是很好用的，数据库方面主要有下面的文档：
   1. [[https://docs.oracle.com/cd/E11882_01/server.112/e10897.pdf][2 Day DBA]] - 《两天数据库管理员》
   2. [[https://docs.oracle.com/cd/E11882_01/server.112/e40540.pdf][Oracle Database Concepts]] - 《Oracle 数据库概念》
   3. Oracle Database SQL Reference - 《Oracle 数据库 SQL 参考手册》
   4. [[http://download.oracle.com/docs/cds/E11882_01.zip][E11882_01 离线下载]]

   [[file:../static/image/2019/07/oracle-database-documentation.png]]

* SQL*Plus 命令行工具
  Oracle 的 SQL*Plus 是与 oracle 数据库进行交互的客户端工具，借助 SQL*Plus 可以
  查看、修改数据库记录。在 SQL*Plus 中，可以运行 SQL*Plus 命令与 SQL 语句。

** 安装 instantclient
   在 mac 和 linux 系统中如果只是想要安装一个 sqlplus 的客户端，可以直接安装
   instantclient 工具

*** macOS
    mac 下的 Oracle 安装需要下载几个 [[https://www.oracle.com/database/technologies/instant-client/downloads.html][instantclient]] 安装包
    1. instantclient-basic-macos.x64-11.2.0.4.0.zip
    2. instantclient-sdk-macos.x64-11.2.0.4.0.zip
    3. instantclient-sqlplus-macos.x64-11.2.0.4.0.zip

    解压安装包
    #+BEGIN_SRC sh
      unzip instantclient-basic-macos.x64-11.2.0.4.0.zip
      unzip instantclient-sdk-macos.x64-11.2.0.4.0.zip
      unzip instantclient-sqlplus-macos.x64-11.2.0.4.0.zip
    #+END_SRC

    解压后生成一个 =instantclient_11_2= 文件夹，直接拷贝到安装的文件夹中
    #+BEGIN_SRC sh
      sudo mkdir -p /usr/local/java
      sudo cp -r instantclient_11_2 /usr/local/java
    #+END_SRC

    建立软连接
    #+BEGIN_SRC sh
      cd /usr/local/java/instantclient_11_2
      mkdir lib

      ln -s libclntsh.dylib.11.1 libclntsh.dylib
      ln -s libocci.dylib.11.1 libocci.dylib

      ln -s $PWD/{libclntsh.dylib.11.1,libnnz11.dylib,libociei.dylib} lib/
      ln -s $PWD/{libsqlplus.dylib,libsqlplusic.dylib} lib/
    #+END_SRC

    添加环境变量到 .bashrc 中
    #+BEGIN_SRC sh
      export PATH="/usr/local/java/instantclient_11_2:$PATH"
      export DYLD_LIBRARY_PATH="/usr/local/java/instantclient_11_2/lib${DYLD_LIBRARY_PATH:+:${DYLD_LIBRARY_PATH}}"
    #+END_SRC

*** Linux
    需要下载的安装文件
    1. instantclient-basic-linux.x64-11.2.0.4.0.zip
    2. instantclient-sdk-linux.x64-11.2.0.4.0.zip
    3. instantclient-sqlplus-linux.x64-11.2.0.4.0.zip

    解压安装包
    #+BEGIN_SRC sh
      unzip instantclient-basic-linux.x64-11.2.0.4.0.zip
      unzip instantclient-sdk-linux.x64-11.2.0.4.0.zip
      unzip instantclient-sqlplus-linux.x64-11.2.0.4.0.zip
    #+END_SRC

    构建目录结构
    #+BEGIN_SRC sh
      [ ! -d /usr/local/java ] && mkdir -p /usr/local/java
      sudo mv instantclient_11_2 /usr/local/java
      cd /usr/local/java/instantclient_11_2
      sudo mkdir lib
    #+END_SRC

    建立软连接
    #+BEGIN_SRC sh
      ln -s libclntsh.so.11.1 libclntsh.so
      ln -s libocci.so.11.1 libocci.so

      ln -s $PWD/libclntsh.so.11.1 lib/
      ln -s $PWD/libnnz11.so lib/
      ln -s $PWD/libocci.so.11.1 lib/
      ln -s $PWD/libociei.so lib/
      ln -s $PWD/libocijdbc11.so lib/
      ln -s $PWD/libsqlplusic.so lib/
      ln -s $PWD/libsqlplus.so lib/
    #+END_SRC

    添加环境变量
    #+BEGIN_SRC sh
      export LD_LIBRARY_PATH=/usr/local/java/instantclient_11_2/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
      export PATH=/usr/local/java/instantclient_11_2${PATH:+:${PATH}}
    #+END_SRC

** 从命令行中连接 SQL*Plus
   第一种登录方式的命令如下

   #+BEGIN_SRC sh
     sqlplus username/password@hostname:port/service_id
   #+END_SRC

   登录过后可以看到成功的登录界面

   [[file:../static/image/2018/11/sqlplus-login.png]]

   第二种登录方式需要使用 tnsnames.ora 这种格式，下面是 Oracle Client 提供的默认
   样本

   #+BEGIN_SRC text
     # This is a sample tnsnames.ora that contains the NET8 parameters that are
     # needed to connect to an HS Agent

     hsagent  =
       (DESCRIPTION=
         (ADDRESS=(PROTOCOL=tcp)(HOST=localhost)(PORT=1521))
         (CONNECT_DATA=(SID=hsagent))
         (HS=)
       )
   #+END_SRC

   熟悉了 tnsnames.org 这种格式后就可以编写相应的登录命令，具体方式如下：
   #+BEGIN_SRC sh
     sqlplus username/password@"(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=hostname)(PORT=1521)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=service_id)))"
   #+END_SRC

   当命令中的密码字段中含义有 @ 字段时需要将 password 字段用双引号包起来，如下：
   #+BEGIN_SRC sh
     sqlplus user/\"my@password\"@hostname:port/service_id
   #+END_SRC

** SQL*Plus 启动配置
   SQL*Plus 启动配置文件为 ~$ORACLE_HOME/sqlplus/admin/glogin.sql~ 。在启动
   SQL*Plus 时需要预先设置一些启动的基本配置，例如启动的每行显示的字符数量，显示
   是否折行，分页大小配置等。下面是我常用的配置。

   #+BEGIN_SRC sql
     -- $ORACLE_HOME/sqlplus/admin/glogin.sql
     -- SET UNDERLINE OFF
     SET TAB OFF
     SET VERIFY OFF
     SET WRAP OFF
     SET LINESIZE 32767
     SET PAGESIZE 0
     SET TRIMOUT ON
     SET TRIMSPOOL ON
     SET FEEDBACK ON

     -- 改变当前会话的日期格式
     ALTER SESSION SET nls_date_format = 'yyyy-mm-dd hh24:mi:ss';
   #+END_SRC

** SQL*Plus 使用技巧
*** 添加 readline 的支持
    sqlplus 本身不支持 readline 的特性，不过可以通过安装 rlwrap 来将 readline 特性添
    加到 sqlplus 中
    #+BEGIN_SRC sh
      # mac
      brew install rlwrap

      # ubuntu
      sudo apt-get install -y rlwrap
    #+END_SRC

    通过 rlwrap 来启动 sqlplus
    #+BEGIN_SRC sh
      rlwrap -c sqlplus user/pass@host/sid
    #+END_SRC

*** 常见命令
    - 执行本地 SQL 脚本: ~START filename~ 或者 ~@ filename~
    - 在 SQL*Plus 里面执行 shell 命令: ~HOST cmd~
    - 将 SQL*Plus 执行的命令存成本地文件: ~SAVE filename~
    - 装载本地 SQL 脚本，但不立即执行: ~GET filename~
    - 执行最后一条 SQL 语句: ~/~
    - 打印最后执行的 SQL 语句: ~L~
    - 结果输出到文件: ~SPOOL filename~
    - 查看/修改 SQL*Plus 的环境变量: ~SHOW/SET variablename~

*** 执行 sql 脚本的方法
    #+BEGIN_SRC sh
      # 执行 script.sql 脚本后退出,
      echo 'exit' | sqlplus -S user/pass@host:port/sid @script.sql

      # 使用重定向执行 script.sql 脚本
      sqlplus -S user/pass@host:port/sid < script.sql

      # 使用重定向执行脚本并追加方式输出日志
      sqlplus -S user/pass@host:port/sid < script.sql >> /tmp/sqlplus.log

      # .sql 文件后缀名不是必须的，例如下面的两句是同样效果的
      echo 'exit' | sqlplus -S user/pass@host:port/sid @script.sql
      echo 'exit' | sqlplus -S user/pass@host:port/sid @script
    #+END_SRC

*** 打开/关闭终端输出
    #+BEGIN_SRC sql
      SET TERMOUT OFF;
      -- do a lot of parepare work
      SET TERMOUT ON;
    #+END_SRC

** SQL*Plus 变量使用技巧
*** 定义和使用变量
    定义的变量只在一个 SQL*Plus 的会话期间有效
    #+BEGIN_SRC sql
      -- 定义一个变量
      DEFINE var = text;

      -- 读取用户输入，将用户输入放到变量中
      ACCEPT var;

      -- 在变量名前面添加 & 来使用变量
      DEFINE MYDATE = 01-FEB-98;
      SELECT '&MYDATE' FROM DUAL;
    #+END_SRC

    下面使用一个使用例子
    #+BEGIN_SRC text
      SQL> DEFINE MYDATE = 01-FEB-98;
      SQL> SELECT '&MYDATE' FROM DUAL;
      原值    1: SELECT '&MYDATE' FROM DUAL
      新值    1: SELECT '01-FEB-98' FROM DUAL

      '01-FEB-98'
      ---------------------------
      01-FEB-98

      SQL>
    #+END_SRC

*** 将列值赋给变量
    具体语法如下：
    #+BEGIN_SRC sql
      COLUMN colname NEW_VALUE var
    #+END_SRC

    使用示例
    #+BEGIN_SRC text
      SQL> COLUMN len1 NEW_VALUE l1
      SQL> SELECT MAX(LENGTH(tc.TABLE_NAME)) as len1 FROM USER_TAB_COMMENTS tc;

            LEN1
      ----------
              29
      SQL> SELECT &l1 FROM DUAL;
      old   1: select &l1 from dual
      new   1: select         29 from dual

              29
      ----------
              29
      SQL>
    #+END_SRC

** 给 script.sql 中传入参数
   在调用脚本时直接将参数写到后面，见下面的例子
   #+BEGIN_SRC sh
     echo 'exit' | sqlplus -S user/pass@host:port/sid @script.sql arg1 arg2
   #+END_SRC

   然后在脚本中使用 ~&1~ 引用第一个参数， ~&2~ 引用第二个参数，以此类推
   #+BEGIN_SRC sql
     -- script.sql
     DEFINE arg1 = &1
     SELECT '&arg1' FROM DUAL;
   #+END_SRC

* 数据库
** 查看当前数据库
   #+BEGIN_SRC sql
     SELECT NAME FROM V$DATABASE;
   #+END_SRC

* 表
** 查看所有表
   #+BEGIN_SRC sql
     -- 查看所有表
     SELECT TABLE_NAME FROM USER_TABLES ORDER BY TABLE_NAME;

     -- 查看所有表和视图，以及注释
     SELECT tc.TABLE_NAME || ' ' || tc.COMMENTS
       FROM USER_TAB_COMMENTS tc
      WHERE tc.TABLE_TYPE in ('TABLE', 'VIEW')
      ORDER BY tc.TABLE_NAME;
   #+END_SRC

** 创建表
   #+BEGIN_SRC sql
     CREATE TABLE [scmname.]tabname (
       colname dbtype [NOT NULL | NULL] [DEFAULT DEFAULT_VALUE] [PRIMARY KEY]
     );
   #+END_SRC
   - Oracle 数据库中 =scmname=, =tabname=, 和 =colname= 不加引号默认大写，即使使
     用小写的名称也会自动转成大写。如果非要使用小写需要使用单引号将名称包起来
   - Oracle 一张表最多只能有 254 列
   - dbtype 是数据类型，常见的有 number, varchar2, date，布尔型一般使用
     ~char(1)~ 或 ~number(1)~ 来模拟

   #+BEGIN_SRC sql
     CREATE TABLE users (
       id number(16) PRIMARY KEY NOT NULL,
       created_by varchar2(64) DEFAULT 'SYSMAN' NOT NULL,
       updated_at date DEFAULT SYSDATE NOT NULL,
       valid char(1) DEFAULT 'y' NOT NULL,
       -- code rule and type
       code varchar2(32) UNIQUE NOT NULL,
       name varchar2(32)
     );

     COMMENT ON COLUMN users.code IS '用户编号, 用于登录';
     COMMENT ON COLUMN users.name IS '用户名字, 用于显示';
   #+END_SRC

*** 数据类型
**** 数值型
     - ~number(precision[,scale])~ : 数值型，用于表示整数和实数。 precision 表示
       精度，scale 表示数值范围。precision 的取值范围为 1 到 38，scale 的取值范
       围为 -84 到 127

**** 字符串
     - ~varchar2(size[BYTE|CHAR])~ : 变长字符串类型，size 表示字符串最大长度，单
       位可以是 BYTE 或 CHAR。 size 的取值范围为 1 到 4000。单位 BYTE 表示所用的
       字节数，单位 CHAR 表示所用的字符（character）数
     - ~nvarchar2(size)~ : 边长 Unicode 编码字符串类型， =AL16UTF16= 字符编码的
       byte 数是 =UTF8= 字符编码的三倍，所以 nvarchar2 的 size 取决于具体的编码集。
       size 的取值范围为 1 到 4000
     - ~char(size[BYTE|CHAR])~ : 定长字符串类型，size 的取值范围是 1 到 2000 。
       单位 BYTE 和单位 CHAR 语义一样都是表示字符（character）数
     - ~long~ : 2GB 的超长字符串。 _每张表只允许一列是 long 类型_

**** 时间/日期类型
     - ~date~ : 时间和日期类型。 Oracle 的时间和日期都用 date 类型表示， 默认的
       时间格式字符由 ~NLS_DATE_FORMAT~ 参数决定，它是 =DD-MMM-YY= 格式，例如：
       '13-OCT-92', '07-JAN-98' 。

**** 二进制 Lob
     - ~clob~ : 最多可以存储 4GB 的数据字符的大对象（character data of large
       object）
     - ~blob~ : 最多可以存储 4GB 数据的二进制大对象（binary large object）

** 修改表
   #+BEGIN_SRC sql
     -- 添加一列
     ALTER TABLE tabname ADD colname varchar2;
     COMMENT ON COLUMN tabname.colname IS 'comments';

     ALTER TABLE t_employee_base ADD COLUMN is_active char(1) DEFAULT 'n';
     COMMENT ON COLUMN t_employee_base.is_active IS '用户是否激活，默认为 n，表示未激活';

     -- 删除一列
     ALTER TABLE tabname DROP COLUMN colname;

     -- 添加主键
     ALTER TABLE tabname ADD PRIMARY KEY ("pk_name");

     -- 重命名列
     ALTER TABLE tabname RENAME COLUMN oldcol TO newcol;
   #+END_SRC

* 数据操作：增删改查
** 查询 SELECT
   #+BEGIN_SRC sql
     -- 选取全部列
     SELECT * FROM emp;

     -- 选取部分列
     SELECT empno, hiredate FROM emp;
   #+END_SRC

* 用户、角色和权限
** 查看当前用户
   #+BEGIN_SRC sql
     SHOW USER;
     SELECT USER FROM DUAL;
   #+END_SRC

   例如：
   #+BEGIN_SRC text
     SQL> SHOW USER;
     USER is "APPLE"
     SQL> SELECT USER FROM DUAL;
     Apple
   #+END_SRC

** 创建/解锁用户
   #+BEGIN_SRC sql
     CREATE USER <username> IDENTIFIED BY <password>;

     ALTER USER <username> ACCOUNT UNLOCK IDENTIFIED BY <password>;

     ALTER USER hr ACCOUNT UNLOCK IDENTIFIED BY hr;
   #+END_SRC

** 删除用户
   #+BEGIN_SRC sql
     DROP USER <username>;
   #+END_SRC

** 修改用户密码
   有时候修改用户密码但是不知道用户的原始密码，可以添加 =VALUES= 传入的是数据库
   加密后的密码字符串
   #+BEGIN_SRC sql
     ALTER USER <username> IDENTIFIED BY <password>;
     ALTER USER <username> IDENTIFIED BY VALUES <encrypted_password>;
   #+END_SRC

** 角色和授权
   #+BEGIN_SRC sql
     -- 创建角色
     CREATE ROLE <rolename> IDENTIFIED BY <password>;
     -- 授权用户
     GRANT ALL ON <database>.* TO <username>;
     -- 解除授权
     REVOKE ALL ON <database>.* FROM <username>;
   #+END_SRC

* 内置函数
** 单行函数
*** 数值函数
    - ~ABS(n)~
    - ~ACOS(n)~
    - ~ASIN(n)~
    - ~ATAN(n)~
    - ~ATAN2(n)~
    - ~BITAND(expr1, expr2)~ : 计算 expr1 和 expr2 的按位与操作，通常和 DECODE
      一起搭配使用
    - ~CEIL(n)~
    - ~COS(n)~
    - ~COSH(n)~
    - ~EXP(n)~
    - ~FLOOR(n)~
    - ~LN(n)~
    - ~LOG(n)~
    - ~MOD(n, m)~ : =MOD(11,4) -> 3=
    - ~NANVL(n)~
    - ~POWER(n)~
    - ~REMAINDER(n, m)~ : 求余数
    - ~ROUND(n, precision)~ : precision 表示小数点后的精度，例如：
      =TRUNC(15.193,1) -> 15.2=, =TRUNC(15.193, -1) -> 20=
    - ~SIGN(n)~
    - ~SIN(n)~
    - ~SINH(n)~
    - ~SQRT(n)~
    - ~TAN(n)~
    - ~TANH(n)~
    - ~TRUNC(n, precision)~: precision 表示小数点后的精度， 例如：
      =TRUNC(15.79,1) -> 15.7=, =TRUNC(15.79, -1) -> 10=
    - ~WIDTH_BUCKET(n, min_value, max_value, num_buckets)~ : 使用 WIDTH_BUCKET
      可以根据输入参数创建等长的段。范围 min_value 到 max_value 被分为
      num_buckets 节，每节有相同的大小。返回 n 所在的那一节。如果 n 小于
      min_value，将返回 0，如果 n 大于或等于 max_value，将返回
      num_buckets+1. min_value 和 max_value 都不能为 NULL，num_buckets 必须是一
      个正整数。如果 n 是 NULL，则返回 NULL。
      + min_value, max_value 取值范围的最小值和最大值
      + num_buckets 所分为的节

    #+BEGIN_SRC sql
      SELECT order_id, customer_id,
             DECODE(BITAND(order_status, 1), 1, 'Warehouse', 'PostOffice')
               Location,
             DECODE(BITAND(order_status, 2), 2, 'Ground', 'Air') Method,
             DECODE(BITAND(order_status, 4), 4, 'Insured', 'Certified') Receipt
        FROM orders
       WHERE order_status < 8;

      --    ORDER_ID CUSTOMER_ID LOCATION   METHOD RECEIPT
      -- ---------- ----------- ---------- ------ ---------
      --       2458         101 PostOffice Air    Certified
      --       2397         102 Warehouse  Air    Certified
      --       2454         103 Warehouse  Air    Certified
      --       2354         104 PostOffice Air    Certified
      --       2358         105 PostOffice Ground Certified
      --       2381         106 Warehouse  Ground Certified
      --       2440         107 Warehouse  Ground Certified
      --       2357         108 Warehouse  Air    Insured
      --       2394         109 Warehouse  Air    Insured
      --       2435         144 PostOffice Ground Insured


      SELECT customer_id, cust_last_name, credit_limit,
             WIDTH_BUCKET(credit_limit, 100, 5000, 10) "Credit Group"
        FROM customers WHERE nls_territory = 'SWITZERLAND'
       ORDER BY "Credit Group";

      -- CUSTOMER_ID CUST_LAST_NAME       CREDIT_LIMIT Credit Group
      -- ----------- -------------------- ------------ ------------
      --         825 Dreyfuss                      500            1
      --         826 Barkin                        500            1
      --         853 Palin                         400            1
      --         827 Siegel                        500            1
      --         843 Oates                         700            2
      --         844 Julius                        700            2
      --         835 Eastwood                     1200            3
      --         840 Elliott                      1400            3
      --         842 Stern                        1400            3
      --         841 Boyer                        1400            3
      --         837 Stanton                      1200            3
      --         836 Berenger                     1200            3
      --         848 Olmos                        1800            4
      --         849 Kaurusmdki                   1800            4
      --         828 Minnelli                     2300            5
      --         829 Hunter                       2300            5
      --         852 Tanner                       2300            5
      --         851 Brown                        2300            5
      --         850 Finney                       2300            5
      --         830 Dutt                         3500            7
      --         831 Bel Geddes                   3500            7
      --         832 Spacek                       3500            7
      --         838 Nicholson                    3500            7
      --         839 Johnson                      3500            7
      --         833 Moranis                      3500            7
      --         834 Idle                         3500            7
      --         845 Fawcett                      5000           11
      --         846 Brando                       5000           11
      --         847 Streep                       5000           11
    #+END_SRC

*** 返回字符值的字符函数
    - ~CHR(n)~
    - ~CONCAT(str1, str2)~ : 字符串可以是 CHAR, VARCHAR2, NCHAR, NVARCHAR2,
      CLOB, NCLOB 这些类型
    - ~INITCAP(s)~
    - ~LOWER(s)~
    - ~LPAD(s, n, pad)~ : 左填充字符串，填充 n 个 pad 字符到 s 的左侧，返回新字
      符串
    - ~LTRIM(s[, set])~ : 移除左侧包含的 set 字符
    - ~NLS_INITCAP(s)~
    - ~NLS_LOWER(s)~
    - ~NLSSORT(s)~
    - ~NLS_UPPER(s)~
    - ~REGEXP_REPLACE(str, pat, repl_str, pos, occur, match_param)~ : 正则表达式
      替换
      + str 源字符串
      + pat 匹配的正则表达式
      + repl_str 待替换的字符串
      + pos 替换的起始位置，默认为 0
      + occur 替换的次数，默认为 0，表示全部替换
      + match_param 匹配参数，匹配参数可以多个混合使用，例如： 'mc'
        - 'i' = ignore-case
        - 'c' = case-sensitive
        - 'n' = 点号 (=.=) 不匹配换行符号
        - 'm' = mutil-line
        - 'x' = 扩展模式，忽略正则表达式中的空白字符
    - ~REGEXP_SUBSTR(str, pat, pos, occur, match_param)~ : 和 REGEXP_REPLACE 类
      似，只是常用于搜索字符串或者提取字串
    - ~REPLACE(str, search_str, repl_str)~ : 将字符串 str 中的 search_str 替换成
      repl_str
    - ~RPAD(s[, set])~
    - ~RTRIM(s[, set])~
    - ~SOUNDEX(s)~
    - ~SUBSTR(s, pos, len)~ : 以 pos 作为起始位置，截取总长度为 len，s 的字串
    - ~TRANSLATE(s)~
    - ~TREAT(expr AS REF schema.type)~
    - ~TRIM([LEADING|TRAILING|BOTH] trim_char FROM trim_src)~ : 删除空白符号
      =TO_CHAR(TRIM(LEADING 0 FROM hire_date))=
    - ~UPPER(s)~

    #+BEGIN_SRC sql
      SQL> SELECT substr('abcdef', 2, 3) FROM DUAL;
      bcd

      SQL> SELECT instr('abcdef', 'cd') FROM DUAL;
                 3

      SQL> SELECT instr('abcdef', 'ce') FROM DUAL;
                 0

      SQL> SELECT replace('abcdef', 'ce') FROM DUAL;
      abcdef

      SQL> SELECT replace('abcdef', 'cd', '$$') FROM DUAL;
      ab$$ef

      SQL> select regexp_substr('500 Oracle Parkway, Redwood Shores, CA', ',[^,]+,') from dual;
      , Redwood Shores,

      SQL> SELECT lower('abcdef') FROM DUAL;
      abcdef

      SQL> SELECT upper('abcdef') FROM DUAL;
      ABCDEF

      SQL> select lpad('Page 1',15,'*.') from dual;
      ,*.*.*.*.*Page 1
    #+END_SRC

    处理字符串的回车换行符 Oracle 字符串好回车换行符处理需要借助 ~chr~ 函数，见
    如下例子
    #+BEGIN_SRC sql
      SQL> SELECT E_NOTE FROM T_EMPLOYEE_BASE WHERE E_CODE='test04';
      第一行
      第二行

      SQL> SELECT replace(replace(E_NOTE, chr(13), ''), chr(10), '') FROM T_EMPLOYEE_BASE WHERE E_CODE='test04';
      第一行第二行

      SQL> SELECT replace(replace(E_NOTE, chr(13), ''), chr(10), ' _r_n ') FROM T_EMPLOYEE_BASE WHERE E_CODE='test04';
      第一行 _r_n 第二行
    #+END_SRC

*** NLS 字符串函数
    - ~NLS_CHARSET_DECL_LEN()~ : =NLS_CHARSET_DECL_LEN (200, nls_charset_id('ja16eucfixed'))=
    - ~NLS_CHARSET_ID()~
    - ~NLS_CHARSET_NAME()~

*** 返回数值的字符函数
    - ~ASCII(c)~
    - ~INSTR(s, search_str, pos, occur)~ : 如果 search_str 在字符串 s 中，返回真；
      否则假。pos 表示起始搜索位置，occur 表示搜索次数
    - ~LENGTH(s)~
    - ~REGEXP_INSTR(str, pat, pos, occur, ret_option, match_param)~
      + ret_option 表示 occur 的相对位置，0 表示第一次出现，1 表示第二次出现

*** 时间/日期函数
    - ~ADD_MONTHS(date, n)~
    - ~CURRENT_DATE~
    - ~CURRENT_TIMESTAMP(precision)~ : precision 表示秒后面的小数位数，默认为 6
    - ~DBTIMEZONE~ : 当前时区
    - ~EXTRACT(val FROM str)~ : =EXTRACT(month FROM order_date)=
      + val 可以是 YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, TIMEZONE_HOUR,
        TIMEZONE_MINUTE, TIMEZONE_REGION, TIMEZONE_ABBR
      + str 是时间格式的字符串
    - ~FROM_TZ~ : =FROM_TZ(TIMESTAMP '2000-03-28 08:00:00', '3:00')=
    - ~LAST_DAY(date)~ : date 月的最后一天
    - ~LOCALTIMESTAMP()~ : 带区域信息的时间戳
    - ~MONTHS_BETWEEN(date1, date2)~ : date1 和 date2 相差的月份，是个浮点数
    - ~NEW_TIME(date, timezone1, timezone)~
    - ~NEXT_DAY(date, str)~ : 返回在 date 日期过后的 str 表示的星期，例如：
      =NEXT_DAY('02-FEB-2001','TUESDAY')= 返回 2001 年 2 月 2 日后面的第一个星期二
    - ~NUMTODSINTERVAL(n, interval_unit)~
    - ~NUMTOYMINTERVAL(n, interval_unit)~
    - ~ROUND(date, fmt)~
    - ~SESSIONTIMEZONE~
    - ~SYS_EXTRACT_UTC()~
    - ~SYSDATE~ : 系统时间
    - ~SYSTIMESTAMP~ : 系统时间戳
    - ~TO_CHAR(date, fmt)~ : 格式化日期, 例如要获取 '2018-12-02' 这样的字符串可以使用
    - ~TO_TIMESTAMP()~
    - ~TO_TIMESTAMP_TZ()~
    - ~TO_DSINTERVAL()~
    - ~TO_YMINTERVAL()~
    - ~TRUNC (date)()~
    - ~TZ_OFFSET()~

    #+BEGIN_SRC sql
      SQL> select DBTIMEZONE from dual;
      +00:00

      SQL> select NEXT_DAY('02-FEB-2001','TUESDAY') from dual;
      06-FEB-01

      SQL> select TO_CHAR(current_timestamp, 'YYYY-MM-DD') from dual;
      2019-07-11

      SQL> select SYSTIMESTAMP from dual;
      11-JUL-19 12.38.17.185000 PM +08:00

      SQL> select SYSDATE from dual;
      11-JUL-19

      SQL> select SYSTIMESTAMP from dual;
      11-JUL-19 12.42.11.732000 PM +08:00
    #+END_SRC

*** 通用比较函数
    - ~GREATEST(a1, a2, ...)~
    - ~LEAST(a1, a2, ...)~

*** 类型转化函数
    - ~ASCIISTR()~
    - ~BIN_TO_NUM()~
    - ~CAST()~
    - ~CHARTOROWID()~
    - ~COMPOSE()~
    - ~CONVERT()~
    - ~DECOMPOSE()~
    - ~HEXTORAW()~
    - ~NUMTODSINTERVAL()~
    - ~NUMTOYMINTERVAL()~
    - ~RAWTOHEX()~
    - ~RAWTONHEX()~
    - ~ROWIDTOCHAR()~
    - ~ROWIDTONCHAR()~
    - ~SCN_TO_TIMESTAMP()~
    - ~TIMESTAMP_TO_SCN()~
    - ~TO_BINARY_DOUBLE()~
    - ~TO_BINARY_FLOAT()~
    - ~TO_CHAR()~
    - ~TO_CLOB()~
    - ~TO_DATE()~
    - ~TO_DSINTERVAL()~
    - ~TO_LOB()~
    - ~TO_MULTI_BYTE()~
    - ~TO_NCHAR()~
    - ~TO_NCLOB()~
    - ~TO_NUMBER()~
    - ~TO_DSINTERVAL()~
    - ~TO_SINGLE_BYTE()~
    - ~TO_TIMESTAMP()~
    - ~TO_TIMESTAMP_TZ()~
    - ~TO_YMINTERVAL()~
    - ~UNISTR()~

*** 大对象处理函数
    - ~BFILENAME()~
    - ~EMPTY_BLOB, EMPTY_CLOB()~

*** 集合函数
    - ~CARDINALITY()~
    - ~COLLECT()~
    - ~POWERMULTISET()~
    - ~POWERMULTISET_BY_CARDINALITY()~
    - ~SET()~

*** 继承函数
    - ~SYS_CONNECT_BY_PATH()~ : 主要用于树查询(层次查询) 以及 多列转行。其语法一般为：
    #+BEGIN_SRC sql
      SELECT ... SYS_CONNECT_BY_PATH(colname, 'CONNECT_SYMBOL')  FROM tabname
      START WITH ... CONNECT BY ... PRIOR
    #+END_SRC

*** 数据挖掘函数
    - ~CLUSTER_ID()~
    - ~CLUSTER_PROBABILITY()~
    - ~CLUSTER_SET()~
    - ~FEATURE_ID()~
    - ~FEATURE_SET()~
    - ~FEATURE_VALUE()~
    - ~PREDICTION()~
    - ~PREDICTION_COST()~
    - ~PREDICTION_DETAILS()~
    - ~PREDICTION_PROBABILITY()~
    - ~PREDICTION_SET()~

*** XML 函数
    - ~APPENDCHILDXML()~
    - ~DELETEXML()~
    - ~DEPTH()~
    - ~EXTRACT (XML)()~
    - ~EXISTSNODE()~
    - ~EXTRACTVALUE()~
    - ~INSERTCHILDXML()~
    - ~INSERTXMLBEFORE()~
    - ~PATH()~
    - ~SYS_DBURIGEN()~
    - ~SYS_XMLAGG()~
    - ~SYS_XMLGEN()~
    - ~UPDATEXML()~
    - ~XMLAGG()~
    - ~XMLCDATA()~
    - ~XMLCOLATTVAL()~
    - ~XMLCOMMENT()~
    - ~XMLCONCAT()~
    - ~XMLFOREST()~
    - ~XMLPARSE()~
    - ~XMLPI()~
    - ~XMLQUERY()~
    - ~XMLROOT()~
    - ~XMLSEQUENCE()~
    - ~XMLSERIALIZE()~
    - ~XMLTABLE()~
    - ~XMLTRANSFORM()~

*** 编码/解码函数
    - ~DECODE()~
    - ~DUMP()~
    - ~ORA_HASH()~
    - ~VSIZE()~

    使用 ~DECODE~ 函数可以对模仿应用程序的 ~if-then-else~ 结构。
    #+BEGIN_SRC sql
      SQL> SELECT SEX || ':' || decode(SEX, '男', 1, '女', 2, 0) FROM T_EMPLOYEE_BASE WHERE ROWNUM < 5;

      男:1
      女:2
      男:1
      女:2
    #+END_SRC

*** NULL 相关函数
    - ~COALESCE(expr1, expr2, ...)~ : 返回第一个非 NULL 值
    - ~LNNVL(cond)~
    - ~NULLIF(expr1, expr2)~ : expr1 和 expr2 相等返回 NULL，不等返回 expr1
    - ~NVL(expr1, expr2)~ : expr1 为 NULL，返回 expr2；不为 NULL，返回 expr1。注意两
      者的类型要一致
    - ~NVL2(expr1, expr2, expr3)~ : expr1 不为 NULL，返回 expr2；为 NULL，返回
      expr3。expr2 和 expr3 类型不同的话，expr3 会转换为 expr2 的类型

    在数据库选取时候需要处理空值，即 ~NULL~ 值。Oracle 提供 ~nvl~ 函数来处理空值
    #+BEGIN_SRC sql
      SQL> SELECT nvl(length(PHOTO), 0) AS PHOTO_SIZE FROM T_EMPLOYEE_BASE WHERE rownum < 10;

      PHOTO_SIZE
      ----------
          103357
           12177
           84866
          102154
           17527
          169567
           33577
           0
           52372

      SQL> SELECT nvl(to_char(length(PHOTO)), 'null') AS PHOTO_SIZE FROM T_EMPLOYEE_BASE WHERE rownum < 10;

      PHOTO_SIZE
      ----------
      103357
      12177
      84866
      102154
      17527
      169567
      33577
      null
      52372
    #+END_SRC

*** 环境和标识符函数
    - ~SYS_CONTEXT()~
    - ~SYS_GUID()~
    - ~SYS_TYPEID()~
    - ~UID~
    - ~USER()~
    - ~USERENV()~
    #+BEGIN_SRC sql
      SQL> SELECT SYS_CONTEXT ('USERENV', 'SESSION_USER') FROM DUAL;

      BAMTRI_MES

      SQL> SELECT UID FROM DUAL;

          69

      SQL> SELECT SYS_GUID FROM DUAL;
      SELECT SYS_GUID FROM DUAL
             ,*
      ERROR at line 1:
      ORA-00904: "SYS_GUID": invalid identifier


      SQL> SELECT SYS_GUID() FROM DUAL;

      23497C0CBD3548E2A30F172BA6CB55CD

      SQL> SELECT UID() FROM DUAL;
      SELECT UID() FROM DUAL
                ,*
      ERROR at line 1:
      ORA-00923: FROM keyword not found where expected
    #+END_SRC

** 聚合函数
   - ~AVG(expr)~ : 平均值
   - ~COLLECT()~
   - ~CORR()~
   - ~COUNT(expr)~ : 计数
   - ~COVAR_POP()~
   - ~COVAR_SAMP()~
   - ~CUME_DIST()~
   - ~DENSE_RANK()~
   - ~FIRST~ : 取首个值, 具体参考下面的例子 =aggr_func KEEP (DENSE_RANK FIRST
     ORDER BY expr [ASC/DESC] [NULLS FIRST/LAST])=
   - ~GROUP_ID()~
   - ~GROUPING()~
   - ~GROUPING_ID()~
   - ~LAST~ : 取最后一个值， 语法和 FIRST 相似。 =aggr_func KEEP (DENSE_RANK
     LAST ORDER BY expr [ASC/DESC] [NULLS FIRST/LAST])=
   - ~MAX(expr)~ : 最大值
   - ~MEDIAN()~
   - ~MIN(expr)~ : 最小值
   - ~PERCENTILE_CONT()~
   - ~PERCENTILE_DISC()~
   - ~PERCENT_RANK()~
   - ~RANK()~
   - ~STATS_BINOMIAL_TEST()~
   - ~STATS_CROSSTAB()~
   - ~STATS_F_TEST()~
   - ~STATS_KS_TEST()~
   - ~STATS_MODE()~
   - ~STATS_MW_TEST()~
   - ~STATS_ONE_WAY_ANOVA()~
   - ~STATS_WSR_TEST()~
   - ~STDDEV()~
   - ~STDDEV_POP()~
   - ~STDDEV_SAMP()~
   - ~SUM(expr)~ : 求和
   - ~VAR_POP()~
   - ~VAR_SAMP()~
   - ~VARIANCE(expr)~ : 方差

   #+BEGIN_SRC sql
     SELECT department_id,
            MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) "Worst",
            MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) "Best"
       FROM employees
      GROUP BY department_id;

     -- DEPARTMENT_ID      Worst       Best
     -- ------------- ---------- ----------
     --            10       4400       4400
     --            20       6000      13000
     --            30       2500      11000
     --            40       6500       6500
     --            50       2100       8200
     --            60       4200       9000
     --            70      10000      10000
     --            80       6100      14000
     --            90      17000      24000
     --           100       6900      12000
     --           110       8300      12000
     --                     7000       7000
   #+END_SRC

** 分析函数
   - ~NUMTOYMINTERVAL()~
   - ~AVG()~
   - ~CORR()~
   - ~COVAR_POP()~
   - ~COVAR_SAMP()~
   - ~COUNT()~
   - ~CUME_DIST()~
   - ~DENSE_RANK()~
   - ~FIRST()~
   - ~FIRST_VALUE()~
   - ~LAG()~
   - ~LAST()~
   - ~LAST_VALUE()~
   - ~LEAD()~
   - ~MAX()~
   - ~MIN()~
   - ~NTILE()~
   - ~PERCENT_RANK()~
   - ~PERCENTILE_CONT()~
   - ~PERCENTILE_DISC()~
   - ~RANK()~
   - ~RATIO_TO_REPORT()~
   - ~REGR_ (Linear Regression) Functions()~
   - ~ROW_NUMBER()~
   - ~STDDEV()~
   - ~STDDEV_POP()~
   - ~STDDEV_SAMP()~
   - ~SUM()~
   - ~VAR_POP()~
   - ~VAR_SAMP()~
   - ~VARIANCE()~

** 对象引用函数
   - ~DEREF()~
   - ~MAKE_REF()~
   - ~REF()~
   - ~REFTOHEX()~
   - ~VALUE()~

** 模型函数
   - ~CV()~
   - ~ITERATION_NUMBER()~
   - ~PRESENTNNV()~
   - ~PRESENTV()~
   - ~PREVIOUS()~

* 元信息
  Oracle 的数据库组织方式中所有数据库的表信息，类信息等元信息也是存放在一个对用
  户不可见的数据表中，这里称之为元表。

  表更加功能不同分成了不同的级别，不同级别对于的表名称开头不一样：
  - =USER_*=: 用户表信息
  - =DBA_*=: 数据库管理员表信息
  - =ALL_*=: 所有的表信息，包括：DBA 和 USER

  例如： =USER_TAB_COMMENTS= 表中存放着用户表的注释， =DBA_TAB_COMMENTS= 表中则
  存放在管理员的所有表注释。

** 获取表的元信息：列的属性，唯一性约束
*** 表列属性
    可以查看表中每列的名字，数据类型，长度等信息
    #+BEGIN_SRC sql
      SELECT USER_TAB_COLUMNS.TABLE_NAME ||
               ',' || USER_TAB_COLUMNS.COLUMN_NAME ||
               ',' || USER_TAB_COLUMNS.DATA_TYPE ||
               ',' || USER_TAB_COLUMNS.DATA_LENGTH ||
               ',' || USER_TAB_COLUMNS.NULLABLE
        FROM USER_TAB_COLUMNS
       WHERE ROWNUM < 100
       ORDER BY USER_TAB_COLUMNS.TABLE_NAME;
    #+END_SRC

*** 唯一性约束
    获取列的约束名称
    #+BEGIN_SRC sql
      SELECT USER_CONS_COLUMNS.OWNER ||
               ',' || USER_CONS_COLUMNS.CONSTRAINT_NAME ||
               ',' || USER_CONS_COLUMNS.TABLE_NAME ||
               ',' || USER_CONS_COLUMNS.COLUMN_NAME ||
               ',' || USER_CONS_COLUMNS.POSITION
        FROM USER_CONS_COLUMNS
       WHERE ROWNUM < 100
       ORDER BY USER_CONS_COLUMNS.TABLE_NAME;
    #+END_SRC

    获取列的约束类型
    #+BEGIN_SRC sql
      SELECT USER_CONSTRAINTS.CONSTRAINT_NAME ||
               ',' || USER_CONSTRAINTS.CONSTRAINT_TYPE ||
               ',' || USER_CONSTRAINTS.STATUS
        FROM USER_CONSTRAINTS
       WHERE USER_CONSTRAINTS.CONSTRAINT_TYPE in ('U','P')
         AND ROWNUM < 100
       ORDER BY USER_CONSTRAINTS.CONSTRAINT_NAME;
    #+END_SRC

** 获取注释信息
*** 表注释
    #+BEGIN_SRC sql
      SELECT USER_TAB_COMMENTS.TABLE_NAME ||
               ',' || USER_TAB_COMMENTS.TABLE_TYPE ||
               ',' || USER_TAB_COMMENTS.COMMENTS
        FROM USER_TAB_COMMENTS
       WHERE ROWNUM < 100
       ORDER BY USER_TAB_COMMENTS.TABLE_NAME;
    #+END_SRC

*** 列注释
    #+BEGIN_SRC sql
      SELECT USER_COL_COMMENTS.TABLE_NAME ||
               ',' || USER_COL_COMMENTS.COLUMN_NAME ||
               ',' || USER_COL_COMMENTS.COMMENTS
        FROM USER_COL_COMMENTS
       WHERE ROWNUM < 100
       ORDER BY USER_COL_COMMENTS.TABLE_NAME;
    #+END_SRC

* PL/SQL
** 存储过程
   #+BEGIN_SRC sql
     DECLARE
       -- 定义变量
       i INTEGER;
     BEGIN
       -- sqlplus 中默认输出是关闭的，可以使用下面方法开启选项
       -- SET SERVEROUTPUT ON
       DBMS_OUTPUT.put_line('Hello world');
     END;
   #+END_SRC
** 变量
*** 变量类型
    - 普通变量（CHAR, VARCHAR2, DATE, NUMBER, BOOLEAN, LONG）
    - 特殊变量（引用型变量，记录型变量）

    #+BEGIN_SRC sql
      varname varchar2(20);
    #+END_SRC

*** 变量赋值
    - 直接赋值 ~:=~
    - 语句赋值，使用 ~SELECT ... INTO ...~

    #+BEGIN_SRC sql
      DECLARE
        v_name varchar(20) := ''; -- 初始化赋值
        v_sal number;
        v_addr varchar(200);
      BEGIN
        -- 直接赋值
        v_sal := 2383;

        -- 语句赋值
        SELECT '北京市朝阳区' INTO v_addr FROM DUAL;

        DBMS_OUTPUT.put_line('姓名: ' || v_name || ', 薪水: ' || v_sal || ', 地址 c: ' || v_addr);
      END;
    #+END_SRC

* 一些使用场景

** 创建新的表空间以及用户
*** 创建数据储存的目录
    Oracle 数据库的表空间的存储目录需要显示创建
    #+BEGIN_SRC sh
      mkdir -p /u01/app/oracle/oradata/XE
    #+END_SRC

*** 创建表空间
    Oracle 在创建用户前最好为当前用户显示创建表空间，否则创建的新用户会使用默认
    的表空间。为了避免这种情况，提前创建默认表空间和临时表空间
    #+BEGIN_SRC sql
      -- 创建默认表空间
      CREATE TABLESPACE PFile1
        DATAFILE '/u01/app/oracle/oradata/XE/pfile1.dbf'
        SIZE 128M AUTOEXTEND OFF
        LOGGING
        ONLINE
        PERMANENT
        EXTENT MANAGEMENT LOCAL AUTOALLOCATE
        BLOCKSIZE 8K
        SEGMENT SPACE MANAGEMENT AUTO
        FLASHBACK ON;

      -- 创建临时表空间
      CREATE TEMPORARY TABLESPACE TFile1
        TEMPFILE '/u01/app/oracle/oradata/XE/tfile1.dbf'
        SIZE 2048M AUTOEXTEND OFF
        TABLESPACE GROUP ''
        EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M;
    #+END_SRC

*** 创建用户
    创建新的用户
    #+BEGIN_SRC sql
      DROP USER AVICTOR CASCADE;

      CREATE USER AVICTOR
        IDENTIFIED BY secret
        DEFAULT TABLESPACE PFile1
        TEMPORARY TABLESPACE TFile1
        PROFILE DEFAULT
        ACCOUNT UNLOCK;

      GRANT CONNECT TO AVICTOR;
      GRANT DBA TO AVICTOR;
      ALTER USER AVICTOR DEFAULT ROLE ALL;

      GRANT SELECT ANY DICTIONARY TO AVICTOR;
      GRANT SELECT ANY SEQUENCE TO AVICTOR;
      GRANT SELECT ANY TABLE TO AVICTOR;
      GRANT SELECT ANY TRANSACTION TO AVICTOR;
      GRANT UNLIMITED TABLESPACE TO AVICTOR;

      ALTER USER AVICTOR IDENTIFIED BY secret;
    #+END_SRC

*** 登录测试
    使用 sqlplus 测试一下连接是否成功
    #+BEGIN_SRC sh
      sqlplus avictor/secret@localhost/xe
    #+END_SRC
** 导入/导出数据
*** 导出全部数据库
    如果两个数据库的磁盘的物理路径都是相同的，可以指定 ~full=y~ 的方式导入所有的
    数据库，这种方式导出的表空间会绑定到磁盘上存储的 Datafile 路径
    #+BEGIN_SRC sh
      -- 导出所有的表
      exp user/pass@host:port/sid FULL=y FILE=data.dmp

      -- 导入所有的表
      imp user/pass@host:port/sid FULL=y FILE=data.dmp
    #+END_SRC

*** 导出用户的数据库
    如果要导出某个特定用户的所有数据库，这种方式导出的数据库的表空间文件不会绑定
    到磁盘存储的物理位置，使用下面命令可以查看所有的帮忙选项
    #+BEGIN_SRC sh
      -- 查看帮助和可选的参数
      exp HELP=y
      imp HELP=y
    #+END_SRC

    最后新建一个保存参数是文件，这样使用 exp 和 imp 文件时就可以少敲一些命令，这
    里将相关参数保存成 =options.txt=
    #+BEGIN_SRC text
      USERID=system/oracle@host/sid
      FILE=data.dmp
      GRANTS=y
      INDEXES=y
      CONSTRAINTS=y
      ROWS=y
    #+END_SRC

    导入和导出命令
    #+BEGIN_SRC sh
      -- 导出数据库
      exp PARFILE=options.txt LOG=export.log OWNER=owner1

      -- 导入数据库
      imp PARFILE=options.txt LOG=import.log FROMUSER=owner1 TOUSER=owner2
    #+END_SRC

** 正则化表达式匹配
   Oracle 可以使用 ~regexp_like~ 来做正则表达式匹配
   #+BEGIN_SRC sql
     SQL> SELECT TABLE_NAME FROM USER_TAB_COMMENTS WHERE regexp_like(TABLE_NAME, '^PRDT');

     TABLE_NAME
     -----------------------------
     PRDT_DIC
     PRDT_DIC_ALL_V
     PRDT_DIC_BOM
     PRDT_DIC_CODE_RULE
     PRDT_DIC_EXT01
     PRDT_DIC_EXT02
     PRDT_DIC_PROCESS
     PRDT_DIC_PROCESS_ALL
     PRDT_DIC_PROCESS_DEVICE_WORK
     PRDT_KIND_TYPE
     PRDT_LIST_TYPE
     PRDT_PROCESS_ACT_DIC
     PRDT_PROCESS_DIC
     PRDT_PROCESS_RES_DIC
   #+END_SRC

** 获取序列值
   创建序列
   #+BEGIN_SRC sql
     CREATE SEQUENCE SEQ_GLOBAL_ID
       START WITH 10000
       INCREMENT BY 1;
   #+END_SRC
   ~NEXTVAL~ 获取下一个序列值，同时自增， ~CURRVAL~ 获取当前序列值，单不自增。
   #+BEGIN_SRC sql

     SQL> SELECT SEQ_GLOBAL_ID.NEXTVAL FROM DUAL;

          10000

     SQL> SELECT SEQ_GLOBAL_ID.NEXTVAL FROM DUAL;

          10001

     SQL> SELECT SEQ_GLOBAL_ID.CURRVAL FROM DUAL;

          10001

     SQL> SELECT SEQ_GLOBAL_ID.CURRVAL FROM DUAL;

          10001

     SQL>
   #+END_SRC

** 限制查询结果的行数
   使用 ~ROWNUM~ 在条件语句中限制
   #+BEGIN_SRC sql
     SELECT ID FROM EMPLOYEE
      WHERE ROWNUM < 100;
   #+END_SRC

** 删除表中重复的行数据
   Oracle 里面每行都有一个 ~ROWID~ 的伪列，即使两行的数据是相同的， ~ROWID~ 也是
   唯一的。
   #+BEGIN_SRC sql
     SELECT DISTINCT MYID FROM T_EMPLOYEE_BASE E1
      WHERE ROWID != (
        SELECT max(ROWID) FROM T_EMPLOYEE_BASE E2
         WHERE E1.MYID = E2.MYID
      );
   #+END_SRC
   将 SELECT 修改成 DELETE 即可删除重复行。

** 查看数据库磁盘容量
   通过 ~SYS.DBA_FREE_SPACE~ 视图可以查看磁盘可以空间，进行实时监控。
   #+BEGIN_SRC sql
     SELECT TABLESPACE_NAME, sum(BLOCKS), sum(BYTES)
       FROM SYS.DBA_FREE_SPACE
      GROUP BY TABLESPACE_NAME
      ORDER BY TABLESPACE_NAME;
   #+END_SRC

** 查看 query 的执行时间
   查看单个 query 执行计时直接开启 ~TIMING~ 选项就可以看到
   #+BEGIN_SRC sql
     SQL> SELECT count(*) FROM T_LOG;

       COUNT(*)
     ----------
          85718

     SQL> SET TIMING ON
     SQL> SELECT count(*) FROM T_LOG;

       COUNT(*)
     ----------
          85718

     Elapsed: 00:00:00.04
     SQL> SET TIMING OFF
   #+END_SRC
   查询多条 query 语句的计时需要借助计时器
   #+BEGIN_SRC sql
     SQL> TIMING START mytimer;

     SQL> SELECT count(*) FROM T_LOG;

       COUNT(*)
     ----------
          85718

     SQL> TIMING SHOW mytimer;

     timing for: mytimer
     Elapsed: 00:00:00.04
     SQL> SELECT max(myid) FROM T_LOG;

      MAX(MYID)
     ----------
         103234


     SQL> TIMING STOP mytimer;

     timing for: mytimer
     Elapsed: 00:00:00.07
     SQL>
   #+END_SRC

** 字符串拼接的聚合函数
   oracle 10g 和 11g 的字符串拼接函数不是一样的，10g 中使用 =WM_CONCAT()= 聚合函
   数，而在 11g 中需要使用 =LISTAGG()= 聚合函数。两者的语法也是不太一样的

   10g 的使用方式
   #+BEGIN_SRC sql
     SELECT
       USER_CONS_COLUMNS.CONSTRAINT_NAME,
       WM_CONCAT(TO_CHAR(USER_CONS_COLUMNS.COLUMN_NAME))
         AS colnames
       FROM USER_CONS_COLUMNS, USER_CONSTRAINTS
      WHERE USER_CONS_COLUMNS.CONSTRAINT_NAME = USER_CONSTRAINTS.CONSTRAINT_NAME AND
            USER_CONSTRAINTS.CONSTRAINT_TYPE = 'U' AND
            UPPER(USER_CONS_COLUMNS.TABLE_NAME) = UPPER('tabname')
      GROUP BY USER_CONS_COLUMNS.CONSTRAINT_NAME;

   #+END_SRC

   11g 的使用方式
   #+BEGIN_SRC sql
     SELECT
       USER_CONS_COLUMNS.CONSTRAINT_NAME,
       LISTAGG(USER_CONS_COLUMNS.COLUMN_NAME, ',')
         WITHIN GROUP(ORDER BY USER_CONS_COLUMNS.POSITION)
         AS colnames
       FROM USER_CONS_COLUMNS, USER_CONSTRAINTS
      WHERE USER_CONS_COLUMNS.CONSTRAINT_NAME = USER_CONSTRAINTS.CONSTRAINT_NAME AND
            USER_CONSTRAINTS.CONSTRAINT_TYPE = 'U' AND
            UPPER(USER_CONS_COLUMNS.TABLE_NAME) = UPPER('tabname')
      GROUP BY USER_CONS_COLUMNS.CONSTRAINT_NAME;
   #+END_SRC

* 常见问题
** 客户端和服务器字符集不一致
   首先查看一下服务器中的编码格式，最好设置服务器的编码格式为 Unicode
   #+BEGIN_SRC sql
     SELECT USERENV('language') FROM DUAL;
   #+END_SRC
   #+BEGIN_SRC text
     SQL> SELECT USERENV('language') FROM DUAL;
     AMERICAN_AMERICA.AL32UTF8
   #+END_SRC

   根据服务器的编码格式来修改客户端的编码格式
   #+BEGIN_SRC sh
     # 将客户端修改成英文的 Unicode 码
     export NLS_LANG="AMERICAN_AMERICA.AL32UTF8"

     # 或者直接修改成中文的 Unicode 码，解决中文乱码
     export NLS_LANG="SIMPLIFIED CHINESE_CHINA.AL32UTF8"
   #+END_SRC

** 将服务器字符集从 UTF8 强转成 GBK
   修改数据库字符集最好放在在安装数据库的最初阶段，如果修改一个已经运行的数据库
   可能会发生一些不可预料的错误
   #+BEGIN_SRC sql
     -- 本操作必须使用 DBA 权限
     CONNECT SYS/oracle AS SYSDBA;

     -- 关闭连接断开所有已经建立的链接
     SHUTDOWN IMMEDIATE;
     STARTUP MOUNT;

     -- 预先设置处理工作
     ALTER SYSTEM ENABLE RESTRICTED SESSION;
     ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;
     ALTER SYSTEM SET AQ_TM_PROCESSES=0;
     ALTER DATABASE OPEN;

     -- ALTER DATABASE CHARACTER SET ZHS16GBK ;
     -- *ERROR at line 1:
     -- ORA-12712: new character set must be a superset of old character set
     -- 报字符集不兼容，此时下 INTERNAL_USE 指令不对字符集超集进行检查：
     ALTER DATABASE CHARACTER SET INTERNAL_USE ZHS16GBK;

     -- 重启数据库
     SHUTDOWN IMMEDIATE;
     STARTUP;
   #+END_SRC

   查看当前数据库的字符集
   #+BEGIN_SRC sql
     COLUMN PROPERTY_NAME FORMAT A32 HEADING 'Name';
     COLUMN PROPERTY_VALUE FORMAT A32 HEADING 'Value';
     COLUMN DESCRIPTION FORMAT A80 HEADING 'Description' TRUNCATE;

     SELECT PROPERTY_NAME, PROPERTY_VALUE, DESCRIPTION
       FROM DATABASE_PROPERTIES WHERE PROPERTY_NAME LIKE 'NLS_%';
  #+END_SRC

** ORA-00904: "POLTYP": invalid identifier
   客户端版本如下：
   #+BEGIN_SRC text
     Export: Release 11.2.0.2.0 - Production on Thu Sep 12 00:56:51 2019
     Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.
   #+END_SRC
   服务器数据版本如下：
   #+BEGIN_SRC text
     Connected to: Oracle Database 10g Enterprise Edition Release 10.2.0.4.0 - 64bit Production
     With the Partitioning, OLAP, Data Mining and Real Application Testing options
   #+END_SRC

   在使用以下 11g 的 exp 客户端程序导出 10g 服务器数据出现问题以下：
   #+BEGIN_SRC text
     EXP-00008: ORACLE error 904 encountered
     ORA-00904: "POLTYP": invalid identifier
     EXP-00000: Export terminated unsuccessfully
   #+END_SRC

   查了一下在不动数据库的前提下解决这种问题最好方法是： *将导出客户端换成 10g*

** ORA-21561: OID generation failed
   数据库的主机名解析错误
   #+BEGIN_SRC sh
     $ hostname
     Jesenia.local
     $ ping Jesenia.local
     ping: cannot resolve Jesenia.local: Unknown host
     $ cat /etc/hosts
     ##
     # Host Database
     #
     # localhost is used to configure the loopback interface
     # when the system is booting.  Do not change this entry.
     ##
     127.0.0.1	localhost
     255.255.255.255	broadcasthost
     ::1             localhost
   #+END_SRC

   在 hosts 文件结尾追加当前主机的解析地址即可
   #+BEGIN_SRC sh
     sudo echo "127.0.0.1 $(hostname)" >> /etc/hosts
   #+END_SRC

* 参考链接
  1. [[http://www.dbatoolz.com/][Vitaliy Mogilevskiy]]
  2. [[http://download.oracle.com/docs/cds/E11882_01.zip][E11882_01]] - Oracle 11g 的配套文档
