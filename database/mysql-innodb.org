#+TITLE: InnoDB 存储引擎
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-07 Wed 09:41:29>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: mysql innodb storage-engine

* InnoDB 多版本控制 MVCC
  InnoDB 的多版本控制添加如下三个字段来记录额外的信息
  1. ~DB_TRX_ID~ 6 字节的事务 ID
     - 记录上一个 Insert 或者 Update 的事务 ID
     - Delete 的事务也被当成一种特殊的 Update, 只不过多了一个标记位
  2. ~DB_ROLL_PTR~ 7 字节的回滚指针
     - 指向一个 Undo Log 记录
     - 如果是列更新了的话， Undo Log 包含反向重建的操作
  3. ~DB_ROW_ID~ 行标识
     - 就是聚簇索引的标识

* InnoDB 体系结构

  MySQL 的 InnoDB 存储引擎体系结构如下图所示

  [[file:../static/image/2021/07/innodb-architecture.png]]

  对照 MySQL 数据目录下的文件，可以找到对应的数据项如下
  #+BEGIN_SRC text
    /usr/local/mysql/data $ ll
    -rw-r----- 1 mysql mysql        56 May 21 09:58 auto.cnf
    -rw-r----- 1 mysql mysql 139311228 Jul  7 09:48 binlog.000001
    -rw-r----- 1 mysql mysql        16 Jun 22 08:14 binlog.index
    -rw-r----- 1 mysql mysql     11811 Jun 22 08:14 ib_buffer_pool
    -rw-r----- 1 mysql mysql  79691776 Jul  7 08:23 ibdata1
    -rw-r----- 1 mysql mysql  50331648 Jul  7 08:23 ib_logfile0
    -rw-r----- 1 mysql mysql  50331648 Jul  6 13:26 ib_logfile1
    -rw-r----- 1 mysql mysql  12582912 Jul  7 09:30 ibtmp1
    drwxr-x--- 2 mysql mysql      4096 May 21 09:58 mysql
    drwxr-x--- 2 mysql mysql      8192 May 21 09:58 performance_schema
    drwxr-x--- 2 mysql mysql      8192 May 21 09:58 sys
  #+END_SRC

  备注：
  - =O_DIRECT= 一般如果在 Linux 内核中读写一个文件，其 IO 流程都需要经过 Kernel
    内的 Page Cache 层次，若想要使用自己开发的缓存系统，那么就可以在打开这个文件
    的时候， 对该文件加以 =O_DIRECT= 的标志位，这样一来就可以让程序对该文件的 IO
    直接在磁盘上进行，从而避开了 Kernel 的 Page Cache，进而对 IO 流程里的块数据
    进行拦截，让其流入到自己开发的缓存系统内
  - Redo Log 是循环写入多个文件的，当文件写满可能会触发 checkpoint

* InnoDB 内存结构
** Buffer Pool
*** Buffer Pool 概述
    Buffer Pool 是 MySQL 缓存数据到内存的结构
    1. Buffer Pool 一般占用 80% 的 MySQL 的物理内存
    2. Buffer Pool 中缓存基本数据大小叫做 Page, Page 一般通过链表的方式组织
    3. LRU-List: 经常用的 Page 通过 LRU 算法组织起来
       - MySQL 使用一种改进的 LRU 算法
       - 该算法将 LRU 链表分成两个部分, ~innodb_old_blocks_pct~ 参数设置
         + New Sublist: 占 5/8
         + Old Sublist: 占 3/8
         #+BEGIN_SRC text
           New Pages                                                 Old Pages
           <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

           |----------------------------------------|------------------------|
           | head                              tail | head              tail |
           |----------------------------------------|------------------------|
           |<---------- New Sublist 5/8 ----------->|<--- Old Sublist 3/8 -->|
                                                    ^
                                                    |
                                            MidPoint Insertion
         #+END_SRC
       - 当 Page 第一次访问时，会被插入到 MidPoint 处, 即 Old Sublist 的 head,
         这么做是减少全表扫描对 LRU 的热数据的影响
       - Old Sublist 的数据会在一点的时间窗口被移到 New Sublist 中，通过
         ~innodb_old_blocks_time~ 参数可以控制移动的时间窗口
    4. Free-List: 缓存中空闲的列表
    5. Flush-List: 记录被修改的脏页 (dirty page), 这些页需要刷新到磁盘上

*** Buffer Pool 相关调优
    MySQL 默认的 ~innodb_buffer_pool_size~ 的默认大小 128 M，一般需要根据需求进
    行配置
    #+BEGIN_SRC text
      root@localhost [(none)]> show variables like '%buffer%';
      +-------------------------------------+----------------+
      | Variable_name                       | Value          |
      +-------------------------------------+----------------+
      | bulk_insert_buffer_size             | 8388608        |
      | innodb_buffer_pool_chunk_size       | 134217728      |
      | innodb_buffer_pool_dump_at_shutdown | ON             |
      | innodb_buffer_pool_dump_now         | OFF            |
      | innodb_buffer_pool_dump_pct         | 25             |
      | innodb_buffer_pool_filename         | ib_buffer_pool |
      | innodb_buffer_pool_instances        | 1              |
      | innodb_buffer_pool_load_abort       | OFF            |
      | innodb_buffer_pool_load_at_startup  | ON             |
      | innodb_buffer_pool_load_now         | OFF            |
      | innodb_buffer_pool_size             | 134217728      |
      | innodb_change_buffer_max_size       | 25             |
      | innodb_change_buffering             | all            |
      | innodb_log_buffer_size              | 16777216       |
      | innodb_sort_buffer_size             | 1048576        |
      | join_buffer_size                    | 262144         |
      | key_buffer_size                     | 8388608        |
      | myisam_sort_buffer_size             | 8388608        |
      | net_buffer_length                   | 16384          |
      | preload_buffer_size                 | 32768          |
      | read_buffer_size                    | 131072         |
      | read_rnd_buffer_size                | 262144         |
      | sort_buffer_size                    | 262144         |
      | sql_buffer_result                   | OFF            |
      +-------------------------------------+----------------+
    #+END_SRC

** Change Buffer
   Change Buffer 使用了 Buffer Pool 的部分空间完成性能优化
   1. 它主要对部分不在 Buffer Pool 中的数据 Page 页的 DML 操作 (Insert, Update
      and Delete) 进行缓存
   2. 通常这些 DML 语句影响的 Page 具有随机寻址的特性， Change Buffer 将这些修改
      缓存起来，当下次读取对应的 Page 时合并修改操作，可以降低 I/O 带来的性能低
      的问题
   3. 对于系统长时间没有访问的 Change Buffer, MySQL 会定期同步数据到磁盘

** Adaptive Hash Index
   1. InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度
      的提升，则建立哈希索引，所以称之为自适应（adaptive）
   2. 自适应哈希索引通过缓冲池的 B+ 树构造而来，因此建立的速度很快。而且不需要将
      整个表都建哈希索引，InnoDB 存储引擎会自动根据访问的频率和模式来为某些页建
      立哈希索引

** Log Buffer
   1. Redo Log 日志文件也需要相应的内存数据结构来进行缓存操作
   2. Log Buffer 就是用于缓存 Redo Log 日志文件的内存空间
   3. 其空间大小可以通过参数 ~innodb_log_buffer_size~ 来设定
   4. 日志文件的每次更新都应该刷会磁盘，不然就会有数据丢失或不一致的风险,
      ~innodb_flush_log_at_trx_commit~ 参数用于设置日志刷回磁盘的频率
      - 默认值为 1， 即每次事务提交时，都会记录日志，并将其刷回到磁盘
      - 参数值为 0 时，日志写入和刷回磁盘的操作为每秒 1 次
      - 参数值为 2 时，每次事务提交时都会写入 Log Buffer，但 Log Buffer 更新到磁
        盘的操作为每秒 1 次

* InnoDB 磁盘结构

* 参考链接
  1. [[https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html][The InnoDB Storage Engine]]
