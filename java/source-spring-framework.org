#+TITLE: Spring Framework v5.2.5.RELEASE
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-14 Wed 12:16:43>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: java spring source

* 容器实现原理
** Bean 工厂接口: BeanFactory
   ~BeanFactory~ 是 Spring 的 Bean 工厂的接口定义，它定义对 Spring Bean 容器访问的
   基本操作方法，这里简化如下
   #+BEGIN_SRC java
     public interface BeanFactory {

       // FactoryBean 的 beanName 前缀
       String FACTORY_BEAN_PREFIX = "&";

       // 获取 Bean 的主方法
       Object getBean(String name) throws BeansException;
       <T> T getBean(String name, Class<T> requiredType) throws BeansException;
       Object getBean(String name, Object... args) throws BeansException;
       <T> T getBean(Class<T> requiredType) throws BeansException;
       <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;

       <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
       <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);

       boolean containsBean(String name);

       boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
       boolean isPrototype(String name) throws NoSuchBeanDefinitionException;

       boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
       boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;

       @Nullable
       Class<?> getType(String name) throws NoSuchBeanDefinitionException;
       @Nullable
       Class<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;

       String[] getAliases(String name);
     }
   #+END_SRC

** Bean 工厂的实现类: DefaultListableBeanFactory
   ~DefaultListableBeanFactory~ 是实现 ~BeanFactory~ 接口的核心类，熟悉它的类继
   承和实现接口是了解 Bean 工厂功能的基本方法， ~DefaultListableBeanFactory~ 的
   关系如下
   #+BEGIN_SRC text
     org.springframework.beans.factory.support
     Class DefaultListableBeanFactory

         java.lang.Object
             org.springframework.core.SimpleAliasRegistry
                 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry
                     org.springframework.beans.factory.support.FactoryBeanRegistrySupport
                         org.springframework.beans.factory.support.AbstractBeanFactory
                             org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory
                                 org.springframework.beans.factory.support.DefaultListableBeanFactory

         All Implemented Interfaces:
             Serializable, BeanFactory, AutowireCapableBeanFactory,
             ConfigurableBeanFactory, ConfigurableListableBeanFactory,
             SingletonBeanRegistry, HierarchicalBeanFactory, ListableBeanFactory,
             BeanDefinitionRegistry, org.springframework.core.AliasRegistry

         Direct Known Subclasses:
             XmlBeanFactory
   #+END_SRC

   这里说明一下重要的类和接口的作用
   1. ~SimpleAliasRegistry~ 实现了 ~AliasRegistry~ 接口
      - ~AliasRegistry~ 定义了对别名的增删查改操作
   2. ~DefaultSingletonBeanRegistry~ 实现了 ~SingletonBeanRegistry~ 接口
      - ~SingletonBeanRegistry~ 定义了对单例 Bean 的注册及获取方法
      - ~SingletonBeanRegistry~ 通过三级缓存来解决循环依赖
   3. ~FactoryBeanRegistrySupport~ 实现了对 ~FactoryBean~ 的操作支持
      - 在 Spring 管理中, ~FactoryBean~ 的 beanName 以 ~&~ 开头
      - ~FactoryBean~ 的创建方式和普通 Spring Bean 是不一样的，它没有
        BeanDefinition, 直接通过实现 ~T getObject()~ 方法来返回创建的 Bean 对象
      - ~FactoryBean~ 还需要实现一些其他的方法，例如： ~isSingleton()~,
        ~getObjectType()~
   4. ~AbstractBeanFactory~ 实现了 ~BeanFactory~ 接口
      - ~BeanFactory~ 接口的直接实现是 ~AbstractBeanFactory~ 抽象类
      - ~AbstractBeanFactory~ 有很多核心方法
        + ~doGetBean(...)~ 实现了获取 Bean 的核心逻辑
        + ~isSingleton(...)~ 实现了判断 Bean 是否单例的核心逻辑
        + ~isPrototype(...)~ 实现了判断 Bean 是否原型的核心逻辑
   5. ~HierarchicalBeanFactory~ 接口继承自 ~BeanFactory~, 它增强了对 parentFactory
      的支持
   6. ~ConfigurableBeanFactory~ 接口提供了配置 Factory 的各种操作
      - ~setBeanClassLoader(...)~ 设置 Bean 的类加载器
      - ~registerDependentBean(...)~ 方法注册依赖 Bean
      - ~registerScope(...)~ 注册 Scope
      - ~isFactoryBean(...)~ 判断是否为 FactoryBean
      - ~destroyBean(...)~ 销毁 Bean
   7. ~ListableBeanFactory~ 定义了一些获取 Bean 清单的操作
      - ~getBeanDefinitionCount()~ 获取工厂中定义 BeanDefinition 的数量
      - ~getBeanDefinitionNames()~ 获取工厂定义的 BeanDefinition 名称

** Bean 定义的读取器: XmlBeanDefinitionReader
   ~XmlBeanDefinitionReader~ 是实现读取 BeanDefinition 的类，它的继承关系如下
   #+BEGIN_SRC text
     org.springframework.beans.factory.xml
     Class XmlBeanDefinitionReader

         java.lang.Object
             org.springframework.beans.factory.support.AbstractBeanDefinitionReader
                 org.springframework.beans.factory.xml.XmlBeanDefinitionReader

         All Implemented Interfaces:
             BeanDefinitionReader, org.springframework.core.env.EnvironmentCapable
   #+END_SRC

   这里说明一下重要的类和接口的作用
   1. ~AbstractBeanDefinitionReader~ 实现了对 BeanDefinition 的读取操作，它包含
      如下成员变量
      #+BEGIN_SRC java
        private final BeanDefinitionRegistry registry;
        private ResourceLoader resourceLoader;
        private ClassLoader beanClassLoader;
        private Environment environment;
        private BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;
      #+END_SRC
      - registry 表示 BeanDefinition 的注册类
      - resourceLoader 实现了资源加载
      - environment 实现了读取系统环境变量和 Java 属性
      - beanNameGenerator 是 beanName 生成器
   2. ~XmlBeanDefinitionReader~ 直接继承自 ~AbstractBeanDefinitionReader~, 增加了
      - ~DocumentLoader~ 将资源转化成 Document 对象功能
      - 添加了对 XML 的格式验证的方法
        + DTD (Document Type Definition) 验证
        + XSD (XML Schema Definition) 验证

** BeanDefinition 自动加载流程
   ~DefaultListableBeanFactory~ 类定义了存储 BeanDefinition 类的哈希表, 具体定义如下
   #+BEGIN_SRC java
      /** Map of bean definition objects, keyed by bean name. */
      private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

      /** Map of singleton and non-singleton bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);

      /** Map of singleton-only bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);

      /** List of bean definition names, in registration order. */
      private volatile List<String> beanDefinitionNames = new ArrayList<>(256);
   #+END_SRC

   最终 BeanDefinition 通过调用 ~registerBeanDefinition(...)~ 方法注册到
   ~beanDefinitionMap~ 中，代码的注释也写了是对 ~BeanDefinitionRegistry~ 的实现
   #+BEGIN_SRC java
     //---------------------------------------------------------------------
     // Implementation of BeanDefinitionRegistry interface
     //---------------------------------------------------------------------

     @Override
     public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
             throws BeanDefinitionStoreException {

         Assert.hasText(beanName, "Bean name must not be empty");
         Assert.notNull(beanDefinition, "BeanDefinition must not be null");

         if (beanDefinition instanceof AbstractBeanDefinition) {
             try {
                 ((AbstractBeanDefinition) beanDefinition).validate();
             }
             catch (BeanDefinitionValidationException ex) {
                 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                         "Validation of bean definition failed", ex);
             }
         }

         BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
         if (existingDefinition != null) {
             if (!isAllowBeanDefinitionOverriding()) {
                 throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
             }
             else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                 // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                 if (logger.isInfoEnabled()) {
                     logger.info("Overriding user-defined bean definition for bean '" + beanName +
                             "' with a framework-generated bean definition: replacing [" +
                             existingDefinition + "] with [" + beanDefinition + "]");
                 }
             }
             else if (!beanDefinition.equals(existingDefinition)) {
                 if (logger.isDebugEnabled()) {
                     logger.debug("Overriding bean definition for bean '" + beanName +
                             "' with a different definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             else {
                 if (logger.isTraceEnabled()) {
                     logger.trace("Overriding bean definition for bean '" + beanName +
                             "' with an equivalent definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             this.beanDefinitionMap.put(beanName, beanDefinition);
         }
         else {
             if (hasBeanCreationStarted()) {
                 // Cannot modify startup-time collection elements anymore (for stable iteration)
                 synchronized (this.beanDefinitionMap) {
                     this.beanDefinitionMap.put(beanName, beanDefinition);
                     List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                     updatedDefinitions.addAll(this.beanDefinitionNames);
                     updatedDefinitions.add(beanName);
                     this.beanDefinitionNames = updatedDefinitions;
                     removeManualSingletonName(beanName);
                 }
             }
             else {
                 // Still in startup registration phase
                 this.beanDefinitionMap.put(beanName, beanDefinition);
                 this.beanDefinitionNames.add(beanName);
                 removeManualSingletonName(beanName);
             }
             this.frozenBeanDefinitionNames = null;
         }

         if (existingDefinition != null || containsSingleton(beanName)) {
             resetBeanDefinition(beanName);
         }
     }
   #+END_SRC

   在 ~registerBeanDefinition(...)~ 方法中添加端点可以获得如下的调用栈
   #+BEGIN_SRC text
     registerBeanDefinition:914, DefaultListableBeanFactory (org.springframework.beans.factory.support)
     registerBeanDefinition:164, BeanDefinitionReaderUtils (org.springframework.beans.factory.support)
     processBeanDefinition:311, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     parseDefaultElement:197, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     parseBeanDefinitions:176, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     doRegisterBeanDefinitions:149, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     registerBeanDefinitions:96, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     registerBeanDefinitions:509, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     doLoadBeanDefinitions:389, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     loadBeanDefinitions:336, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     loadBeanDefinitions:305, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     loadBeanDefinitions:188, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:224, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:195, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:257, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:128, AbstractXmlApplicationContext (org.springframework.context.support)
     loadBeanDefinitions:94, AbstractXmlApplicationContext (org.springframework.context.support)
     refreshBeanFactory:133, AbstractRefreshableApplicationContext (org.springframework.context.support)
     obtainFreshBeanFactory:637, AbstractApplicationContext (org.springframework.context.support)
     refresh:522, AbstractApplicationContext (org.springframework.context.support)
     <init>:144, ClassPathXmlApplicationContext (org.springframework.context.support)
     <init>:85, ClassPathXmlApplicationContext (org.springframework.context.support)
     main:10, MyApp01 (io.github.jeanhwea.app01)
   #+END_SRC

   观察调用栈可以得到 BeanDefinition 的加载步骤如下:
   1. 入口方法为 ~AbstractApplicationContext#refresh(...)~
   2. ~obtainFreshBeanFactory(...)~ 方法获取 BeanFactory 的同时需要注册
      BeanDefinition
   3. ~XmlBeanDefinitionReader#doLoadBeanDefinitions(...)~ 方法完成如下操作
      - 定义了 documentLoader 成员变量
        #+BEGIN_SRC java
          private DocumentLoader documentLoader = new DefaultDocumentLoader();
        #+END_SRC
      - 首先调用 ~doLoadDocument(inputSource, resource)~ 读取到 Document 对象
      - 然后调用 ~registerBeanDefinitions(doc, resource)~ 完成 BeanDefinition 的
        注册
   4. 调用 ~parseDefaultElement(...)~ 方法对默认元素进行解析
      - 对 import 类型标签解析
      - 对 alias 类型标签解析
      - 对 bean 类型标签解析
      - 对嵌套 bean 类型标签解析
   5. 接着对标签进行处理，最终交付到
      ~DefaultListableBeanFactory#registerBeanDefinition(...)~ 方法进行注册

** BeanDefinition 注册的实现
   ~DefaultListableBeanFactory~ 的 ~registerBeanDefinition(...)~ 才是真正实现注
   册 BeanDefinition 逻辑，其代码如下：
   1. 对 beanDefinition 进行验证
   2. 检查 beanDefinition 是否存在
      - 如果存在，判断是否覆盖对应的 BeanDefinition
      - 如果 beanDefinition 不存在，进行创建并注册
   #+BEGIN_SRC java
     //---------------------------------------------------------------------
     // Implementation of BeanDefinitionRegistry interface
     //---------------------------------------------------------------------

     @Override
     public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
             throws BeanDefinitionStoreException {

         Assert.hasText(beanName, "Bean name must not be empty");
         Assert.notNull(beanDefinition, "BeanDefinition must not be null");

         if (beanDefinition instanceof AbstractBeanDefinition) {
             try {
                 ((AbstractBeanDefinition) beanDefinition).validate();
             }
             catch (BeanDefinitionValidationException ex) {
                 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                         "Validation of bean definition failed", ex);
             }
         }

         BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
         if (existingDefinition != null) {
             if (!isAllowBeanDefinitionOverriding()) {
                 throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
             }
             else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                 // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                 if (logger.isInfoEnabled()) {
                     logger.info("Overriding user-defined bean definition for bean '" + beanName +
                             "' with a framework-generated bean definition: replacing [" +
                             existingDefinition + "] with [" + beanDefinition + "]");
                 }
             }
             else if (!beanDefinition.equals(existingDefinition)) {
                 if (logger.isDebugEnabled()) {
                     logger.debug("Overriding bean definition for bean '" + beanName +
                             "' with a different definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             else {
                 if (logger.isTraceEnabled()) {
                     logger.trace("Overriding bean definition for bean '" + beanName +
                             "' with an equivalent definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             this.beanDefinitionMap.put(beanName, beanDefinition);
         }
         else {
             if (hasBeanCreationStarted()) {
                 // Cannot modify startup-time collection elements anymore (for stable iteration)
                 synchronized (this.beanDefinitionMap) {
                     this.beanDefinitionMap.put(beanName, beanDefinition);
                     List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                     updatedDefinitions.addAll(this.beanDefinitionNames);
                     updatedDefinitions.add(beanName);
                     this.beanDefinitionNames = updatedDefinitions;
                     removeManualSingletonName(beanName);
                 }
             }
             else {
                 // Still in startup registration phase
                 this.beanDefinitionMap.put(beanName, beanDefinition);
                 this.beanDefinitionNames.add(beanName);
                 removeManualSingletonName(beanName);
             }
             this.frozenBeanDefinitionNames = null;
         }

         if (existingDefinition != null || containsSingleton(beanName)) {
             resetBeanDefinition(beanName);
         }
     }
   #+END_SRC

   在上面注册过程中， ~hasBeanCreationStarted()~ 方法用于判断 Bean 是否开始创建，
   它实现逻辑在父类 ~AbstractBeanFactory~ 中
   #+BEGIN_SRC java
     /**
      ,* Check whether this factory's bean creation phase already started,
      ,* i.e. whether any bean has been marked as created in the meantime.
      ,* @since 4.2.2
      ,* @see #markBeanAsCreated
      ,*/
     protected boolean hasBeanCreationStarted() {
         return !this.alreadyCreated.isEmpty();
     }
   #+END_SRC

   父类 ~AbstractBeanFactory~ 中定义了一个集合记录正在创建的 Bean
   #+BEGIN_SRC java
     /** Names of beans that have already been created at least once. */
     private final Set<String> alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap<>(256));
   #+END_SRC

   创建时通过 ~markBeanAsCreated(...)~ 方法标记，注意对 ~alreadyCreated~ 的访问
   是需要加锁的
   #+BEGIN_SRC java
     /**
      ,* Mark the specified bean as already created (or about to be created).
      ,* <p>This allows the bean factory to optimize its caching for repeated
      ,* creation of the specified bean.
      ,* @param beanName the name of the bean
      ,*/
     protected void markBeanAsCreated(String beanName) {
         if (!this.alreadyCreated.contains(beanName)) {
             synchronized (this.mergedBeanDefinitions) {
                 if (!this.alreadyCreated.contains(beanName)) {
                     // Let the bean definition get re-merged now that we're actually creating
                     // the bean... just in case some of its metadata changed in the meantime.
                     clearMergedBeanDefinition(beanName);
                     this.alreadyCreated.add(beanName);
                 }
             }
         }
     }
   #+END_SRC

** BeanDefinition 移除的实现
   BeanDefinition 的移除方法如下，通过 ~removeBeanDefinition(...)~ 方法
   #+BEGIN_SRC java
     @Override
     public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
         Assert.hasText(beanName, "'beanName' must not be empty");

         BeanDefinition bd = this.beanDefinitionMap.remove(beanName);
         if (bd == null) {
             if (logger.isTraceEnabled()) {
                 logger.trace("No bean named '" + beanName + "' found in " + this);
             }
             throw new NoSuchBeanDefinitionException(beanName);
         }

         if (hasBeanCreationStarted()) {
             // Cannot modify startup-time collection elements anymore (for stable iteration)
             synchronized (this.beanDefinitionMap) {
                 List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);
                 updatedDefinitions.remove(beanName);
                 this.beanDefinitionNames = updatedDefinitions;
             }
         }
         else {
             // Still in startup registration phase
             this.beanDefinitionNames.remove(beanName);
         }
         this.frozenBeanDefinitionNames = null;

         resetBeanDefinition(beanName);
     }
   #+END_SRC

   移除 BeanDefinition 中调用了刷新 BeanDefinition 的方法
   ~resetBeanDefinition(...)~
   #+BEGIN_SRC java
     /**
      ,* Reset all bean definition caches for the given bean,
      ,* including the caches of beans that are derived from it.
      ,* <p>Called after an existing bean definition has been replaced or removed,
      ,* triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}
      ,* and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the
      ,* given bean and on all bean definitions that have the given bean as parent.
      ,* @param beanName the name of the bean to reset
      ,* @see #registerBeanDefinition
      ,* @see #removeBeanDefinition
      ,*/
     protected void resetBeanDefinition(String beanName) {
         // Remove the merged bean definition for the given bean, if already created.
         clearMergedBeanDefinition(beanName);

         // Remove corresponding bean from singleton cache, if any. Shouldn't usually
         // be necessary, rather just meant for overriding a context's default beans
         // (e.g. the default StaticMessageSource in a StaticApplicationContext).
         destroySingleton(beanName);

         // Notify all post-processors that the specified bean definition has been reset.
         for (BeanPostProcessor processor : getBeanPostProcessors()) {
             if (processor instanceof MergedBeanDefinitionPostProcessor) {
                 ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);
             }
         }

         // Reset all bean definitions that have the given bean as parent (recursively).
         for (String bdName : this.beanDefinitionNames) {
             if (!beanName.equals(bdName)) {
                 BeanDefinition bd = this.beanDefinitionMap.get(bdName);
                 // Ensure bd is non-null due to potential concurrent modification
                 // of the beanDefinitionMap.
                 if (bd != null && beanName.equals(bd.getParentName())) {
                     resetBeanDefinition(bdName);
                 }
             }
         }
     }
   #+END_SRC

** BeanDefinition 获取的实现
   ~DefaultListableBeanFactory~ 的实现获取 BeanDefinition 的逻辑如下
   #+BEGIN_SRC java
     @Override
     public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
         BeanDefinition bd = this.beanDefinitionMap.get(beanName);
         if (bd == null) {
             if (logger.isTraceEnabled()) {
                 logger.trace("No bean named '" + beanName + "' found in " + this);
             }
             throw new NoSuchBeanDefinitionException(beanName);
         }
         return bd;
     }
   #+END_SRC

** ~<bean/>~ 标签解析
   之前在 BeanDefinition 自动加载流程中忽略了对 ~<bean/>~ 标签的解析，其核心实现
   逻辑 ~BeanDefinitionDocumentReader~ 类中的 ~processBeanDefinition(...)~ 方法
   #+BEGIN_SRC java
     /**
      ,* Process the given bean element, parsing the bean definition
      ,* and registering it with the registry.
      ,*/
     protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
         BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
         if (bdHolder != null) {
             bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
             try {
                 // Register the final decorated instance.
                 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
             }
             catch (BeanDefinitionStoreException ex) {
                 getReaderContext().error("Failed to register bean definition with name '" +
                         bdHolder.getBeanName() + "'", ele, ex);
             }
             // Send registration event.
             getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
         }
     }
   #+END_SRC

   可以看出对 XML 标签的解析核心逻辑为 ~parseBeanDefinitionElement(...)~
   #+BEGIN_SRC java
     /**
      ,* Parses the supplied {@code <bean>} element. May return {@code null}
      ,* if there were errors during parse. Errors are reported to the
      ,* {@link org.springframework.beans.factory.parsing.ProblemReporter}.
      ,*/
     @Nullable
     public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
         String id = ele.getAttribute(ID_ATTRIBUTE);
         String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

         List<String> aliases = new ArrayList<>();
         if (StringUtils.hasLength(nameAttr)) {
             String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
             aliases.addAll(Arrays.asList(nameArr));
         }

         String beanName = id;
         if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
             beanName = aliases.remove(0);
             if (logger.isTraceEnabled()) {
                 logger.trace("No XML 'id' specified - using '" + beanName +
                         "' as bean name and " + aliases + " as aliases");
             }
         }

         if (containingBean == null) {
             checkNameUniqueness(beanName, aliases, ele);
         }

         AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
         if (beanDefinition != null) {
             if (!StringUtils.hasText(beanName)) {
                 try {
                     if (containingBean != null) {
                         beanName = BeanDefinitionReaderUtils.generateBeanName(
                                 beanDefinition, this.readerContext.getRegistry(), true);
                     }
                     else {
                         beanName = this.readerContext.generateBeanName(beanDefinition);
                         // Register an alias for the plain bean class name, if still possible,
                         // if the generator returned the class name plus a suffix.
                         // This is expected for Spring 1.2/2.0 backwards compatibility.
                         String beanClassName = beanDefinition.getBeanClassName();
                         if (beanClassName != null &&
                                 beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                                 !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                             aliases.add(beanClassName);
                         }
                     }
                     if (logger.isTraceEnabled()) {
                         logger.trace("Neither XML 'id' nor 'name' specified - " +
                                 "using generated bean name [" + beanName + "]");
                     }
                 }
                 catch (Exception ex) {
                     error(ex.getMessage(), ele);
                     return null;
                 }
             }
             String[] aliasesArray = StringUtils.toStringArray(aliases);
             return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
         }

         return null;
     }
   #+END_SRC

* Bean 实现原理
** Bean 的生命周期
   ~BeanFactory~ 的注释中完整地说明的实现标准 BeanFactory 的代码
   1. BeanFactory 初始化过程，支持的标准 Bean 的生命周期
      - ~BeanNameAware#setBeanName(...)~
      - ~BeanClassLoaderAware#setBeanClassLoader(...)~
      - ~BeanFactoryAware#setBeanFactory(...)~
      - ~EnvironmentAware#setEnvironment(...)~
      - ~EmbeddedValueResolverAware#setEmbeddedValueResolver(...)~
      - ~ResourceLoaderAware#setResourceLoader(...)~ 在 ApplicationContext 中
      - ~ApplicationEventPublisherAware#setApplicationEventPublisher(...)~ 在
        ApplicationContext 中
      - ~MessageSourceAware#setMessageSource(...)~ 在 ApplicationContext 中
      - ~ApplicationContextAware#setApplicationContext(...)~ 在
        ApplicationContext 中
      - ~ServletContextAware#setServletContext(...)~ 在 ApplicationContext 中
      - ~BeanPostProcessors~ 的一系列 ~postProcessBeforeInitialization(...)~ 方法
      - ~InitializingBean#afterPropertiesSet(...)~
      - a custom init-method definition
      - ~BeanPostProcessors~ 的一系列 ~postProcessAfterInitialization(...)~ 方法
   2. 关闭 BeanFactory 时，执行的 Bean 销毁方法
      - ~DestructionAwareBeanPostProcessors~ 的一系列
        ~postProcessBeforeDestruction(...)~ 方法
      - ~DisposableBean#destroy(...)~
      - a custom destroy-method definition

** Bean 的流程分析
   实例化 Bean 的方法为 ~BeanUtils#instantiateClass(...)~, 先添加断点获取调用栈
   #+BEGIN_SRC text
     instantiateClass:185, BeanUtils (org.springframework.beans)
     instantiate:87, SimpleInstantiationStrategy (org.springframework.beans.factory.support)
     instantiateBean:1312, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     createBeanInstance:1214, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     doCreateBean:557, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     createBean:517, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     lambda$doGetBean$0:323, AbstractBeanFactory (org.springframework.beans.factory.support)
     getObject:-1, 1027007693 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$29)
     getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)
     doGetBean:321, AbstractBeanFactory (org.springframework.beans.factory.support)
     getBean:207, AbstractBeanFactory (org.springframework.beans.factory.support)
     invokeBeanFactoryPostProcessors:89, PostProcessorRegistrationDelegate (org.springframework.context.support)
     invokeBeanFactoryPostProcessors:706, AbstractApplicationContext (org.springframework.context.support)
     refresh:532, AbstractApplicationContext (org.springframework.context.support)
     main:18, MyApp02 (io.github.jeanhwea.app02)
   #+END_SRC

   先分析调用栈，可以知道创建 Bean 的入口是 ~refresh()~ 方法的
   ~invokeBeanFactoryPostProcessors()~ 方法，这里牵扯到几个核心的方法
   1. ~AbstractApplicationContext#refresh()~
   2. ~AbstractBeanFactory#doGetBean(...)~
   3. ~AbstractAutowireCapableBeanFactory#instantiateBean(...)~

*** 实例化 Bean: ~instantiateBean()~ 方法
    ~instantiateBean(...)~ 实例化 Bean 主要完成如下工作
    1. 使用 InstantiationStrategy 实例化策略来实例化 Bean, Spring 中创建 Bean 有如
       下两种方式
       - 通过 ~BeanUtils.instantiateClass()~ 方法创建实例
       - 通过 ~new CglibSubclassCreator(bd, owner).instantiate(ctor, args)~ 方式
         进行创建
    2. 添加 BeanWrapper 封装 Bean 对象
       - 实现类为 ~BeanWrapperImpl~
       - ~BeanWrapperImpl~ 继承自 ~AbstractNestablePropertyAccessor~
       - ~AbstractNestablePropertyAccessor#setPropertyValue(...)~ 方法设置属性值
    #+BEGIN_SRC java
      /**
       ,* Instantiate the given bean using its default constructor.
       ,* @param beanName the name of the bean
       ,* @param mbd the bean definition for the bean
       ,* @return a BeanWrapper for the new instance
       ,*/
      protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
          try {
              Object beanInstance;
              final BeanFactory parent = this;
              if (System.getSecurityManager() != null) {
                  beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
                          getInstantiationStrategy().instantiate(mbd, beanName, parent),
                          getAccessControlContext());
              }
              else {
                  beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
              }
              BeanWrapper bw = new BeanWrapperImpl(beanInstance);
              initBeanWrapper(bw);
              return bw;
          }
          catch (Throwable ex) {
              throw new BeanCreationException(
                      mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
          }
      }
    #+END_SRC

*** 获取 Bean 实例: ~doGetBean()~ 方法
    ~doGetBean(...)~ 方法是获取 Bean 的最终处理函数，它的逻辑比较复杂，可以分成
    以下流程
    1. 获取 beanName
       - 解析带有别名的 Bean 到最终的名称
       - 去除 FactoryBean 的修饰符，即 ~&~ 前缀
    2. 缓存获取
       - 调用 ~DefaultSingletonBeanRegistry#getSingleton()~ 尝试从单例容器缓存中
         获取
       - 单例 Bean 只创建一次，创建完成直接放入缓存，参考
         ~DefaultSingletonBeanRegistry~ 的实现
       - 依赖的 Bean 避免循环依赖，只记录 ~ObjectFactory~ 对象, 参考
         ~singletonFactories~ 变量的定义及循环依赖的解决方法
    3. 创建 Bean 实例
       - 获取 FactoryBean 生成的 Bean 实例
         + FactoryBean 实例需要获取到的对象是 ~factory-method~ 返回的 Bean 对象
         + ~getObjectForBeanInstance()~ 方法实现了从 Bean 实例中获取 Bean 对象的
           逻辑，后续再说明该方法的逻辑
       - 如果不是 FactoryBean
         + 调用 ~isPrototypeCurrentlyInCreation(...)~ 判断创建原型 Bean 是否出现
           循环依赖
         + 尝试从 parentBeanFactory 中获取 Bean
         + 将 BeanDefinition 进行合并，得到 ~RootBeanDefinition~, 并检验
         + 调用 ~markBeanAsCreated()~ 方法标记创建 Bean
         + 解决 Bean 依赖
           - Bean 是动态加载的，当前待创建 Bean 的可能存在依赖项
           - 解决依赖的策略是顺序寻找出所有依赖，并完成创建
         + 通过不同的 scope 完成对应 Bean 的创建
           - 单例 Bean 创建: ~getSingleton(...)~
           - 原型 Bean 创建: ~getSingleton(...)~
           - 其它情况 Bean 创建，例如： ~@RequestScope~ ~@SessionScope~ 等
    4. 检查 Bean 实例，完成类型转换
    #+BEGIN_SRC java
      /**
       ,* Return an instance, which may be shared or independent, of the specified bean.
       ,* @param name the name of the bean to retrieve
       ,* @param requiredType the required type of the bean to retrieve
       ,* @param args arguments to use when creating a bean instance using explicit arguments
       ,* (only applied when creating a new instance as opposed to retrieving an existing one)
       ,* @param typeCheckOnly whether the instance is obtained for a type check,
       ,* not for actual use
       ,* @return an instance of the bean
       ,* @throws BeansException if the bean could not be created
       ,*/
      @SuppressWarnings("unchecked")
      protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
              @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

          final String beanName = transformedBeanName(name);
          Object bean;

          // Eagerly check singleton cache for manually registered singletons.
          Object sharedInstance = getSingleton(beanName);
          if (sharedInstance != null && args == null) {
              if (logger.isTraceEnabled()) {
                  if (isSingletonCurrentlyInCreation(beanName)) {
                      logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                              "' that is not fully initialized yet - a consequence of a circular reference");
                  }
                  else {
                      logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                  }
              }
              bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
          }

          else {
              // Fail if we're already creating this bean instance:
              // We're assumably within a circular reference.
              if (isPrototypeCurrentlyInCreation(beanName)) {
                  throw new BeanCurrentlyInCreationException(beanName);
              }

              // Check if bean definition exists in this factory.
              BeanFactory parentBeanFactory = getParentBeanFactory();
              if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
                  // Not found -> check parent.
                  String nameToLookup = originalBeanName(name);
                  if (parentBeanFactory instanceof AbstractBeanFactory) {
                      return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                              nameToLookup, requiredType, args, typeCheckOnly);
                  }
                  else if (args != null) {
                      // Delegation to parent with explicit args.
                      return (T) parentBeanFactory.getBean(nameToLookup, args);
                  }
                  else if (requiredType != null) {
                      // No args -> delegate to standard getBean method.
                      return parentBeanFactory.getBean(nameToLookup, requiredType);
                  }
                  else {
                      return (T) parentBeanFactory.getBean(nameToLookup);
                  }
              }

              if (!typeCheckOnly) {
                  markBeanAsCreated(beanName);
              }

              try {
                  final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                  checkMergedBeanDefinition(mbd, beanName, args);

                  // Guarantee initialization of beans that the current bean depends on.
                  String[] dependsOn = mbd.getDependsOn();
                  if (dependsOn != null) {
                      for (String dep : dependsOn) {
                          if (isDependent(beanName, dep)) {
                              throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                      "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                          }
                          registerDependentBean(dep, beanName);
                          try {
                              getBean(dep);
                          }
                          catch (NoSuchBeanDefinitionException ex) {
                              throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                      "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                          }
                      }
                  }

                  // Create bean instance.
                  if (mbd.isSingleton()) {
                      sharedInstance = getSingleton(beanName, () -> {
                          try {
                              return createBean(beanName, mbd, args);
                          }
                          catch (BeansException ex) {
                              // Explicitly remove instance from singleton cache: It might have been put there
                              // eagerly by the creation process, to allow for circular reference resolution.
                              // Also remove any beans that received a temporary reference to the bean.
                              destroySingleton(beanName);
                              throw ex;
                          }
                      });
                      bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                  }

                  else if (mbd.isPrototype()) {
                      // It's a prototype -> create a new instance.
                      Object prototypeInstance = null;
                      try {
                          beforePrototypeCreation(beanName);
                          prototypeInstance = createBean(beanName, mbd, args);
                      }
                      finally {
                          afterPrototypeCreation(beanName);
                      }
                      bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                  }

                  else {
                      String scopeName = mbd.getScope();
                      final Scope scope = this.scopes.get(scopeName);
                      if (scope == null) {
                          throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                      }
                      try {
                          Object scopedInstance = scope.get(beanName, () -> {
                              beforePrototypeCreation(beanName);
                              try {
                                  return createBean(beanName, mbd, args);
                              }
                              finally {
                                  afterPrototypeCreation(beanName);
                              }
                          });
                          bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                      }
                      catch (IllegalStateException ex) {
                          throw new BeanCreationException(beanName,
                                  "Scope '" + scopeName + "' is not active for the current thread; consider " +
                                  "defining a scoped proxy for this bean if you intend to refer to it from a singleton",
                                  ex);
                      }
                  }
              }
              catch (BeansException ex) {
                  cleanupAfterBeanCreationFailure(beanName);
                  throw ex;
              }
          }

          // Check if required type matches the type of the actual bean instance.
          if (requiredType != null && !requiredType.isInstance(bean)) {
              try {
                  T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                  if (convertedBean == null) {
                      throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                  }
                  return convertedBean;
              }
              catch (TypeMismatchException ex) {
                  if (logger.isTraceEnabled()) {
                      logger.trace("Failed to convert bean '" + name + "' to required type '" +
                              ClassUtils.getQualifiedName(requiredType) + "'", ex);
                  }
                  throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
              }
          }
          return (T) bean;
      }
    #+END_SRC
** 特殊的 Spring Bean: FactoryBean
   FactoryBean 不同于普通的 Bean， FactoryBean 自身就是一个组装 Bean 的微型工厂，
   即在调用 ~BeanFactory#getBean(...)~ 方法时不返回 FactoryBean，而是返回工厂方
   法返回的 Bean，定义 FactoryBean 只需要实现 ~FactoryBean~ 接口即可

   #+BEGIN_SRC java
     public interface FactoryBean<T> {
         @Nullable
         T getObject() throws Exception;

         @Nullable
         Class<?> getObjectType();

         default boolean isSingleton() {
             return true;
         }
     }
   #+END_SRC
   1. ~getObject(...)~ 方法返回 FactoryBean 创建的实例，也称工厂方法
   2. ~getObjectType(...)~ 方法返回 FactoryBean 创建的实例的类型
   3. ~isSingleton(...)~ 方法返回 FactoryBean 创建的实例的 Scope

** 单例 Bean 工厂的实现
*** 单例 Bean 工厂的三级缓存: ~DefaultSingletonBeanRegistry~ 类的缓存
    ~DefaultSingletonBeanRegistry~ 是对单例 Bean 注册的实现类，它的继承关系如下
    #+BEGIN_SRC text
      org.springframework.beans.factory.support
      Class DefaultSingletonBeanRegistry

          java.lang.Object
              org.springframework.core.SimpleAliasRegistry
                  org.springframework.beans.factory.support.DefaultSingletonBeanRegistry

          All Implemented Interfaces:
              SingletonBeanRegistry, org.springframework.core.AliasRegistry
    #+END_SRC

    ~DefaultSingletonBeanRegistry~ 定义了如下成员变量
    #+BEGIN_SRC java
      /** Cache of singleton objects: bean name to bean instance. */
      private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

      /** Cache of singleton factories: bean name to ObjectFactory. */
      private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

      /** Cache of early singleton objects: bean name to bean instance. */
      private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);

      /** Set of registered singletons, containing the bean names in registration order. */
      private final Set<String> registeredSingletons = new LinkedHashSet<>(256);

      /** Names of beans that are currently in creation. */
      private final Set<String> singletonsCurrentlyInCreation =
              Collections.newSetFromMap(new ConcurrentHashMap<>(16));

      /** Names of beans currently excluded from in creation checks. */
      private final Set<String> inCreationCheckExclusions =
              Collections.newSetFromMap(new ConcurrentHashMap<>(16));

      /** List of suppressed Exceptions, available for associating related causes. */
      @Nullable
      private Set<Exception> suppressedExceptions;

      /** Flag that indicates whether we're currently within destroySingletons. */
      private boolean singletonsCurrentlyInDestruction = false;

      /** Disposable bean instances: bean name to disposable instance. */
      private final Map<String, Object> disposableBeans = new LinkedHashMap<>();

      /** Map between containing bean names: bean name to Set of bean names that the bean contains. */
      private final Map<String, Set<String>> containedBeanMap = new ConcurrentHashMap<>(16);

      /** Map between dependent bean names: bean name to Set of dependent bean names. */
      private final Map<String, Set<String>> dependentBeanMap = new ConcurrentHashMap<>(64);

      /** Map between depending bean names: bean name to Set of bean names for the bean's dependencies. */
      private final Map<String, Set<String>> dependenciesForBeanMap = new ConcurrentHashMap<>(64);
    #+END_SRC
    这里需要注意的是其定义的三级缓存结构
    1. singletonObjects: 一级缓存单例 Bean 对象
    2. earlySingletonObjects: 二级缓存早期创建的单例 Bean 对象
       - earlySingletonObjects 于 singletonObjects 不同之处是，当一个单例 Bean
         还在创建过程中可以将其依赖的单例 Bean 放入 earlySingletonObjects 哈希表
         内
       - 这样做，即使单例 Bean 在创建过程中，调用 ~getBean(...)~ 方法依然可以获
         取到所依赖的 Bean 对象
       - 另外该方案用来循环检测，避免循环依赖
    3. singletonFactories: 三级缓存单例对象工厂 ObjectFactory
       - singletonFactories 哈希表的值是 ~ObjectFactory~ 接口类型
       - ~ObjectFactory~ 是个函数式接口，用于延迟创建 Bean
       #+BEGIN_SRC java
         @FunctionalInterface
         public interface ObjectFactory<T> {

             /**
              ,* Return an instance (possibly shared or independent)
              ,* of the object managed by this factory.
              ,* @return the resulting instance
              ,* @throws BeansException in case of creation errors
              ,*/
             T getObject() throws BeansException;

         }
       #+END_SRC

*** 获取单例 Bean 方法: ~getSingleton(...)~ 方法
    ~getSingleton()~ 方法是获取 Bean 的核心方法, 它的实现如下
    #+BEGIN_SRC java
      // 获取单例，可以从 earlySingletonObjects 中获取
      public Object getSingleton(String beanName) {
          return getSingleton(beanName, true);
      }

      // 获取单例，添加是否可以从 earlySingletonObjects 中获取参数
      @Nullable
      protected Object getSingleton(String beanName, boolean allowEarlyReference) {
          Object singletonObject = this.singletonObjects.get(beanName);
          if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
              synchronized (this.singletonObjects) {
                  singletonObject = this.earlySingletonObjects.get(beanName);
                  if (singletonObject == null && allowEarlyReference) {
                      ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                      if (singletonFactory != null) {
                          singletonObject = singletonFactory.getObject();
                          this.earlySingletonObjects.put(beanName, singletonObject);
                          this.singletonFactories.remove(beanName);
                      }
                  }
              }
          }
          return singletonObject;
      }
    #+END_SRC
    允许从 earlySingletonObjects 获取单例的 ~getSingleton(...)~ 方法逻辑比较清晰
    1. 先尝试从 singletonObjects 中获取 singletonObject, 如果成功直接返回
       singletonObject
    2. 如果获取失败，则尝试从 earlySingletonObjects 中获取 singletonObject, 如果
       成功直接返回 singletonObject
    3. 如果再次失败，尝试从 singletonFactories 中创建 singletonObject，并返回创
       建结果
       - 首先通过 beanName, 查找到 ~ObjectFactory~ 的值, 即 singletonFactory
       - 若 singletonFactory 存在，调用 ~singletonFactory.getObject(...)~ 方法创
         建 singletonObject
       - 创建成功将 singletonObject, 将 singletonObject 添加到
         earlySingletonObjects, 并从 singletonFactories 移除 beanName 对应的值

    #+BEGIN_SRC java
      // 获取单例，主要针对未创建的 Bean 对象，通过 ObjectFactory 创建对象并返回
      public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
          Assert.notNull(beanName, "Bean name must not be null");
          synchronized (this.singletonObjects) {
              Object singletonObject = this.singletonObjects.get(beanName);
              if (singletonObject == null) {
                  if (this.singletonsCurrentlyInDestruction) {
                      throw new BeanCreationNotAllowedException(beanName,
                              "Singleton bean creation not allowed while singletons of this factory are in destruction " +
                              "(Do not request a bean from a BeanFactory in a destroy method implementation!)");
                  }
                  if (logger.isDebugEnabled()) {
                      logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
                  }
                  beforeSingletonCreation(beanName);
                  boolean newSingleton = false;
                  boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
                  if (recordSuppressedExceptions) {
                      this.suppressedExceptions = new LinkedHashSet<>();
                  }
                  try {
                      singletonObject = singletonFactory.getObject();
                      newSingleton = true;
                  }
                  catch (IllegalStateException ex) {
                      // Has the singleton object implicitly appeared in the meantime ->
                      // if yes, proceed with it since the exception indicates that state.
                      singletonObject = this.singletonObjects.get(beanName);
                      if (singletonObject == null) {
                          throw ex;
                      }
                  }
                  catch (BeanCreationException ex) {
                      if (recordSuppressedExceptions) {
                          for (Exception suppressedException : this.suppressedExceptions) {
                              ex.addRelatedCause(suppressedException);
                          }
                      }
                      throw ex;
                  }
                  finally {
                      if (recordSuppressedExceptions) {
                          this.suppressedExceptions = null;
                      }
                      afterSingletonCreation(beanName);
                  }
                  if (newSingleton) {
                      addSingleton(beanName, singletonObject);
                  }
              }
              return singletonObject;
          }
      }
    #+END_SRC

    获取单例 Bean 的总逻辑逻辑如下
    1. 首先尝试从 singletonObjects 获取 singletonObject, 获取成功直接返回
       singletonObject
    2. 如果 singletonObjects 获取失败，则需要创建 singletonObject
       - 先调用 ~beforeSingletonCreation(...)~ 前置钩子函数
       - 调用 ~ObjectFactory~ 的 ~getObject(...)~ 方法来创建 singletonObject
       - 然后调用 ~afterSingletonCreation(...)~ 后置钩子函数
       - 如果有信创建的 singletonObject, 调用 ~addSingleton(...)~ 来处理添加新创
         建 singletonObject
         #+BEGIN_SRC java
           protected void addSingleton(String beanName, Object singletonObject) {
               synchronized (this.singletonObjects) {
                   this.singletonObjects.put(beanName, singletonObject);
                   this.singletonFactories.remove(beanName);
                   this.earlySingletonObjects.remove(beanName);
                   this.registeredSingletons.add(beanName);
               }
           }
         #+END_SRC
         + ~addSingleton(...)~ 将新创建的 singletonObject 放入 singletonObjects,
           并从 singletonFactories 和 earlySingletonObjects 中移除
           singletonObject 对象
         + 将 singletonObject 添加到 registeredSingletons 中，完成 Bean 的注册

*** beanInstance 到 beanOject 过程: ~getObjectForBeanInstance(...)~ 方法
    beanInstance -> beanOject 是将缓存中的 Bean 实例转化成最终用户所需对象的过程，
    1. 在 ~doGetBean(...)~ 方法中的 ~getObjectForBeanInstance(...)~ 方法实现
    2. beanInstance 如果是非 FactoryBean, beanInstance 即为 beanOject, 直接返回
       创建好的 Bean 对象
    3. beanInstance 如果是 FactoryBean, 需要调用工厂方法进行处理，创建 beanOject
       - 先调用 ~getCachedObjectForFactoryBean(...)~ 从缓存中获取，获取成功直接
         返回结果
       - 如果未获取成功，调用 ~getObjectFromFactoryBean(...)~ 创建 beanOject
       - 最终通过 ~doGetObjectFromFactoryBean(...)~ 完成调用工厂方法并获取
         beanObject 逻辑

    这里分析一下 ~doGetObjectFromFactoryBean(...)~ 的逻辑，先查看一下调用栈
    #+BEGIN_SRC text
      doGetObjectFromFactoryBean:161, FactoryBeanRegistrySupport (org.springframework.beans.factory.support)
      getObjectFromFactoryBean:101, FactoryBeanRegistrySupport (org.springframework.beans.factory.support)
      getObjectForBeanInstance:1818, AbstractBeanFactory (org.springframework.beans.factory.support)
      getObjectForBeanInstance:1266, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
      doGetBean:260, AbstractBeanFactory (org.springframework.beans.factory.support)
      getBean:202, AbstractBeanFactory (org.springframework.beans.factory.support)
      getBean:1108, AbstractApplicationContext (org.springframework.context.support)
      main:25, MyApp04 (io.github.jeanhwea.app04_factory_bean)
    #+END_SRC

    ~doGetObjectFromFactoryBean(...)~ 方法逻辑如下，可以看出在进行了一些校验工作，
    最终调用 ~factory.getObject()~ 方法获取 beanObject
    #+BEGIN_SRC java
      /**
       ,* Obtain an object to expose from the given FactoryBean.
       ,* @param factory the FactoryBean instance
       ,* @param beanName the name of the bean
       ,* @return the object obtained from the FactoryBean
       ,* @throws BeanCreationException if FactoryBean object creation failed
       ,* @see org.springframework.beans.factory.FactoryBean#getObject()
       ,*/
      private Object doGetObjectFromFactoryBean(final FactoryBean<?> factory, final String beanName)
              throws BeanCreationException {

          Object object;
          try {
              if (System.getSecurityManager() != null) {
                  AccessControlContext acc = getAccessControlContext();
                  try {
                      object = AccessController.doPrivileged((PrivilegedExceptionAction<Object>) factory::getObject, acc);
                  }
                  catch (PrivilegedActionException pae) {
                      throw pae.getException();
                  }
              }
              else {
                  object = factory.getObject();
              }
          }
          catch (FactoryBeanNotInitializedException ex) {
              throw new BeanCurrentlyInCreationException(beanName, ex.toString());
          }
          catch (Throwable ex) {
              throw new BeanCreationException(beanName, "FactoryBean threw exception on object creation", ex);
          }

          // Do not accept a null value for a FactoryBean that's not fully
          // initialized yet: Many FactoryBeans just return null then.
          if (object == null) {
              if (isSingletonCurrentlyInCreation(beanName)) {
                  throw new BeanCurrentlyInCreationException(
                          beanName, "FactoryBean which is currently in creation returned null from getObject");
              }
              object = new NullBean();
          }
          return object;
      }
    #+END_SRC

    往上跳一级，查看 ~FactoryBeanRegistrySupport#getObjectFromFactoryBean(...)~ 方法
    #+BEGIN_SRC java
      /**
       ,* Obtain an object to expose from the given FactoryBean.
       ,* @param factory the FactoryBean instance
       ,* @param beanName the name of the bean
       ,* @param shouldPostProcess whether the bean is subject to post-processing
       ,* @return the object obtained from the FactoryBean
       ,* @throws BeanCreationException if FactoryBean object creation failed
       ,* @see org.springframework.beans.factory.FactoryBean#getObject()
       ,*/
      protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
          if (factory.isSingleton() && containsSingleton(beanName)) {
              synchronized (getSingletonMutex()) {
                  Object object = this.factoryBeanObjectCache.get(beanName);
                  if (object == null) {
                      object = doGetObjectFromFactoryBean(factory, beanName);
                      // Only post-process and store if not put there already during getObject() call above
                      // (e.g. because of circular reference processing triggered by custom getBean calls)
                      Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
                      if (alreadyThere != null) {
                          object = alreadyThere;
                      }
                      else {
                          if (shouldPostProcess) {
                              if (isSingletonCurrentlyInCreation(beanName)) {
                                  // Temporarily return non-post-processed object, not storing it yet..
                                  return object;
                              }
                              beforeSingletonCreation(beanName);
                              try {
                                  object = postProcessObjectFromFactoryBean(object, beanName);
                              }
                              catch (Throwable ex) {
                                  throw new BeanCreationException(beanName,
                                          "Post-processing of FactoryBean's singleton object failed", ex);
                              }
                              finally {
                                  afterSingletonCreation(beanName);
                              }
                          }
                          if (containsSingleton(beanName)) {
                              this.factoryBeanObjectCache.put(beanName, object);
                          }
                      }
                  }
                  return object;
              }
          }
          else {
              Object object = doGetObjectFromFactoryBean(factory, beanName);
              if (shouldPostProcess) {
                  try {
                      object = postProcessObjectFromFactoryBean(object, beanName);
                  }
                  catch (Throwable ex) {
                      throw new BeanCreationException(beanName, "Post-processing of FactoryBean's object failed", ex);
                  }
              }
              return object;
          }
      }
    #+END_SRC
    ~getObjectFromFactoryBean~ 实现了获取 FactoryBean 的 beanObject 的业务逻辑
    1. 如果是非单例 FactoryBean，在最外层的 else 代码，直接创建 beanObject
    2. 如果是单例 FactoryBean
       - 首先获取单例缓存池 singletonObjects 的互斥锁
       - 尝试从 factoryBeanObjectCache 缓存中获取创建好的 beanObject, 如果成功
         直接返回结果
       - 如果缓存获取失败，则需要调用 ~doGetObjectFromFactoryBean(...)~ 方法创
         建 beanObject，并将创建好的 beanObject 放入 factoryBeanObjectCache 缓
         存中
    3. 在上述两种情况过后都需要调用 ~postProcessObjectFromFactoryBean(...)~ 方法
       - ~postProcessObjectFromFactoryBean(...)~ 是一个空方法
       - 这样设计是为子类提供扩展点

** Bean 生命周期的实现
*** Bean 创建的实现类: ~AbstractAutowireCapableBeanFactory~
    先看 ~AbstractAutowireCapableBeanFactory~ 的类继承关系
    #+BEGIN_SRC text
      org.springframework.beans.factory.support
      Class AbstractAutowireCapableBeanFactory

          java.lang.Object
              org.springframework.core.SimpleAliasRegistry
                  org.springframework.beans.factory.support.DefaultSingletonBeanRegistry
                      org.springframework.beans.factory.support.FactoryBeanRegistrySupport
                          org.springframework.beans.factory.support.AbstractBeanFactory
                              org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory

          All Implemented Interfaces:
              BeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory,
              SingletonBeanRegistry, HierarchicalBeanFactory,
              org.springframework.core.AliasRegistry
    #+END_SRC
    1. ~AbstractAutowireCapableBeanFactory~ 实现了 ~AutowireCapableBeanFactory~ 接口
    2. ~AutowireCapableBeanFactory~ 中有管理 Autowire 功能 Bean 的方法
       - ~createBean(...)~ 实例化 Bean
       - ~initializeBean(...)~ 初始化 Bean
       - ~destroyBean(...)~ 销毁 Bean
       - 还有一些 Bean 的 ~*PostProcessor*~ 的增强函数
       #+BEGIN_SRC java
         public interface AutowireCapableBeanFactory extends BeanFactory {
             //-------------------------------------------------------------------------
             // Typical methods for creating and populating external bean instances
             //-------------------------------------------------------------------------
             <T> T createBean(Class<T> beanClass) throws BeansException;
             void autowireBean(Object existingBean) throws BeansException;
             Object configureBean(Object existingBean, String beanName) throws BeansException;

             //-------------------------------------------------------------------------
             // Specialized methods for fine-grained control over the bean lifecycle
             //-------------------------------------------------------------------------
             Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
             Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
             void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)
                     throws BeansException;
             void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;
             Object initializeBean(Object existingBean, String beanName) throws BeansException;
             Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
                     throws BeansException;
             Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
                     throws BeansException;
             void destroyBean(Object existingBean);

             //-------------------------------------------------------------------------
             // Delegate methods for resolving injection points
             //-------------------------------------------------------------------------
             <T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException;
             Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException;
             @Nullable
             Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException;
             @Nullable
             Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
                     @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException;
         }
       #+END_SRC
*** Bean 的实例化: ~createBean(...)~ 方法
    实际实例化 Bean 是在 ~doCreateBean(...)~ 方法中完成的，先准备一下调用栈
    #+BEGIN_SRC text
      doCreateBean:552, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
      createBean:517, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
      lambda$doGetBean$0:323, AbstractBeanFactory (org.springframework.beans.factory.support)
      getObject:-1, 1989335500 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$37)
      getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)
      doGetBean:321, AbstractBeanFactory (org.springframework.beans.factory.support)
      getBean:207, AbstractBeanFactory (org.springframework.beans.factory.support)
      invokeBeanFactoryPostProcessors:89, PostProcessorRegistrationDelegate (org.springframework.context.support)
      invokeBeanFactoryPostProcessors:706, AbstractApplicationContext (org.springframework.context.support)
      refresh:532, AbstractApplicationContext (org.springframework.context.support)
      <init>:101, AnnotationConfigApplicationContext (org.springframework.context.annotation)
      main:21, MyApp04 (io.github.jeanhwea.app04_factory_bean)
    #+END_SRC

    ~createBean(...)~ 方法实现如下
    #+BEGIN_SRC java
      /**
       ,* Central method of this class: creates a bean instance,
       ,* populates the bean instance, applies post-processors, etc.
       ,* @see #doCreateBean
       ,*/
      @Override
      protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
              throws BeanCreationException {

          if (logger.isTraceEnabled()) {
              logger.trace("Creating instance of bean '" + beanName + "'");
          }
          RootBeanDefinition mbdToUse = mbd;

          // Make sure bean class is actually resolved at this point, and
          // clone the bean definition in case of a dynamically resolved Class
          // which cannot be stored in the shared merged bean definition.
          Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
          if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
              mbdToUse = new RootBeanDefinition(mbd);
              mbdToUse.setBeanClass(resolvedClass);
          }

          // Prepare method overrides.
          try {
              mbdToUse.prepareMethodOverrides();
          }
          catch (BeanDefinitionValidationException ex) {
              throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                      beanName, "Validation of method overrides failed", ex);
          }

          try {
              // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
              Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
              if (bean != null) {
                  return bean;
              }
          }
          catch (Throwable ex) {
              throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                      "BeanPostProcessor before instantiation of bean failed", ex);
          }

          try {
              Object beanInstance = doCreateBean(beanName, mbdToUse, args);
              if (logger.isTraceEnabled()) {
                  logger.trace("Finished creating instance of bean '" + beanName + "'");
              }
              return beanInstance;
          }
          catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
              // A previously detected exception with proper bean creation context already,
              // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
              throw ex;
          }
          catch (Throwable ex) {
              throw new BeanCreationException(
                      mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
          }
      }

    #+END_SRC
    该方法的流程如下
    1. 通过 BeanDefinition 和 beanName 解析获取到待创建的类 resolvedClass
    2. 对 override 属性进行标记及验证
       - ~lookup-method~, ~replace-method~ 等
    3. 处理 BeanPostProcessors, 进行一些前置处理工作
       - ~resolveBeforeInstantiation(...)~ 方法完成前置处理工作
         #+BEGIN_SRC java
           /**
            ,* Apply before-instantiation post-processors, resolving whether there is a
            ,* before-instantiation shortcut for the specified bean.
            ,* @param beanName the name of the bean
            ,* @param mbd the bean definition for the bean
            ,* @return the shortcut-determined bean instance, or {@code null} if none
            ,*/
           @Nullable
           protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
               Object bean = null;
               if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
                   // Make sure bean class is actually resolved at this point.
                   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
                       Class<?> targetType = determineTargetType(beanName, mbd);
                       if (targetType != null) {
                           bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
                           if (bean != null) {
                               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
                           }
                       }
                   }
                   mbd.beforeInstantiationResolved = (bean != null);
               }
               return bean;
           }
         #+END_SRC
       - ~applyBeanPostProcessorsBeforeInstantiation(...)~ 方法在实例化前调用
       - ~applyBeanPostProcessorsAfterInitialization(...)~ 方法在初始化后调用
    5. 调用 ~doCreateBean(...)~ 创建 Bean 实例 beanInstance, 并返回 beanInstance

   ~doCreateBean(...)~ 方法实现如下
   #+BEGIN_SRC java
     /**
      ,* Actually create the specified bean. Pre-creation processing has already happened
      ,* at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.
      ,* <p>Differentiates between default bean instantiation, use of a
      ,* factory method, and autowiring a constructor.
      ,* @param beanName the name of the bean
      ,* @param mbd the merged bean definition for the bean
      ,* @param args explicit arguments to use for constructor or factory method invocation
      ,* @return a new instance of the bean
      ,* @throws BeanCreationException if the bean could not be created
      ,* @see #instantiateBean
      ,* @see #instantiateUsingFactoryMethod
      ,* @see #autowireConstructor
      ,*/
     protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
             throws BeanCreationException {

         // Instantiate the bean.
         BeanWrapper instanceWrapper = null;
         if (mbd.isSingleton()) {
             instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
         }
         if (instanceWrapper == null) {
             instanceWrapper = createBeanInstance(beanName, mbd, args);
         }
         final Object bean = instanceWrapper.getWrappedInstance();
         Class<?> beanType = instanceWrapper.getWrappedClass();
         if (beanType != NullBean.class) {
             mbd.resolvedTargetType = beanType;
         }

         // Allow post-processors to modify the merged bean definition.
         synchronized (mbd.postProcessingLock) {
             if (!mbd.postProcessed) {
                 try {
                     applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                 }
                 catch (Throwable ex) {
                     throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                             "Post-processing of merged bean definition failed", ex);
                 }
                 mbd.postProcessed = true;
             }
         }

         // Eagerly cache singletons to be able to resolve circular references
         // even when triggered by lifecycle interfaces like BeanFactoryAware.
         boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                 isSingletonCurrentlyInCreation(beanName));
         if (earlySingletonExposure) {
             if (logger.isTraceEnabled()) {
                 logger.trace("Eagerly caching bean '" + beanName +
                         "' to allow for resolving potential circular references");
             }
             addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
         }

         // Initialize the bean instance.
         Object exposedObject = bean;
         try {
             populateBean(beanName, mbd, instanceWrapper);
             exposedObject = initializeBean(beanName, exposedObject, mbd);
         }
         catch (Throwable ex) {
             if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
                 throw (BeanCreationException) ex;
             }
             else {
                 throw new BeanCreationException(
                         mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
             }
         }

         if (earlySingletonExposure) {
             Object earlySingletonReference = getSingleton(beanName, false);
             if (earlySingletonReference != null) {
                 if (exposedObject == bean) {
                     exposedObject = earlySingletonReference;
                 }
                 else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                     String[] dependentBeans = getDependentBeans(beanName);
                     Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                     for (String dependentBean : dependentBeans) {
                         if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                             actualDependentBeans.add(dependentBean);
                         }
                     }
                     if (!actualDependentBeans.isEmpty()) {
                         throw new BeanCurrentlyInCreationException(beanName,
                                 "Bean with name '" + beanName + "' has been injected into other beans [" +
                                 StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                 "] in its raw version as part of a circular reference, but has eventually been " +
                                 "wrapped. This means that said other beans do not use the final version of the " +
                                 "bean. This is often the result of over-eager type matching - consider using " +
                                 "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
                     }
                 }
             }
         }

         // Register bean as disposable.
         try {
             registerDisposableBeanIfNecessary(beanName, bean, mbd);
         }
         catch (BeanDefinitionValidationException ex) {
             throw new BeanCreationException(
                     mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
         }

         return exposedObject;
     }
   #+END_SRC
   该方法实现流程如下
   1. 如果是单例 Bean, 首先清理缓存
   2. 通过 ~createBeanInstance(...)~ 方法将 BeanDefinition 转化成 BeanWrapper,
      BeanWrapper 的作用如下
      - 如果检测到 Supplier, 使用 Supplier 进行实例化，具体实现见
        ~obtainFromSupplier(...)~ 方法
      - 如果存在工厂方法, 则使用工厂方法进行实例化, 具体实现见
        ~instantiateUsingFactoryMethod(...)~
      - 如果包含多参数构造器，根据参数类型锁定的构造方法，然后调用进行实例化，具
        体实现见 ~autowireConstructor(...)~ 方法
      - 其它情况使用无参构造器进行实例化, 具体实现见 ~instantiateBean(...)~ 方法
   3. 允许后置处理器合并 BeanDefinition
   4. 解决依赖，若有依赖项调用 ~addSingletonFactory(...)~ 添加到
      singletonFactories 缓存中
   5. 调用 ~populateBean(...)~ 方法进行属性填充
   6. 调用 ~initializeBean(...)~ 方法进行初始化
   7. 循环依赖检测
      - 只检测单例 Bean 的循环依赖
      - 原型 Bean 的循环检测很难做到，Spring 做法是直接抛出异常
   8. 注册 DisposableBean
      - 便于 destroy-method 在Bean销毁时调用
   9. 完成创建并返回

*** Bean 的初始化: ~initializeBean(...)~ 方法
    #+BEGIN_SRC java
      /**
       ,* Initialize the given bean instance, applying factory callbacks
       ,* as well as init methods and bean post processors.
       ,* <p>Called from {@link #createBean} for traditionally defined beans,
       ,* and from {@link #initializeBean} for existing bean instances.
       ,* @param beanName the bean name in the factory (for debugging purposes)
       ,* @param bean the new bean instance we may need to initialize
       ,* @param mbd the bean definition that the bean was created with
       ,* (can also be {@code null}, if given an existing bean instance)
       ,* @return the initialized bean instance (potentially wrapped)
       ,* @see BeanNameAware
       ,* @see BeanClassLoaderAware
       ,* @see BeanFactoryAware
       ,* @see #applyBeanPostProcessorsBeforeInitialization
       ,* @see #invokeInitMethods
       ,* @see #applyBeanPostProcessorsAfterInitialization
       ,*/
      protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
          if (System.getSecurityManager() != null) {
              AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                  invokeAwareMethods(beanName, bean);
                  return null;
              }, getAccessControlContext());
          }
          else {
              invokeAwareMethods(beanName, bean);
          }

          Object wrappedBean = bean;
          if (mbd == null || !mbd.isSynthetic()) {
              wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
          }

          try {
              invokeInitMethods(beanName, wrappedBean, mbd);
          }
          catch (Throwable ex) {
              throw new BeanCreationException(
                      (mbd != null ? mbd.getResourceDescription() : null),
                      beanName, "Invocation of init method failed", ex);
          }
          if (mbd == null || !mbd.isSynthetic()) {
              wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
          }

          return wrappedBean;
      }
    #+END_SRC
    该方法用于初始化 Bean，它完成了如下工作
    1. 调用 Aware 方法，例如
       - BeanFactoryAware
       - ApplicationContextAware
       - ResourceLoaderAware
       - ServletContextAware
    2. 提供 BeanPostProcessor 的扩展点，环绕调用了如下两个钩子方法
       - ~applyBeanPostProcessorsBeforeInitialization(...)~
       - ~applyBeanPostProcessorsAfterInitialization(...)~
    3. 调用自定义的初始化方法，及 init-method
       - ~invokeInitMethods(beanName, wrappedBean, mbd);~

*** Bean 的销毁
    在 ~doCreateBean(...)~ 方法中调用了 ~registerDisposableBeanIfNecessary(...)~
    方法来提供 ~destroy-method~ 销毁的扩展
    #+BEGIN_SRC java
      /**
       ,* Add the given bean to the list of disposable beans in this factory,
       ,* registering its DisposableBean interface and/or the given destroy method
       ,* to be called on factory shutdown (if applicable). Only applies to singletons.
       ,* @param beanName the name of the bean
       ,* @param bean the bean instance
       ,* @param mbd the bean definition for the bean
       ,* @see RootBeanDefinition#isSingleton
       ,* @see RootBeanDefinition#getDependsOn
       ,* @see #registerDisposableBean
       ,* @see #registerDependentBean
       ,*/
      protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
          AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
          if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
              if (mbd.isSingleton()) {
                  // Register a DisposableBean implementation that performs all destruction
                  // work for the given bean: DestructionAwareBeanPostProcessors,
                  // DisposableBean interface, custom destroy method.
                  registerDisposableBean(beanName,
                          new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
              }
              else {
                  // A bean with a custom scope...
                  Scope scope = this.scopes.get(mbd.getScope());
                  if (scope == null) {
                      throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
                  }
                  scope.registerDestructionCallback(beanName,
                          new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
              }
          }
      }
    #+END_SRC

* IoC
** IoC 核心接口和类
   Spring 的 IoC 容器对象一般继承自 ~ApplicationContext~ 接口，常见的对象类如下

   ~ClassPathXmlApplicationContext~: 读取 ClassPath 中 XML 配置文件的 Bean 定义
   的容器

   #+BEGIN_SRC text
     org.springframework.context.support
     Class ClassPathXmlApplicationContext

         java.lang.Object
             org.springframework.core.io.DefaultResourceLoader
                 org.springframework.context.support.AbstractApplicationContext
                     org.springframework.context.support.AbstractRefreshableApplicationContext
                         org.springframework.context.support.AbstractRefreshableConfigApplicationContext
                             org.springframework.context.support.AbstractXmlApplicationContext
                                 org.springframework.context.support.ClassPathXmlApplicationContext

         All Implemented Interfaces:
             Closeable, AutoCloseable, org.springframework.beans.factory.Aware,
             org.springframework.beans.factory.BeanFactory,
             org.springframework.beans.factory.BeanNameAware,
             org.springframework.beans.factory.HierarchicalBeanFactory,
             org.springframework.beans.factory.InitializingBean,
             org.springframework.beans.factory.ListableBeanFactory,
             ApplicationContext, ApplicationEventPublisher,
             ConfigurableApplicationContext, Lifecycle, MessageSource,
             org.springframework.core.env.EnvironmentCapable,
             org.springframework.core.io.ResourceLoader,
             org.springframework.core.io.support.ResourcePatternResolver
   #+END_SRC

   ~AnnotationConfigApplicationContext~: 读取注解 Bean 定义的容器

   #+BEGIN_SRC text
     org.springframework.context.annotation
     Class AnnotationConfigApplicationContext

         java.lang.Object
             org.springframework.core.io.DefaultResourceLoader
                 org.springframework.context.support.AbstractApplicationContext
                     org.springframework.context.support.GenericApplicationContext
                         org.springframework.context.annotation.AnnotationConfigApplicationContext

         All Implemented Interfaces:
             Closeable, AutoCloseable,
             org.springframework.beans.factory.BeanFactory,
             org.springframework.beans.factory.HierarchicalBeanFactory,
             org.springframework.beans.factory.ListableBeanFactory,
             org.springframework.beans.factory.support.BeanDefinitionRegistry,
             AnnotationConfigRegistry, ApplicationContext,
             ApplicationEventPublisher, ConfigurableApplicationContext,
             Lifecycle, MessageSource, org.springframework.core.AliasRegistry,
             org.springframework.core.env.EnvironmentCapable,
             org.springframework.core.io.ResourceLoader,
             org.springframework.core.io.support.ResourcePatternResolver
   #+END_SRC

   常见的类简单可以分成以下几类
   1. 资源处理
      - ~Resource~ Spring 中关于资源的定义
      - ~ResourceLoader~ 提供资源加载方法
      - ~BeanDefinitionReader~ 读取接口主要用来读取信息
   2. 注册形式，在 Spring 中关于注册的几个核心
      - ~AliasRegistry~ 别名注册
      - ~BeanDefinitionRegistry~ Bean 定义注册
      - ~SingletonBeanRegistry~ 单例 Bean 注册
        + ~DefaultSingletonBeanRegistry~
   3. 生命周期，可以分成容器生命周期和 Bean 生命周期两个小类
      - ~Lifecycle~ 容器生命周期的核心接口
      - ~InitializingBean~, ~DisposableBean~ 等 Bean 的生命周期接口
   4. Bean 拓展
      - ~BeanPostProcessor~
      - ~Aware~ 系列接口
   5. 上下文的接口:
      - ~ApplicationContext~ 作为主导接口
        - ~AbstractApplicationContext~

* ApplicationContext

* AOP
  使用动态代理实现
  - JDK 代理
  - cglib 代理

* Spring 核心类梳理
  1. ApplicationContext
     - AbstractApplicationContext
       + ~refresh()~ 实现 Spring Bean 加载的核心逻辑
  2. BeanDefinition
     - AbstractBeanDefinition
  3. BeanDefinitionReader
     - 读取 BeanDefinition 对象
  4. BeanFactory
     - Bean 工厂类
     - AbstractBeanFactory
       + ~doGetBean(...)~
  5. BeanFactoryPostProcessor
     - 函数式接口 ~@FunctionalInterface~
  6. BeanPostProcessor
     - 提供自定义 Bean 实例化的处理接口扩展
     - ~postProcessBeforeInitialization(Object bean, String beanName)~
       + Bean 实例化前置处理方法
     - ~postProcessAfterInitialization(Object bean, String beanName)~
       + Bean 实例化后置处理方法

* SpringBoot 自动装配
* 参考链接
  1. [[https://huifer.github.io/spring-analysis/][Spring Analysis]]
