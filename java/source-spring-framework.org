#+TITLE: Spring Framework v5.2.5.RELEASE
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-14 Wed 12:16:43>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: java spring source


* IoC
** IoC 核心接口和类
   Spring 的 IoC 容器对象一般继承自 ~ApplicationContext~ 接口，常见的对象类如下

   ~ClassPathXmlApplicationContext~: 读取 ClassPath 中 XML 配置文件的 Bean 定义
   的容器

   [[file:../static/image/2021/07/ClassPathXmlApplicationContext.png]]

   ~AnnotationConfigApplicationContext~: 读取注解 Bean 定义的容器

   [[file:../static/image/2021/07/AnnotationConfigApplicationContext.png]]

   常见的类简单可以分成以下几类
   1. 资源处理
      - ~Resource~ Spring 中关于资源的定义
      - ~ResourceLoader~ 提供资源加载方法
      - ~BeanDefinitionReader~ 读取接口主要用来读取信息
   2. 注册形式，在 Spring 中关于注册的几个核心
      - ~AliasRegistry~ 别名注册
      - ~BeanDefinitionRegistry~ Bean 定义注册
      - ~SingletonBeanRegistry~ 单例 Bean 注册
        + ~DefaultSingletonBeanRegistry~
   3. 生命周期，可以分成容器生命周期和 Bean 生命周期两个小类
      - ~Lifecycle~ 容器生命周期的核心接口
      - ~InitializingBean~, ~DisposableBean~ 等 Bean 的生命周期接口
   4. Bean 拓展
      - ~BeanPostProcessor~
      - ~Aware~ 系列接口
   5. 上下文的接口:
      - ~ApplicationContext~ 作为主导接口
        - ~AbstractApplicationContext~

** IoC 资源读取及注册
*** XML 文档验证
    XML 文档验证常见有如下两种方式
    - DTD (Document Type Definition) 验证
    - XSD (XML Schema Definition) 验证
    XML 文档读取实现位于 ~XmlBeanDefinitionReader~ 类中实现，该类中的实现了对上
    述两种格式 XML 文档的读取
    #+BEGIN_SRC java
      /**
       ,* Indicates that the validation should be disabled.
       ,*/
      public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;

      /**
       ,* Indicates that the validation mode should be detected automatically.
       ,*/
      public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;

      /**
       ,* Indicates that DTD validation should be used.
       ,*/
      public static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;

      /**
       ,* Indicates that XSD validation should be used.
       ,*/
      public static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;
     #+END_SRC

*** XML 文档读取
     读取 XML 文件核心方法 ~loadBeanDefinitions(...)~ 实现如下
     #+BEGIN_SRC java
       /**
        ,* Load bean definitions from the specified XML file.
        ,* @param encodedResource the resource descriptor for the XML file,
        ,* allowing to specify an encoding to use for parsing the file
        ,* @return the number of bean definitions found
        ,* @throws BeanDefinitionStoreException in case of loading or parsing errors
        ,*/
       public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
           Assert.notNull(encodedResource, "EncodedResource must not be null");
           if (logger.isTraceEnabled()) {
               logger.trace("Loading XML bean definitions from " + encodedResource);
           }

           Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();
           if (currentResources == null) {
               currentResources = new HashSet<>(4);
               this.resourcesCurrentlyBeingLoaded.set(currentResources);
           }
           if (!currentResources.add(encodedResource)) {
               throw new BeanDefinitionStoreException(
                       "Detected cyclic loading of " + encodedResource + " - check your import definitions!");
           }

           try (InputStream inputStream = encodedResource.getResource().getInputStream()) {
               InputSource inputSource = new InputSource(inputStream);
               if (encodedResource.getEncoding() != null) {
                   inputSource.setEncoding(encodedResource.getEncoding());
               }
               return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
           }
           catch (IOException ex) {
               throw new BeanDefinitionStoreException(
                       "IOException parsing XML document from " + encodedResource.getResource(), ex);
           }
           finally {
               currentResources.remove(encodedResource);
               if (currentResources.isEmpty()) {
                   this.resourcesCurrentlyBeingLoaded.remove();
               }
           }
       }
     #+END_SRC

     其中的 ~doLoadBeanDefinitions(...)~ 方法具体实现加载 ~BeanDefinition~
     - ~doLoadDocument()~ 加载文档，这部分将 XML 作为资源读取
     - ~registerBeanDefinitions()~ 注册 ~BeanDefinition~
       + 其中 ~DefaultBeanDefinitionDocumentReader~ 中的
         ~registerBeanDefinitions()~ 方法实现了注册 ~BeanDefinition~
     #+BEGIN_SRC java
       /**
        ,* Actually load bean definitions from the specified XML file.
        ,* @param inputSource the SAX InputSource to read from
        ,* @param resource the resource descriptor for the XML file
        ,* @return the number of bean definitions found
        ,* @throws BeanDefinitionStoreException in case of loading or parsing errors
        ,* @see #doLoadDocument
        ,* @see #registerBeanDefinitions
        ,*/
       protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
               throws BeanDefinitionStoreException {

           try {
               Document doc = doLoadDocument(inputSource, resource);
               int count = registerBeanDefinitions(doc, resource);
               if (logger.isDebugEnabled()) {
                   logger.debug("Loaded " + count + " bean definitions from " + resource);
               }
               return count;
           }
           catch (BeanDefinitionStoreException ex) {
               throw ex;
           }
           catch (SAXParseException ex) {
               throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                       "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
           }
           catch (SAXException ex) {
               throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                       "XML document from " + resource + " is invalid", ex);
           }
           catch (ParserConfigurationException ex) {
               throw new BeanDefinitionStoreException(resource.getDescription(),
                       "Parser configuration exception parsing XML from " + resource, ex);
           }
           catch (IOException ex) {
               throw new BeanDefinitionStoreException(resource.getDescription(),
                       "IOException parsing XML document from " + resource, ex);
           }
           catch (Throwable ex) {
               throw new BeanDefinitionStoreException(resource.getDescription(),
                       "Unexpected exception parsing XML document from " + resource, ex);
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
           this.readerContext = readerContext;
           doRegisterBeanDefinitions(doc.getDocumentElement());
       }
     #+END_SRC
     ~DefaultBeanDefinitionDocumentReader~ 实现
     - ~protected void doRegisterBeanDefinitions(Element root)~ 读取 XML 的
       ~<bean>~ 标签中的信息
       #+BEGIN_SRC xml
         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

           <bean id="author" class="io.github.jeanhwea.bean.Author">
             <property name="name" value="Martin Flower"/>
           </bean>

         </beans>
       #+END_SRC

     至此 XML 格式的 ~BeanDefinition~ 注册完成

*** XML 标签解析
    标签解析的细节比较多，这里跳过
    1. beans 标签的解析
       - id
       - name
       - class
       - parent
       - scope
       - abstract
       - lazy-init
       - autowire
       - depends-on
       - autowire-candidate
       - init-method
       - destroy-method
       - factory-method
       - factory-bean
    2. import 标签的解析
    3. alias 标签的解析

** TODO 自定义标签注册
   ~BeanDefinitionParser~

** TODO 别名注册

** ~<bean/>~ 标签解析
   ~BeanDefinitionDocumentReader~ 类中的 ~processBeanDefinition(...)~ 方法事先对
   ~<bean/>~ 标签的解析
   #+BEGIN_SRC java
     /**
      ,* Process the given bean element, parsing the bean definition
      ,* and registering it with the registry.
      ,*/
     protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
         BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
         if (bdHolder != null) {
             bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
             try {
                 // Register the final decorated instance.
                 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
             }
             catch (BeanDefinitionStoreException ex) {
                 getReaderContext().error("Failed to register bean definition with name '" +
                         bdHolder.getBeanName() + "'", ele, ex);
             }
             // Send registration event.
             getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
         }
     }
   #+END_SRC

** BeanDefinition 注册
*** BeanDefinition 的注册
    BeanDefinition 的注册方法位于 ~BeanDefinitionReaderUtils~ 抽象类中
    1. 确定 beanName 和 BeanDefinition 的绑定关系
    2. 确定 beanName 和 Alias 的对应关系
    #+BEGIN_SRC java
      /**
       ,* Register the given bean definition with the given bean factory.
       ,* @param definitionHolder the bean definition including name and aliases
       ,* @param registry the bean factory to register with
       ,* @throws BeanDefinitionStoreException if registration failed
       ,*/
      public static void registerBeanDefinition(
              BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
              throws BeanDefinitionStoreException {

          // Register bean definition under primary name.
          String beanName = definitionHolder.getBeanName();
          registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

          // Register aliases for bean name, if any.
          String[] aliases = definitionHolder.getAliases();
          if (aliases != null) {
              for (String alias : aliases) {
                  registry.registerAlias(beanName, alias);
              }
          }
      }
    #+END_SRC

    在调用到注册方法的调用栈如下
    #+BEGIN_SRC text
      registerBeanDefinition:163, BeanDefinitionReaderUtils (org.springframework.beans.factory.support)
      processBeanDefinition:311, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      parseDefaultElement:197, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      parseBeanDefinitions:176, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      doRegisterBeanDefinitions:149, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      registerBeanDefinitions:96, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      registerBeanDefinitions:509, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      doLoadBeanDefinitions:389, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      loadBeanDefinitions:336, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      loadBeanDefinitions:305, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      loadBeanDefinitions:188, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:224, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:195, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:257, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:128, AbstractXmlApplicationContext (org.springframework.context.support)
      loadBeanDefinitions:94, AbstractXmlApplicationContext (org.springframework.context.support)
      refreshBeanFactory:133, AbstractRefreshableApplicationContext (org.springframework.context.support)
      obtainFreshBeanFactory:637, AbstractApplicationContext (org.springframework.context.support)
      refresh:522, AbstractApplicationContext (org.springframework.context.support)
      <init>:144, ClassPathXmlApplicationContext (org.springframework.context.support)
      <init>:85, ClassPathXmlApplicationContext (org.springframework.context.support)
      main:10, MyApplication (io.github.jeanhwea)
    #+END_SRC

*** DefaultListableBeanFactory
    通过观察上文的调用栈可以发现注册 BeanDefinition 是通过
    ~AbstractRefreshableApplicationContext~ 类中的 ~loadBeanDefinitions(...)~ 方
    法实现
    #+BEGIN_SRC java
      /**
       ,* This implementation performs an actual refresh of this context's underlying
       ,* bean factory, shutting down the previous bean factory (if any) and
       ,* initializing a fresh bean factory for the next phase of the context's lifecycle.
       ,*/
      @Override
      protected final void refreshBeanFactory() throws BeansException {
          if (hasBeanFactory()) {
              destroyBeans();
              closeBeanFactory();
          }
          try {
              DefaultListableBeanFactory beanFactory = createBeanFactory();
              beanFactory.setSerializationId(getId());
              customizeBeanFactory(beanFactory);
              loadBeanDefinitions(beanFactory);
              synchronized (this.beanFactoryMonitor) {
                  this.beanFactory = beanFactory;
              }
          }
          catch (IOException ex) {
              throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
          }
      }
    #+END_SRC

    这里使用的 beanFactory 是 ~DefaultListableBeanFactory~, 并且
    ~DefaultListableBeanFactory~ 实现了大部分的 Spring 注册及加载的实现，先查看
    其集成关系

    [[file:../static/image/2021/07/DefaultListableBeanFactory.png]]

    该类定了 BeanDefinition 类的 Map, 是用于存 BeanDefinition 信息的缓存
    #+BEGIN_SRC java
      /** Map of bean definition objects, keyed by bean name. */
      private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

      /** Map of singleton and non-singleton bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);

      /** Map of singleton-only bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);

      /** List of bean definition names, in registration order. */
      private volatile List<String> beanDefinitionNames = new ArrayList<>(256);
    #+END_SRC

**** BeanDefinition 注册的实现
     ~DefaultListableBeanFactory~ 的 ~registerBeanDefinition(...)~ 才是真正实现
     注册 BeanDefinition 逻辑，其代码如下：
     1. 对 beanDefinition 进行验证
     2. 检查 beanDefinition 是否存在
        - 如果存在，判断是否覆盖对应的 BeanDefinition
        - 如果 beanDefinition 不存在，进行创建并注册
     #+BEGIN_SRC java
       //---------------------------------------------------------------------
       // Implementation of BeanDefinitionRegistry interface
       //---------------------------------------------------------------------

       @Override
       public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
               throws BeanDefinitionStoreException {

           Assert.hasText(beanName, "Bean name must not be empty");
           Assert.notNull(beanDefinition, "BeanDefinition must not be null");

           if (beanDefinition instanceof AbstractBeanDefinition) {
               try {
                   ((AbstractBeanDefinition) beanDefinition).validate();
               }
               catch (BeanDefinitionValidationException ex) {
                   throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                           "Validation of bean definition failed", ex);
               }
           }

           BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
           if (existingDefinition != null) {
               if (!isAllowBeanDefinitionOverriding()) {
                   throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
               }
               else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                   // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                   if (logger.isInfoEnabled()) {
                       logger.info("Overriding user-defined bean definition for bean '" + beanName +
                               "' with a framework-generated bean definition: replacing [" +
                               existingDefinition + "] with [" + beanDefinition + "]");
                   }
               }
               else if (!beanDefinition.equals(existingDefinition)) {
                   if (logger.isDebugEnabled()) {
                       logger.debug("Overriding bean definition for bean '" + beanName +
                               "' with a different definition: replacing [" + existingDefinition +
                               "] with [" + beanDefinition + "]");
                   }
               }
               else {
                   if (logger.isTraceEnabled()) {
                       logger.trace("Overriding bean definition for bean '" + beanName +
                               "' with an equivalent definition: replacing [" + existingDefinition +
                               "] with [" + beanDefinition + "]");
                   }
               }
               this.beanDefinitionMap.put(beanName, beanDefinition);
           }
           else {
               if (hasBeanCreationStarted()) {
                   // Cannot modify startup-time collection elements anymore (for stable iteration)
                   synchronized (this.beanDefinitionMap) {
                       this.beanDefinitionMap.put(beanName, beanDefinition);
                       List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                       updatedDefinitions.addAll(this.beanDefinitionNames);
                       updatedDefinitions.add(beanName);
                       this.beanDefinitionNames = updatedDefinitions;
                       removeManualSingletonName(beanName);
                   }
               }
               else {
                   // Still in startup registration phase
                   this.beanDefinitionMap.put(beanName, beanDefinition);
                   this.beanDefinitionNames.add(beanName);
                   removeManualSingletonName(beanName);
               }
               this.frozenBeanDefinitionNames = null;
           }

           if (existingDefinition != null || containsSingleton(beanName)) {
               resetBeanDefinition(beanName);
           }
       }
     #+END_SRC

     在上面注册过程中， ~hasBeanCreationStarted()~ 方法用于判断 Bean 是否开始创
     建，它实现逻辑在父类 ~AbstractBeanFactory~ 中
     #+BEGIN_SRC java
       /**
        ,* Check whether this factory's bean creation phase already started,
        ,* i.e. whether any bean has been marked as created in the meantime.
        ,* @since 4.2.2
        ,* @see #markBeanAsCreated
        ,*/
       protected boolean hasBeanCreationStarted() {
           return !this.alreadyCreated.isEmpty();
       }
     #+END_SRC

     父类 ~AbstractBeanFactory~ 中定义了一个集合记录正在创建的 Bean
     #+BEGIN_SRC java
       /** Names of beans that have already been created at least once. */
       private final Set<String> alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap<>(256));
     #+END_SRC

     创建时通过 ~markBeanAsCreated(...)~ 方法标记，注意对 ~alreadyCreated~ 的访
     问是需要加锁的
     #+BEGIN_SRC java
       /**
        ,* Mark the specified bean as already created (or about to be created).
        ,* <p>This allows the bean factory to optimize its caching for repeated
        ,* creation of the specified bean.
        ,* @param beanName the name of the bean
        ,*/
       protected void markBeanAsCreated(String beanName) {
           if (!this.alreadyCreated.contains(beanName)) {
               synchronized (this.mergedBeanDefinitions) {
                   if (!this.alreadyCreated.contains(beanName)) {
                       // Let the bean definition get re-merged now that we're actually creating
                       // the bean... just in case some of its metadata changed in the meantime.
                       clearMergedBeanDefinition(beanName);
                       this.alreadyCreated.add(beanName);
                   }
               }
           }
       }
     #+END_SRC

**** BeanDefinition 移除的实现
     BeanDefinition 的移除方法如下，通过 ~removeBeanDefinition(...)~ 方法
     #+BEGIN_SRC java
       @Override
       public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
           Assert.hasText(beanName, "'beanName' must not be empty");

           BeanDefinition bd = this.beanDefinitionMap.remove(beanName);
           if (bd == null) {
               if (logger.isTraceEnabled()) {
                   logger.trace("No bean named '" + beanName + "' found in " + this);
               }
               throw new NoSuchBeanDefinitionException(beanName);
           }

           if (hasBeanCreationStarted()) {
               // Cannot modify startup-time collection elements anymore (for stable iteration)
               synchronized (this.beanDefinitionMap) {
                   List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);
                   updatedDefinitions.remove(beanName);
                   this.beanDefinitionNames = updatedDefinitions;
               }
           }
           else {
               // Still in startup registration phase
               this.beanDefinitionNames.remove(beanName);
           }
           this.frozenBeanDefinitionNames = null;

           resetBeanDefinition(beanName);
       }
     #+END_SRC

     移除 BeanDefinition 中调用了刷新 BeanDefinition 的方法
     ~resetBeanDefinition(...)~
     #+BEGIN_SRC java
       /**
        ,* Reset all bean definition caches for the given bean,
        ,* including the caches of beans that are derived from it.
        ,* <p>Called after an existing bean definition has been replaced or removed,
        ,* triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}
        ,* and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the
        ,* given bean and on all bean definitions that have the given bean as parent.
        ,* @param beanName the name of the bean to reset
        ,* @see #registerBeanDefinition
        ,* @see #removeBeanDefinition
        ,*/
       protected void resetBeanDefinition(String beanName) {
           // Remove the merged bean definition for the given bean, if already created.
           clearMergedBeanDefinition(beanName);

           // Remove corresponding bean from singleton cache, if any. Shouldn't usually
           // be necessary, rather just meant for overriding a context's default beans
           // (e.g. the default StaticMessageSource in a StaticApplicationContext).
           destroySingleton(beanName);

           // Notify all post-processors that the specified bean definition has been reset.
           for (BeanPostProcessor processor : getBeanPostProcessors()) {
               if (processor instanceof MergedBeanDefinitionPostProcessor) {
                   ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);
               }
           }

           // Reset all bean definitions that have the given bean as parent (recursively).
           for (String bdName : this.beanDefinitionNames) {
               if (!beanName.equals(bdName)) {
                   BeanDefinition bd = this.beanDefinitionMap.get(bdName);
                   // Ensure bd is non-null due to potential concurrent modification
                   // of the beanDefinitionMap.
                   if (bd != null && beanName.equals(bd.getParentName())) {
                       resetBeanDefinition(bdName);
                   }
               }
           }
       }
     #+END_SRC

**** BeanDefinition 获取
     ~DefaultListableBeanFactory~ 的实现获取 BeanDefinition 的逻辑如下
     #+BEGIN_SRC java
       @Override
       public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
           BeanDefinition bd = this.beanDefinitionMap.get(beanName);
           if (bd == null) {
               if (logger.isTraceEnabled()) {
                   logger.trace("No bean named '" + beanName + "' found in " + this);
               }
               throw new NoSuchBeanDefinitionException(beanName);
           }
           return bd;
       }
     #+END_SRC

** Bean 的生命周期
   ~BeanFactory~ 的注释中完整地说明的实现标准 BeanFactory 的代码
   1. BeanFactory 初始化过程，支持的标准 Bean 的生命周期
      - ~BeanNameAware#setBeanName(...)~
      - ~BeanClassLoaderAware#setBeanClassLoader(...)~
      - ~BeanFactoryAware#setBeanFactory(...)~
      - ~EnvironmentAware#setEnvironment(...)~
      - ~EmbeddedValueResolverAware#setEmbeddedValueResolver(...)~
      - ~ResourceLoaderAware#setResourceLoader(...)~ 在 ApplicationContext 中
      - ~ApplicationEventPublisherAware#setApplicationEventPublisher(...)~ 在
        ApplicationContext 中
      - ~MessageSourceAware#setMessageSource(...)~ 在 ApplicationContext 中
      - ~ApplicationContextAware#setApplicationContext(...)~ 在
        ApplicationContext 中
      - ~ServletContextAware#setServletContext(...)~ 在 ApplicationContext 中
      - ~BeanPostProcessors~ 的一系列 ~postProcessBeforeInitialization(...)~ 方法
      - ~InitializingBean#afterPropertiesSet(...)~
      - a custom init-method definition
      - ~BeanPostProcessors~ 的一系列 ~postProcessAfterInitialization(...)~ 方法
   2. 关闭 BeanFactory 时，执行的 Bean 销毁方法
      - ~DestructionAwareBeanPostProcessors~ 的一系列
        ~postProcessBeforeDestruction(...)~ 方法
      - ~DisposableBean#destroy(...)~
      - a custom destroy-method definition

   实例化 Bean 的方法为 ~instantiateClass(...)~, 它的实现如下
   #+BEGIN_SRC java
     /**
      ,* Convenience method to instantiate a class using the given constructor.
      ,* <p>Note that this method tries to set the constructor accessible if given a
      ,* non-accessible (that is, non-public) constructor, and supports Kotlin classes
      ,* with optional parameters and default values.
      ,* @param ctor the constructor to instantiate
      ,* @param args the constructor arguments to apply (use {@code null} for an unspecified
      ,* parameter, Kotlin optional parameters and Java primitive types are supported)
      ,* @return the new instance
      ,* @throws BeanInstantiationException if the bean cannot be instantiated
      ,* @see Constructor#newInstance
      ,*/
     public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {
         Assert.notNull(ctor, "Constructor must not be null");
         try {
             ReflectionUtils.makeAccessible(ctor); // 设置构造器的可见性
             if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {
                 return KotlinDelegate.instantiateClass(ctor, args);
             }
             else {
                 Class<?>[] parameterTypes = ctor.getParameterTypes();
                 Assert.isTrue(args.length <= parameterTypes.length, "Can't specify more arguments than constructor parameters");
                 Object[] argsWithDefaultValues = new Object[args.length];
                 for (int i = 0 ; i < args.length; i++) {
                     if (args[i] == null) {
                         Class<?> parameterType = parameterTypes[i];
                         argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);
                     }
                     else {
                         argsWithDefaultValues[i] = args[i];
                     }
                 }
                 return ctor.newInstance(argsWithDefaultValues); // 实例化 Bean 对象
             }
         }
         catch (InstantiationException ex) {
             throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex);
         }
         catch (IllegalAccessException ex) {
             throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex);
         }
         catch (IllegalArgumentException ex) {
             throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex);
         }
         catch (InvocationTargetException ex) {
             throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException());
         }
     }
   #+END_SRC

   先分析调用栈，可以知道创建 Bean 的入口是 ~refresh()~ 方法的
   ~invokeBeanFactoryPostProcessors()~ 方法，这里牵扯到几个核心的方法
   1. ~AbstractApplicationContext#refresh()~
   2. ~AbstractBeanFactory#doGetBean(...)~
   3. ~AbstractAutowireCapableBeanFactory#instantiateBean(...)~
   #+BEGIN_SRC text
     instantiateClass:185, BeanUtils (org.springframework.beans)
     instantiate:87, SimpleInstantiationStrategy (org.springframework.beans.factory.support)
     instantiateBean:1312, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     createBeanInstance:1214, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     doCreateBean:557, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     createBean:517, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     lambda$doGetBean$0:323, AbstractBeanFactory (org.springframework.beans.factory.support)
     getObject:-1, 1027007693 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$29)
     getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)
     doGetBean:321, AbstractBeanFactory (org.springframework.beans.factory.support)
     getBean:207, AbstractBeanFactory (org.springframework.beans.factory.support)
     invokeBeanFactoryPostProcessors:89, PostProcessorRegistrationDelegate (org.springframework.context.support)
     invokeBeanFactoryPostProcessors:706, AbstractApplicationContext (org.springframework.context.support)
     refresh:532, AbstractApplicationContext (org.springframework.context.support)
     main:18, MyApp02 (io.github.jeanhwea.app02)
   #+END_SRC

   ~instantiateBean(...)~ 实例化 Bean 主要完成如下工作
   1. 使用 InstantiationStrategy 实例化策略来实例化 Bean, Spring 中创建 Bean 有如
      下两种方式
      - 通过 ~BeanUtils.instantiateClass()~ 方法创建实例
      - 通过 ~new CglibSubclassCreator(bd, owner).instantiate(ctor, args)~ 方式
        进行创建
   2. 添加 BeanWrapper 封装 Bean 对象
      - 实现类为 ~BeanWrapperImpl~
      - ~BeanWrapperImpl~ 继承自 ~AbstractNestablePropertyAccessor~
      - ~AbstractNestablePropertyAccessor#setPropertyValue(...)~ 方法设置属性值
   #+BEGIN_SRC java
     /**
      ,* Instantiate the given bean using its default constructor.
      ,* @param beanName the name of the bean
      ,* @param mbd the bean definition for the bean
      ,* @return a BeanWrapper for the new instance
      ,*/
     protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
         try {
             Object beanInstance;
             final BeanFactory parent = this;
             if (System.getSecurityManager() != null) {
                 beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
                         getInstantiationStrategy().instantiate(mbd, beanName, parent),
                         getAccessControlContext());
             }
             else {
                 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
             }
             BeanWrapper bw = new BeanWrapperImpl(beanInstance);
             initBeanWrapper(bw);
             return bw;
         }
         catch (Throwable ex) {
             throw new BeanCreationException(
                     mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
         }
     }
   #+END_SRC

   ~doGetBean(...)~ 方法是获取 Bean 的最终处理函数，它的逻辑比较复杂，可以分成以
   下流程
   1. 获取 beanName, 这里处理了 Bean 的别名
   2. 单例容器中尝试获取，调用 ~DefaultSingletonBeanRegistry#getSingleton()~ 方
      法来处理
   3. 获取 FactoryBean 生成的 Bean 实例
      - 通过 ~getObjectForBeanInstance()~ 方法获取 beanInstance
   4. 尝试从父容器中获取
   5. 调用 ~markBeanAsCreated()~ 方法标记创建 Bean
   6. 单例 Bean 创建
      - ~getSingleton(String beanName, ObjectFactory<?> singletonFactory)~
   7. 原型 Bean 创建
   8. 非单例 Bean 也非原型 Bean 创建
   #+BEGIN_SRC java
     /**
      ,* Return an instance, which may be shared or independent, of the specified bean.
      ,* @param name the name of the bean to retrieve
      ,* @param requiredType the required type of the bean to retrieve
      ,* @param args arguments to use when creating a bean instance using explicit arguments
      ,* (only applied when creating a new instance as opposed to retrieving an existing one)
      ,* @param typeCheckOnly whether the instance is obtained for a type check,
      ,* not for actual use
      ,* @return an instance of the bean
      ,* @throws BeansException if the bean could not be created
      ,*/
     @SuppressWarnings("unchecked")
     protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
             @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

         final String beanName = transformedBeanName(name);
         Object bean;

         // Eagerly check singleton cache for manually registered singletons.
         Object sharedInstance = getSingleton(beanName);
         if (sharedInstance != null && args == null) {
             if (logger.isTraceEnabled()) {
                 if (isSingletonCurrentlyInCreation(beanName)) {
                     logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                             "' that is not fully initialized yet - a consequence of a circular reference");
                 }
                 else {
                     logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                 }
             }
             bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
         }

         else {
             // Fail if we're already creating this bean instance:
             // We're assumably within a circular reference.
             if (isPrototypeCurrentlyInCreation(beanName)) {
                 throw new BeanCurrentlyInCreationException(beanName);
             }

             // Check if bean definition exists in this factory.
             BeanFactory parentBeanFactory = getParentBeanFactory();
             if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
                 // Not found -> check parent.
                 String nameToLookup = originalBeanName(name);
                 if (parentBeanFactory instanceof AbstractBeanFactory) {
                     return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                             nameToLookup, requiredType, args, typeCheckOnly);
                 }
                 else if (args != null) {
                     // Delegation to parent with explicit args.
                     return (T) parentBeanFactory.getBean(nameToLookup, args);
                 }
                 else if (requiredType != null) {
                     // No args -> delegate to standard getBean method.
                     return parentBeanFactory.getBean(nameToLookup, requiredType);
                 }
                 else {
                     return (T) parentBeanFactory.getBean(nameToLookup);
                 }
             }

             if (!typeCheckOnly) {
                 markBeanAsCreated(beanName);
             }

             try {
                 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                 checkMergedBeanDefinition(mbd, beanName, args);

                 // Guarantee initialization of beans that the current bean depends on.
                 String[] dependsOn = mbd.getDependsOn();
                 if (dependsOn != null) {
                     for (String dep : dependsOn) {
                         if (isDependent(beanName, dep)) {
                             throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                     "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                         }
                         registerDependentBean(dep, beanName);
                         try {
                             getBean(dep);
                         }
                         catch (NoSuchBeanDefinitionException ex) {
                             throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                     "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                         }
                     }
                 }

                 // Create bean instance.
                 if (mbd.isSingleton()) {
                     sharedInstance = getSingleton(beanName, () -> {
                         try {
                             return createBean(beanName, mbd, args);
                         }
                         catch (BeansException ex) {
                             // Explicitly remove instance from singleton cache: It might have been put there
                             // eagerly by the creation process, to allow for circular reference resolution.
                             // Also remove any beans that received a temporary reference to the bean.
                             destroySingleton(beanName);
                             throw ex;
                         }
                     });
                     bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                 }

                 else if (mbd.isPrototype()) {
                     // It's a prototype -> create a new instance.
                     Object prototypeInstance = null;
                     try {
                         beforePrototypeCreation(beanName);
                         prototypeInstance = createBean(beanName, mbd, args);
                     }
                     finally {
                         afterPrototypeCreation(beanName);
                     }
                     bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                 }

                 else {
                     String scopeName = mbd.getScope();
                     final Scope scope = this.scopes.get(scopeName);
                     if (scope == null) {
                         throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                     }
                     try {
                         Object scopedInstance = scope.get(beanName, () -> {
                             beforePrototypeCreation(beanName);
                             try {
                                 return createBean(beanName, mbd, args);
                             }
                             finally {
                                 afterPrototypeCreation(beanName);
                             }
                         });
                         bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                     }
                     catch (IllegalStateException ex) {
                         throw new BeanCreationException(beanName,
                                 "Scope '" + scopeName + "' is not active for the current thread; consider " +
                                 "defining a scoped proxy for this bean if you intend to refer to it from a singleton",
                                 ex);
                     }
                 }
             }
             catch (BeansException ex) {
                 cleanupAfterBeanCreationFailure(beanName);
                 throw ex;
             }
         }

         // Check if required type matches the type of the actual bean instance.
         if (requiredType != null && !requiredType.isInstance(bean)) {
             try {
                 T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                 if (convertedBean == null) {
                     throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                 }
                 return convertedBean;
             }
             catch (TypeMismatchException ex) {
                 if (logger.isTraceEnabled()) {
                     logger.trace("Failed to convert bean '" + name + "' to required type '" +
                             ClassUtils.getQualifiedName(requiredType) + "'", ex);
                 }
                 throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
             }
         }
         return (T) bean;
     }
   #+END_SRC

* ApplicationContext

* AOP
  使用动态代理实现
  - JDK 代理
  - cglib 代理

* Spring 核心类梳理
  1. ApplicationContext
     - AbstractApplicationContext
       + ~refresh()~ 实现 Spring Bean 加载的核心逻辑
  2. BeanDefinition
     - AbstractBeanDefinition
  3. BeanDefinitionReader
     - 读取 BeanDefinition 对象
  4. BeanFactory
     - Bean 工厂类
     - AbstractBeanFactory
       + ~doGetBean(...)~
  5. BeanFactoryPostProcessor
     - 函数式接口 ~@FunctionalInterface~
  6. BeanPostProcessor
     - 提供自定义 Bean 实例化的处理接口扩展
     - ~postProcessBeforeInitialization(Object bean, String beanName)~
       + Bean 实例化前置处理方法
     - ~postProcessAfterInitialization(Object bean, String beanName)~
       + Bean 实例化后置处理方法

* SpringBoot 自动装配
* 参考链接
  1. [[https://huifer.github.io/spring-analysis/][Spring Analysis]]
