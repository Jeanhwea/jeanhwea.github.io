#+TITLE: Spring Framework v5.2.5.RELEASE
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-14 Wed 12:16:43>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: java spring source


* IoC
** IoC 核心接口和类
   Spring 的 IoC 容器对象一般继承自 ~ApplicationContext~ 接口，常见的对象类如下

   ~ClassPathXmlApplicationContext~: 读取 ClassPath 中 XML 配置文件的 Bean 定义
   的容器

   [[file:../static/image/2021/07/ClassPathXmlApplicationContext.png]]

   ~AnnotationConfigApplicationContext~: 读取注解 Bean 定义的容器

   [[file:../static/image/2021/07/AnnotationConfigApplicationContext.png]]

   常见的类简单可以分成以下几类
   1. 资源处理
      - ~Resource~ Spring 中关于资源的定义
      - ~ResourceLoader~ 提供资源加载方法
      - ~BeanDefinitionReader~ 读取接口主要用来读取信息
   2. 注册形式，在 Spring 中关于注册的几个核心
      - ~AliasRegistry~ 别名注册
      - ~BeanDefinitionRegistry~ Bean 定义注册
      - ~SingletonBeanRegistry~ 单例 Bean 注册
        + ~DefaultSingletonBeanRegistry~
   3. 生命周期，可以分成容器生命周期和 Bean 生命周期两个小类
      - ~Lifecycle~ 容器生命周期的核心接口
      - ~InitializingBean~, ~DisposableBean~ 等 Bean 的生命周期接口
   4. Bean 拓展
      - ~BeanPostProcessor~
      - ~Aware~ 系列接口
   5. 上下文的接口:
      - ~ApplicationContext~ 作为主导接口
        - ~AbstractApplicationContext~

** IoC 资源读取及注册
*** XML 文档验证
    XML 文档验证常见有如下两种方式
    - DTD (Document Type Definition) 验证
    - XSD (XML Schema Definition) 验证
    XML 文档读取实现位于 ~XmlBeanDefinitionReader~ 类中实现，该类中的实现了对上
    述两种格式 XML 文档的读取
    #+BEGIN_SRC java
      /**
       ,* Indicates that the validation should be disabled.
       ,*/
      public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;

      /**
       ,* Indicates that the validation mode should be detected automatically.
       ,*/
      public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;

      /**
       ,* Indicates that DTD validation should be used.
       ,*/
      public static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;

      /**
       ,* Indicates that XSD validation should be used.
       ,*/
      public static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;
     #+END_SRC

*** XML 文档读取
     读取 XML 文件核心方法 ~loadBeanDefinitions(...)~ 实现如下
     #+BEGIN_SRC java
       /**
        ,* Load bean definitions from the specified XML file.
        ,* @param encodedResource the resource descriptor for the XML file,
        ,* allowing to specify an encoding to use for parsing the file
        ,* @return the number of bean definitions found
        ,* @throws BeanDefinitionStoreException in case of loading or parsing errors
        ,*/
       public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
           Assert.notNull(encodedResource, "EncodedResource must not be null");
           if (logger.isTraceEnabled()) {
               logger.trace("Loading XML bean definitions from " + encodedResource);
           }

           Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();
           if (currentResources == null) {
               currentResources = new HashSet<>(4);
               this.resourcesCurrentlyBeingLoaded.set(currentResources);
           }
           if (!currentResources.add(encodedResource)) {
               throw new BeanDefinitionStoreException(
                       "Detected cyclic loading of " + encodedResource + " - check your import definitions!");
           }

           try (InputStream inputStream = encodedResource.getResource().getInputStream()) {
               InputSource inputSource = new InputSource(inputStream);
               if (encodedResource.getEncoding() != null) {
                   inputSource.setEncoding(encodedResource.getEncoding());
               }
               return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
           }
           catch (IOException ex) {
               throw new BeanDefinitionStoreException(
                       "IOException parsing XML document from " + encodedResource.getResource(), ex);
           }
           finally {
               currentResources.remove(encodedResource);
               if (currentResources.isEmpty()) {
                   this.resourcesCurrentlyBeingLoaded.remove();
               }
           }
       }
     #+END_SRC

     其中的 ~doLoadBeanDefinitions(...)~ 方法具体实现加载 ~BeanDefinition~
     - ~doLoadDocument()~ 加载文档，这部分将 XML 作为资源读取
     - ~registerBeanDefinitions()~ 注册 ~BeanDefinition~
       + 其中 ~DefaultBeanDefinitionDocumentReader~ 中的
         ~registerBeanDefinitions()~ 方法实现了注册 ~BeanDefinition~
     #+BEGIN_SRC java
       /**
        ,* Actually load bean definitions from the specified XML file.
        ,* @param inputSource the SAX InputSource to read from
        ,* @param resource the resource descriptor for the XML file
        ,* @return the number of bean definitions found
        ,* @throws BeanDefinitionStoreException in case of loading or parsing errors
        ,* @see #doLoadDocument
        ,* @see #registerBeanDefinitions
        ,*/
       protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
               throws BeanDefinitionStoreException {

           try {
               Document doc = doLoadDocument(inputSource, resource);
               int count = registerBeanDefinitions(doc, resource);
               if (logger.isDebugEnabled()) {
                   logger.debug("Loaded " + count + " bean definitions from " + resource);
               }
               return count;
           }
           catch (BeanDefinitionStoreException ex) {
               throw ex;
           }
           catch (SAXParseException ex) {
               throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                       "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
           }
           catch (SAXException ex) {
               throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                       "XML document from " + resource + " is invalid", ex);
           }
           catch (ParserConfigurationException ex) {
               throw new BeanDefinitionStoreException(resource.getDescription(),
                       "Parser configuration exception parsing XML from " + resource, ex);
           }
           catch (IOException ex) {
               throw new BeanDefinitionStoreException(resource.getDescription(),
                       "IOException parsing XML document from " + resource, ex);
           }
           catch (Throwable ex) {
               throw new BeanDefinitionStoreException(resource.getDescription(),
                       "Unexpected exception parsing XML document from " + resource, ex);
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
           this.readerContext = readerContext;
           doRegisterBeanDefinitions(doc.getDocumentElement());
       }
     #+END_SRC
     ~DefaultBeanDefinitionDocumentReader~ 实现
     - ~protected void doRegisterBeanDefinitions(Element root)~ 读取 XML 的
       ~<bean>~ 标签中的信息
       #+BEGIN_SRC xml
         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

           <bean id="author" class="io.github.jeanhwea.bean.Author">
             <property name="name" value="Martin Flower"/>
           </bean>

         </beans>
       #+END_SRC

     至此 XML 格式的 ~BeanDefinition~ 注册完成

*** XML 标签解析
    标签解析的细节比较多，这里跳过
    1. beans 标签的解析
       - id
       - name
       - class
       - parent
       - scope
       - abstract
       - lazy-init
       - autowire
       - depends-on
       - autowire-candidate
       - init-method
       - destroy-method
       - factory-method
       - factory-bean
    2. import 标签的解析
    3. alias 标签的解析

** TODO 自定义标签注册
   ~BeanDefinitionParser~

** TODO 别名注册

** ~<bean/>~ 标签解析
   ~BeanDefinitionDocumentReader~ 类中的 ~processBeanDefinition(...)~ 方法事先对
   ~<bean/>~ 标签的解析
   #+BEGIN_SRC java
     /**
      ,* Process the given bean element, parsing the bean definition
      ,* and registering it with the registry.
      ,*/
     protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
         BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
         if (bdHolder != null) {
             bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
             try {
                 // Register the final decorated instance.
                 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
             }
             catch (BeanDefinitionStoreException ex) {
                 getReaderContext().error("Failed to register bean definition with name '" +
                         bdHolder.getBeanName() + "'", ele, ex);
             }
             // Send registration event.
             getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
         }
     }
   #+END_SRC

** BeanDefinition 注册
*** BeanDefinition 的注册方法
    BeanDefinition 的注册方法位于 ~BeanDefinitionReaderUtils~ 抽象类中
    1. 确定 beanName 和 BeanDefinition 的绑定关系
    2. 确定 beanName 和 Alias 的对应关系
    #+BEGIN_SRC java
      /**
       ,* Register the given bean definition with the given bean factory.
       ,* @param definitionHolder the bean definition including name and aliases
       ,* @param registry the bean factory to register with
       ,* @throws BeanDefinitionStoreException if registration failed
       ,*/
      public static void registerBeanDefinition(
              BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
              throws BeanDefinitionStoreException {

          // Register bean definition under primary name.
          String beanName = definitionHolder.getBeanName();
          registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

          // Register aliases for bean name, if any.
          String[] aliases = definitionHolder.getAliases();
          if (aliases != null) {
              for (String alias : aliases) {
                  registry.registerAlias(beanName, alias);
              }
          }
      }
    #+END_SRC

    在调用到注册方法的调用栈如下
    #+BEGIN_SRC text
      registerBeanDefinition:163, BeanDefinitionReaderUtils (org.springframework.beans.factory.support)
      processBeanDefinition:311, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      parseDefaultElement:197, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      parseBeanDefinitions:176, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      doRegisterBeanDefinitions:149, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      registerBeanDefinitions:96, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
      registerBeanDefinitions:509, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      doLoadBeanDefinitions:389, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      loadBeanDefinitions:336, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      loadBeanDefinitions:305, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
      loadBeanDefinitions:188, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:224, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:195, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:257, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
      loadBeanDefinitions:128, AbstractXmlApplicationContext (org.springframework.context.support)
      loadBeanDefinitions:94, AbstractXmlApplicationContext (org.springframework.context.support)
      refreshBeanFactory:133, AbstractRefreshableApplicationContext (org.springframework.context.support)
      obtainFreshBeanFactory:637, AbstractApplicationContext (org.springframework.context.support)
      refresh:522, AbstractApplicationContext (org.springframework.context.support)
      <init>:144, ClassPathXmlApplicationContext (org.springframework.context.support)
      <init>:85, ClassPathXmlApplicationContext (org.springframework.context.support)
      main:10, MyApplication (io.github.jeanhwea)
    #+END_SRC

*** DefaultListableBeanFactory 实现
    通过观察上文的调用栈可以发现注册 BeanDefinition 是通过
    ~AbstractRefreshableApplicationContext~ 类中的 ~loadBeanDefinitions(...)~ 方
    法实现
    #+BEGIN_SRC java
      /**
       ,* This implementation performs an actual refresh of this context's underlying
       ,* bean factory, shutting down the previous bean factory (if any) and
       ,* initializing a fresh bean factory for the next phase of the context's lifecycle.
       ,*/
      @Override
      protected final void refreshBeanFactory() throws BeansException {
          if (hasBeanFactory()) {
              destroyBeans();
              closeBeanFactory();
          }
          try {
              DefaultListableBeanFactory beanFactory = createBeanFactory();
              beanFactory.setSerializationId(getId());
              customizeBeanFactory(beanFactory);
              loadBeanDefinitions(beanFactory);
              synchronized (this.beanFactoryMonitor) {
                  this.beanFactory = beanFactory;
              }
          }
          catch (IOException ex) {
              throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
          }
      }
    #+END_SRC

    这里使用的 beanFactory 是 ~DefaultListableBeanFactory~, 并且
    ~DefaultListableBeanFactory~ 实现了大部分的 Spring 注册及加载的实现，先查看
    其集成关系

    [[file:../static/image/2021/07/DefaultListableBeanFactory.png]]

    该类定了 BeanDefinition 类的 Map, 是用于存 BeanDefinition 信息的缓存
    #+BEGIN_SRC java
      /** Map of bean definition objects, keyed by bean name. */
      private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

      /** Map of singleton and non-singleton bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);

      /** Map of singleton-only bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);

      /** List of bean definition names, in registration order. */
      private volatile List<String> beanDefinitionNames = new ArrayList<>(256);
    #+END_SRC

    ~DefaultListableBeanFactory~ 的 ~registerBeanDefinition(...)~ 才是真正实现注
    册 BeanDefinition 逻辑，其代码如下：
    1. 对 beanDefinition 进行验证
    2. 检查 beanDefinition 是否存在
       - 如果存在，判断是否覆盖对应的 BeanDefinition
       - 如果 beanDefinition 不存在，进行创建并注册
    #+BEGIN_SRC java
      //---------------------------------------------------------------------
      // Implementation of BeanDefinitionRegistry interface
      //---------------------------------------------------------------------

      @Override
      public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
              throws BeanDefinitionStoreException {

          Assert.hasText(beanName, "Bean name must not be empty");
          Assert.notNull(beanDefinition, "BeanDefinition must not be null");

          if (beanDefinition instanceof AbstractBeanDefinition) {
              try {
                  ((AbstractBeanDefinition) beanDefinition).validate();
              }
              catch (BeanDefinitionValidationException ex) {
                  throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                          "Validation of bean definition failed", ex);
              }
          }

          BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
          if (existingDefinition != null) {
              if (!isAllowBeanDefinitionOverriding()) {
                  throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
              }
              else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                  // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                  if (logger.isInfoEnabled()) {
                      logger.info("Overriding user-defined bean definition for bean '" + beanName +
                              "' with a framework-generated bean definition: replacing [" +
                              existingDefinition + "] with [" + beanDefinition + "]");
                  }
              }
              else if (!beanDefinition.equals(existingDefinition)) {
                  if (logger.isDebugEnabled()) {
                      logger.debug("Overriding bean definition for bean '" + beanName +
                              "' with a different definition: replacing [" + existingDefinition +
                              "] with [" + beanDefinition + "]");
                  }
              }
              else {
                  if (logger.isTraceEnabled()) {
                      logger.trace("Overriding bean definition for bean '" + beanName +
                              "' with an equivalent definition: replacing [" + existingDefinition +
                              "] with [" + beanDefinition + "]");
                  }
              }
              this.beanDefinitionMap.put(beanName, beanDefinition);
          }
          else {
              if (hasBeanCreationStarted()) {
                  // Cannot modify startup-time collection elements anymore (for stable iteration)
                  synchronized (this.beanDefinitionMap) {
                      this.beanDefinitionMap.put(beanName, beanDefinition);
                      List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                      updatedDefinitions.addAll(this.beanDefinitionNames);
                      updatedDefinitions.add(beanName);
                      this.beanDefinitionNames = updatedDefinitions;
                      removeManualSingletonName(beanName);
                  }
              }
              else {
                  // Still in startup registration phase
                  this.beanDefinitionMap.put(beanName, beanDefinition);
                  this.beanDefinitionNames.add(beanName);
                  removeManualSingletonName(beanName);
              }
              this.frozenBeanDefinitionNames = null;
          }

          if (existingDefinition != null || containsSingleton(beanName)) {
              resetBeanDefinition(beanName);
          }
      }
    #+END_SRC

*** XmlBeanDefinitionReader
    实际实现读取 BeanDefinition 的方法
    #+BEGIN_SRC java
      /**
       ,* Actually load bean definitions from the specified XML file.
       ,* @param inputSource the SAX InputSource to read from
       ,* @param resource the resource descriptor for the XML file
       ,* @return the number of bean definitions found
       ,* @throws BeanDefinitionStoreException in case of loading or parsing errors
       ,* @see #doLoadDocument
       ,* @see #registerBeanDefinitions
       ,*/
      protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
              throws BeanDefinitionStoreException {

          try {
              Document doc = doLoadDocument(inputSource, resource);
              int count = registerBeanDefinitions(doc, resource);
              if (logger.isDebugEnabled()) {
                  logger.debug("Loaded " + count + " bean definitions from " + resource);
              }
              return count;
          }
          catch (BeanDefinitionStoreException ex) {
              throw ex;
          }
          catch (SAXParseException ex) {
              throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                      "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
          }
          catch (SAXException ex) {
              throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                      "XML document from " + resource + " is invalid", ex);
          }
          catch (ParserConfigurationException ex) {
              throw new BeanDefinitionStoreException(resource.getDescription(),
                      "Parser configuration exception parsing XML from " + resource, ex);
          }
          catch (IOException ex) {
              throw new BeanDefinitionStoreException(resource.getDescription(),
                      "IOException parsing XML document from " + resource, ex);
          }
          catch (Throwable ex) {
              throw new BeanDefinitionStoreException(resource.getDescription(),
                      "Unexpected exception parsing XML document from " + resource, ex);
          }
      }
    #+END_SRC

* ApplicationContext

* AOP
  使用动态代理实现
  - JDK 代理
  - cglib 代理

* Spring 核心类梳理
  1. ApplicationContext
     - AbstractApplicationContext
       + ~refresh()~ 实现 Spring Bean 加载的核心逻辑
  2. BeanDefinition
     - AbstractBeanDefinition
  3. BeanDefinitionReader
     - 读取 BeanDefinition 对象
  4. BeanFactory
     - Bean 工厂类
     - AbstractBeanFactory
       + ~doGetBean(...)~
  5. BeanFactoryPostProcessor
     - 函数式接口 ~@FunctionalInterface~
  6. BeanPostProcessor
     - 提供自定义 Bean 实例化的处理接口扩展
     - ~postProcessBeforeInitialization(Object bean, String beanName)~
       + Bean 实例化前置处理方法
     - ~postProcessAfterInitialization(Object bean, String beanName)~
       + Bean 实例化后置处理方法

* SpringBoot 自动装配
* 参考链接
  1. [[https://huifer.github.io/spring-analysis/][Spring Analysis]]
