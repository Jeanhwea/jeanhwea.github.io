#+TITLE: Spring Framework v5.2.5.RELEASE
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2021-07-14 Wed 12:16:43>
#+HTML_LINK_UP: ../readme.html
#+HTML_LINK_HOME: ../index.html
#+SETUPFILE: ~/.emacs.d/site-lisp/org-html-themes/setup/theme-readtheorg-local.setup
#+TAGS: java spring source

* 容器实现原理
** Bean 工厂接口: BeanFactory
   ~BeanFactory~ 是 Spring 的 Bean 工厂的接口定义，它定义对 Spring Bean 容器访问的
   基本操作方法，这里简化如下
   #+BEGIN_SRC java
     public interface BeanFactory {

       // FactoryBean 的 beanName 前缀
       String FACTORY_BEAN_PREFIX = "&";

       // 获取 Bean 的主方法
       Object getBean(String name) throws BeansException;
       <T> T getBean(String name, Class<T> requiredType) throws BeansException;
       Object getBean(String name, Object... args) throws BeansException;
       <T> T getBean(Class<T> requiredType) throws BeansException;
       <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;

       <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
       <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);

       boolean containsBean(String name);

       boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
       boolean isPrototype(String name) throws NoSuchBeanDefinitionException;

       boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
       boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;

       @Nullable
       Class<?> getType(String name) throws NoSuchBeanDefinitionException;
       @Nullable
       Class<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;

       String[] getAliases(String name);
     }
   #+END_SRC

** Bean 工厂的实现类: DefaultListableBeanFactory
   ~DefaultListableBeanFactory~ 是实现 ~BeanFactory~ 接口的核心类，熟悉它的类继
   承和实现接口是了解 Bean 工厂功能的基本方法， ~DefaultListableBeanFactory~ 的
   关系如下
   #+BEGIN_SRC text
     org.springframework.beans.factory.support
     Class DefaultListableBeanFactory

         java.lang.Object
             org.springframework.core.SimpleAliasRegistry
                 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry
                     org.springframework.beans.factory.support.FactoryBeanRegistrySupport
                         org.springframework.beans.factory.support.AbstractBeanFactory
                             org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory
                                 org.springframework.beans.factory.support.DefaultListableBeanFactory

         All Implemented Interfaces:
             Serializable, BeanFactory, AutowireCapableBeanFactory,
             ConfigurableBeanFactory, ConfigurableListableBeanFactory,
             SingletonBeanRegistry, HierarchicalBeanFactory, ListableBeanFactory,
             BeanDefinitionRegistry, org.springframework.core.AliasRegistry

         Direct Known Subclasses:
             XmlBeanFactory
   #+END_SRC

   这里说明一下重要的类和接口的作用
   1. ~SimpleAliasRegistry~ 实现了 ~AliasRegistry~ 接口
      - ~AliasRegistry~ 定义了对别名的增删查改操作
   2. ~DefaultSingletonBeanRegistry~ 实现了 ~SingletonBeanRegistry~ 接口
      - ~SingletonBeanRegistry~ 定义了对单例 Bean 的注册及获取方法
      - ~SingletonBeanRegistry~ 通过三级缓存来解决循环依赖
   3. ~FactoryBeanRegistrySupport~ 实现了对 ~FactoryBean~ 的操作支持
      - 在 Spring 管理中, ~FactoryBean~ 的 beanName 以 ~&~ 开头
      - ~FactoryBean~ 的创建方式和普通 Spring Bean 是不一样的，它没有
        BeanDefinition, 直接通过实现 ~T getObject()~ 方法来返回创建的 Bean 对象
      - ~FactoryBean~ 还需要实现一些其他的方法，例如： ~isSingleton()~,
        ~getObjectType()~
   4. ~AbstractBeanFactory~ 实现了 ~BeanFactory~ 接口
      - ~BeanFactory~ 接口的直接实现是 ~AbstractBeanFactory~ 抽象类
      - ~AbstractBeanFactory~ 有很多核心方法
        + ~doGetBean(...)~ 实现了获取 Bean 的核心逻辑
        + ~isSingleton(...)~ 实现了判断 Bean 是否单例的核心逻辑
        + ~isPrototype(...)~ 实现了判断 Bean 是否原型的核心逻辑
   5. ~HierarchicalBeanFactory~ 接口继承自 ~BeanFactory~, 它增强了对 parentFactory
      的支持
   6. ~ConfigurableBeanFactory~ 接口提供了配置 Factory 的各种操作
      - ~setBeanClassLoader(...)~ 设置 Bean 的类加载器
      - ~registerDependentBean(...)~ 方法注册依赖 Bean
      - ~registerScope(...)~ 注册 Scope
      - ~isFactoryBean(...)~ 判断是否为 FactoryBean
      - ~destroyBean(...)~ 销毁 Bean
   7. ~ListableBeanFactory~ 定义了一些获取 Bean 清单的操作
      - ~getBeanDefinitionCount()~ 获取工厂中定义 BeanDefinition 的数量
      - ~getBeanDefinitionNames()~ 获取工厂定义的 BeanDefinition 名称

** Bean 定义的读取器: XmlBeanDefinitionReader
   ~XmlBeanDefinitionReader~ 是实现读取 BeanDefinition 的类，它的继承关系如下
   #+BEGIN_SRC text
     org.springframework.beans.factory.xml
     Class XmlBeanDefinitionReader

         java.lang.Object
             org.springframework.beans.factory.support.AbstractBeanDefinitionReader
                 org.springframework.beans.factory.xml.XmlBeanDefinitionReader

         All Implemented Interfaces:
             BeanDefinitionReader, org.springframework.core.env.EnvironmentCapable
   #+END_SRC

   这里说明一下重要的类和接口的作用
   1. ~AbstractBeanDefinitionReader~ 实现了对 BeanDefinition 的读取操作，它包含
      如下成员变量
      #+BEGIN_SRC java
        private final BeanDefinitionRegistry registry;
        private ResourceLoader resourceLoader;
        private ClassLoader beanClassLoader;
        private Environment environment;
        private BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;
      #+END_SRC
      - registry 表示 BeanDefinition 的注册类
      - resourceLoader 实现了资源加载
      - environment 实现了读取系统环境变量和 Java 属性
      - beanNameGenerator 是 beanName 生成器
   2. ~XmlBeanDefinitionReader~ 直接继承自 ~AbstractBeanDefinitionReader~, 增加了
      - ~DocumentLoader~ 将资源转化成 Document 对象功能
      - 添加了对 XML 的格式验证的方法
        + DTD (Document Type Definition) 验证
        + XSD (XML Schema Definition) 验证

** BeanDefinition 自动加载流程
   ~DefaultListableBeanFactory~ 类定义了存储 BeanDefinition 类的哈希表, 具体定义如下
   #+BEGIN_SRC java
      /** Map of bean definition objects, keyed by bean name. */
      private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

      /** Map of singleton and non-singleton bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);

      /** Map of singleton-only bean names, keyed by dependency type. */
      private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);

      /** List of bean definition names, in registration order. */
      private volatile List<String> beanDefinitionNames = new ArrayList<>(256);
   #+END_SRC

   最终 BeanDefinition 通过调用 ~registerBeanDefinition(...)~ 方法注册到
   ~beanDefinitionMap~ 中，代码的注释也写了是对 ~BeanDefinitionRegistry~ 的实现
   #+BEGIN_SRC java
     //---------------------------------------------------------------------
     // Implementation of BeanDefinitionRegistry interface
     //---------------------------------------------------------------------

     @Override
     public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
             throws BeanDefinitionStoreException {

         Assert.hasText(beanName, "Bean name must not be empty");
         Assert.notNull(beanDefinition, "BeanDefinition must not be null");

         if (beanDefinition instanceof AbstractBeanDefinition) {
             try {
                 ((AbstractBeanDefinition) beanDefinition).validate();
             }
             catch (BeanDefinitionValidationException ex) {
                 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                         "Validation of bean definition failed", ex);
             }
         }

         BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
         if (existingDefinition != null) {
             if (!isAllowBeanDefinitionOverriding()) {
                 throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
             }
             else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                 // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                 if (logger.isInfoEnabled()) {
                     logger.info("Overriding user-defined bean definition for bean '" + beanName +
                             "' with a framework-generated bean definition: replacing [" +
                             existingDefinition + "] with [" + beanDefinition + "]");
                 }
             }
             else if (!beanDefinition.equals(existingDefinition)) {
                 if (logger.isDebugEnabled()) {
                     logger.debug("Overriding bean definition for bean '" + beanName +
                             "' with a different definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             else {
                 if (logger.isTraceEnabled()) {
                     logger.trace("Overriding bean definition for bean '" + beanName +
                             "' with an equivalent definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             this.beanDefinitionMap.put(beanName, beanDefinition);
         }
         else {
             if (hasBeanCreationStarted()) {
                 // Cannot modify startup-time collection elements anymore (for stable iteration)
                 synchronized (this.beanDefinitionMap) {
                     this.beanDefinitionMap.put(beanName, beanDefinition);
                     List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                     updatedDefinitions.addAll(this.beanDefinitionNames);
                     updatedDefinitions.add(beanName);
                     this.beanDefinitionNames = updatedDefinitions;
                     removeManualSingletonName(beanName);
                 }
             }
             else {
                 // Still in startup registration phase
                 this.beanDefinitionMap.put(beanName, beanDefinition);
                 this.beanDefinitionNames.add(beanName);
                 removeManualSingletonName(beanName);
             }
             this.frozenBeanDefinitionNames = null;
         }

         if (existingDefinition != null || containsSingleton(beanName)) {
             resetBeanDefinition(beanName);
         }
     }
   #+END_SRC

   在 ~registerBeanDefinition(...)~ 方法中添加端点可以获得如下的调用栈
   #+BEGIN_SRC text
     registerBeanDefinition:914, DefaultListableBeanFactory (org.springframework.beans.factory.support)
     registerBeanDefinition:164, BeanDefinitionReaderUtils (org.springframework.beans.factory.support)
     processBeanDefinition:311, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     parseDefaultElement:197, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     parseBeanDefinitions:176, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     doRegisterBeanDefinitions:149, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     registerBeanDefinitions:96, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)
     registerBeanDefinitions:509, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     doLoadBeanDefinitions:389, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     loadBeanDefinitions:336, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     loadBeanDefinitions:305, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)
     loadBeanDefinitions:188, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:224, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:195, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:257, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)
     loadBeanDefinitions:128, AbstractXmlApplicationContext (org.springframework.context.support)
     loadBeanDefinitions:94, AbstractXmlApplicationContext (org.springframework.context.support)
     refreshBeanFactory:133, AbstractRefreshableApplicationContext (org.springframework.context.support)
     obtainFreshBeanFactory:637, AbstractApplicationContext (org.springframework.context.support)
     refresh:522, AbstractApplicationContext (org.springframework.context.support)
     <init>:144, ClassPathXmlApplicationContext (org.springframework.context.support)
     <init>:85, ClassPathXmlApplicationContext (org.springframework.context.support)
     main:10, MyApp01 (io.github.jeanhwea.app01)
   #+END_SRC

   观察调用栈可以得到 BeanDefinition 的加载步骤如下:
   1. 入口方法为 ~AbstractApplicationContext#refresh(...)~
   2. ~obtainFreshBeanFactory(...)~ 方法获取 BeanFactory 的同时需要注册
      BeanDefinition
   3. ~XmlBeanDefinitionReader#doLoadBeanDefinitions(...)~ 方法完成如下操作
      - 定义了 documentLoader 成员变量
        #+BEGIN_SRC java
          private DocumentLoader documentLoader = new DefaultDocumentLoader();
        #+END_SRC
      - 首先调用 ~doLoadDocument(inputSource, resource)~ 读取到 Document 对象
      - 然后调用 ~registerBeanDefinitions(doc, resource)~ 完成 BeanDefinition 的
        注册
   4. 调用 ~parseDefaultElement(...)~ 方法对默认元素进行解析
      - 对 import 类型标签解析
      - 对 alias 类型标签解析
      - 对 bean 类型标签解析
      - 对嵌套 bean 类型标签解析
   5. 接着对标签进行处理，最终交付到
      ~DefaultListableBeanFactory#registerBeanDefinition(...)~ 方法进行注册

** BeanDefinition 注册的实现
   ~DefaultListableBeanFactory~ 的 ~registerBeanDefinition(...)~ 才是真正实现注
   册 BeanDefinition 逻辑，其代码如下：
   1. 对 beanDefinition 进行验证
   2. 检查 beanDefinition 是否存在
      - 如果存在，判断是否覆盖对应的 BeanDefinition
      - 如果 beanDefinition 不存在，进行创建并注册
   #+BEGIN_SRC java
     //---------------------------------------------------------------------
     // Implementation of BeanDefinitionRegistry interface
     //---------------------------------------------------------------------

     @Override
     public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
             throws BeanDefinitionStoreException {

         Assert.hasText(beanName, "Bean name must not be empty");
         Assert.notNull(beanDefinition, "BeanDefinition must not be null");

         if (beanDefinition instanceof AbstractBeanDefinition) {
             try {
                 ((AbstractBeanDefinition) beanDefinition).validate();
             }
             catch (BeanDefinitionValidationException ex) {
                 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                         "Validation of bean definition failed", ex);
             }
         }

         BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
         if (existingDefinition != null) {
             if (!isAllowBeanDefinitionOverriding()) {
                 throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
             }
             else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                 // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                 if (logger.isInfoEnabled()) {
                     logger.info("Overriding user-defined bean definition for bean '" + beanName +
                             "' with a framework-generated bean definition: replacing [" +
                             existingDefinition + "] with [" + beanDefinition + "]");
                 }
             }
             else if (!beanDefinition.equals(existingDefinition)) {
                 if (logger.isDebugEnabled()) {
                     logger.debug("Overriding bean definition for bean '" + beanName +
                             "' with a different definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             else {
                 if (logger.isTraceEnabled()) {
                     logger.trace("Overriding bean definition for bean '" + beanName +
                             "' with an equivalent definition: replacing [" + existingDefinition +
                             "] with [" + beanDefinition + "]");
                 }
             }
             this.beanDefinitionMap.put(beanName, beanDefinition);
         }
         else {
             if (hasBeanCreationStarted()) {
                 // Cannot modify startup-time collection elements anymore (for stable iteration)
                 synchronized (this.beanDefinitionMap) {
                     this.beanDefinitionMap.put(beanName, beanDefinition);
                     List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                     updatedDefinitions.addAll(this.beanDefinitionNames);
                     updatedDefinitions.add(beanName);
                     this.beanDefinitionNames = updatedDefinitions;
                     removeManualSingletonName(beanName);
                 }
             }
             else {
                 // Still in startup registration phase
                 this.beanDefinitionMap.put(beanName, beanDefinition);
                 this.beanDefinitionNames.add(beanName);
                 removeManualSingletonName(beanName);
             }
             this.frozenBeanDefinitionNames = null;
         }

         if (existingDefinition != null || containsSingleton(beanName)) {
             resetBeanDefinition(beanName);
         }
     }
   #+END_SRC

   在上面注册过程中， ~hasBeanCreationStarted()~ 方法用于判断 Bean 是否开始创建，
   它实现逻辑在父类 ~AbstractBeanFactory~ 中
   #+BEGIN_SRC java
     /**
      ,* Check whether this factory's bean creation phase already started,
      ,* i.e. whether any bean has been marked as created in the meantime.
      ,* @since 4.2.2
      ,* @see #markBeanAsCreated
      ,*/
     protected boolean hasBeanCreationStarted() {
         return !this.alreadyCreated.isEmpty();
     }
   #+END_SRC

   父类 ~AbstractBeanFactory~ 中定义了一个集合记录正在创建的 Bean
   #+BEGIN_SRC java
     /** Names of beans that have already been created at least once. */
     private final Set<String> alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap<>(256));
   #+END_SRC

   创建时通过 ~markBeanAsCreated(...)~ 方法标记，注意对 ~alreadyCreated~ 的访问
   是需要加锁的
   #+BEGIN_SRC java
     /**
      ,* Mark the specified bean as already created (or about to be created).
      ,* <p>This allows the bean factory to optimize its caching for repeated
      ,* creation of the specified bean.
      ,* @param beanName the name of the bean
      ,*/
     protected void markBeanAsCreated(String beanName) {
         if (!this.alreadyCreated.contains(beanName)) {
             synchronized (this.mergedBeanDefinitions) {
                 if (!this.alreadyCreated.contains(beanName)) {
                     // Let the bean definition get re-merged now that we're actually creating
                     // the bean... just in case some of its metadata changed in the meantime.
                     clearMergedBeanDefinition(beanName);
                     this.alreadyCreated.add(beanName);
                 }
             }
         }
     }
   #+END_SRC

** BeanDefinition 移除的实现
   BeanDefinition 的移除方法如下，通过 ~removeBeanDefinition(...)~ 方法
   #+BEGIN_SRC java
     @Override
     public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
         Assert.hasText(beanName, "'beanName' must not be empty");

         BeanDefinition bd = this.beanDefinitionMap.remove(beanName);
         if (bd == null) {
             if (logger.isTraceEnabled()) {
                 logger.trace("No bean named '" + beanName + "' found in " + this);
             }
             throw new NoSuchBeanDefinitionException(beanName);
         }

         if (hasBeanCreationStarted()) {
             // Cannot modify startup-time collection elements anymore (for stable iteration)
             synchronized (this.beanDefinitionMap) {
                 List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);
                 updatedDefinitions.remove(beanName);
                 this.beanDefinitionNames = updatedDefinitions;
             }
         }
         else {
             // Still in startup registration phase
             this.beanDefinitionNames.remove(beanName);
         }
         this.frozenBeanDefinitionNames = null;

         resetBeanDefinition(beanName);
     }
   #+END_SRC

   移除 BeanDefinition 中调用了刷新 BeanDefinition 的方法
   ~resetBeanDefinition(...)~
   #+BEGIN_SRC java
     /**
      ,* Reset all bean definition caches for the given bean,
      ,* including the caches of beans that are derived from it.
      ,* <p>Called after an existing bean definition has been replaced or removed,
      ,* triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}
      ,* and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the
      ,* given bean and on all bean definitions that have the given bean as parent.
      ,* @param beanName the name of the bean to reset
      ,* @see #registerBeanDefinition
      ,* @see #removeBeanDefinition
      ,*/
     protected void resetBeanDefinition(String beanName) {
         // Remove the merged bean definition for the given bean, if already created.
         clearMergedBeanDefinition(beanName);

         // Remove corresponding bean from singleton cache, if any. Shouldn't usually
         // be necessary, rather just meant for overriding a context's default beans
         // (e.g. the default StaticMessageSource in a StaticApplicationContext).
         destroySingleton(beanName);

         // Notify all post-processors that the specified bean definition has been reset.
         for (BeanPostProcessor processor : getBeanPostProcessors()) {
             if (processor instanceof MergedBeanDefinitionPostProcessor) {
                 ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);
             }
         }

         // Reset all bean definitions that have the given bean as parent (recursively).
         for (String bdName : this.beanDefinitionNames) {
             if (!beanName.equals(bdName)) {
                 BeanDefinition bd = this.beanDefinitionMap.get(bdName);
                 // Ensure bd is non-null due to potential concurrent modification
                 // of the beanDefinitionMap.
                 if (bd != null && beanName.equals(bd.getParentName())) {
                     resetBeanDefinition(bdName);
                 }
             }
         }
     }
   #+END_SRC

** BeanDefinition 获取的实现
   ~DefaultListableBeanFactory~ 的实现获取 BeanDefinition 的逻辑如下
   #+BEGIN_SRC java
     @Override
     public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
         BeanDefinition bd = this.beanDefinitionMap.get(beanName);
         if (bd == null) {
             if (logger.isTraceEnabled()) {
                 logger.trace("No bean named '" + beanName + "' found in " + this);
             }
             throw new NoSuchBeanDefinitionException(beanName);
         }
         return bd;
     }
   #+END_SRC

** ~<bean/>~ 标签解析
   之前在 BeanDefinition 自动加载流程中忽略了对 ~<bean/>~ 标签的解析，其核心实现
   逻辑 ~BeanDefinitionDocumentReader~ 类中的 ~processBeanDefinition(...)~ 方法
   #+BEGIN_SRC java
     /**
      ,* Process the given bean element, parsing the bean definition
      ,* and registering it with the registry.
      ,*/
     protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
         BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
         if (bdHolder != null) {
             bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
             try {
                 // Register the final decorated instance.
                 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
             }
             catch (BeanDefinitionStoreException ex) {
                 getReaderContext().error("Failed to register bean definition with name '" +
                         bdHolder.getBeanName() + "'", ele, ex);
             }
             // Send registration event.
             getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
         }
     }
   #+END_SRC

   可以看出对 XML 标签的解析核心逻辑为 ~parseBeanDefinitionElement(...)~
   #+BEGIN_SRC java
     /**
      ,* Parses the supplied {@code <bean>} element. May return {@code null}
      ,* if there were errors during parse. Errors are reported to the
      ,* {@link org.springframework.beans.factory.parsing.ProblemReporter}.
      ,*/
     @Nullable
     public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
         String id = ele.getAttribute(ID_ATTRIBUTE);
         String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

         List<String> aliases = new ArrayList<>();
         if (StringUtils.hasLength(nameAttr)) {
             String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
             aliases.addAll(Arrays.asList(nameArr));
         }

         String beanName = id;
         if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
             beanName = aliases.remove(0);
             if (logger.isTraceEnabled()) {
                 logger.trace("No XML 'id' specified - using '" + beanName +
                         "' as bean name and " + aliases + " as aliases");
             }
         }

         if (containingBean == null) {
             checkNameUniqueness(beanName, aliases, ele);
         }

         AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
         if (beanDefinition != null) {
             if (!StringUtils.hasText(beanName)) {
                 try {
                     if (containingBean != null) {
                         beanName = BeanDefinitionReaderUtils.generateBeanName(
                                 beanDefinition, this.readerContext.getRegistry(), true);
                     }
                     else {
                         beanName = this.readerContext.generateBeanName(beanDefinition);
                         // Register an alias for the plain bean class name, if still possible,
                         // if the generator returned the class name plus a suffix.
                         // This is expected for Spring 1.2/2.0 backwards compatibility.
                         String beanClassName = beanDefinition.getBeanClassName();
                         if (beanClassName != null &&
                                 beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                                 !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                             aliases.add(beanClassName);
                         }
                     }
                     if (logger.isTraceEnabled()) {
                         logger.trace("Neither XML 'id' nor 'name' specified - " +
                                 "using generated bean name [" + beanName + "]");
                     }
                 }
                 catch (Exception ex) {
                     error(ex.getMessage(), ele);
                     return null;
                 }
             }
             String[] aliasesArray = StringUtils.toStringArray(aliases);
             return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
         }

         return null;
     }
   #+END_SRC

* Bean 实现原理
** Bean 的生命周期
   ~BeanFactory~ 的注释中完整地说明的实现标准 BeanFactory 的代码
   1. BeanFactory 初始化过程，支持的标准 Bean 的生命周期
      - ~BeanNameAware#setBeanName(...)~
      - ~BeanClassLoaderAware#setBeanClassLoader(...)~
      - ~BeanFactoryAware#setBeanFactory(...)~
      - ~EnvironmentAware#setEnvironment(...)~
      - ~EmbeddedValueResolverAware#setEmbeddedValueResolver(...)~
      - ~ResourceLoaderAware#setResourceLoader(...)~ 在 ApplicationContext 中
      - ~ApplicationEventPublisherAware#setApplicationEventPublisher(...)~ 在
        ApplicationContext 中
      - ~MessageSourceAware#setMessageSource(...)~ 在 ApplicationContext 中
      - ~ApplicationContextAware#setApplicationContext(...)~ 在
        ApplicationContext 中
      - ~ServletContextAware#setServletContext(...)~ 在 ApplicationContext 中
      - ~BeanPostProcessors~ 的一系列 ~postProcessBeforeInitialization(...)~ 方法
      - ~InitializingBean#afterPropertiesSet(...)~
      - a custom init-method definition
      - ~BeanPostProcessors~ 的一系列 ~postProcessAfterInitialization(...)~ 方法
   2. 关闭 BeanFactory 时，执行的 Bean 销毁方法
      - ~DestructionAwareBeanPostProcessors~ 的一系列
        ~postProcessBeforeDestruction(...)~ 方法
      - ~DisposableBean#destroy(...)~
      - a custom destroy-method definition

** Bean 的流程分析
   实例化 Bean 的方法为 ~BeanUtils#instantiateClass(...)~, 先添加断点获取调用栈
   #+BEGIN_SRC text
     instantiateClass:185, BeanUtils (org.springframework.beans)
     instantiate:87, SimpleInstantiationStrategy (org.springframework.beans.factory.support)
     instantiateBean:1312, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     createBeanInstance:1214, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     doCreateBean:557, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     createBean:517, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)
     lambda$doGetBean$0:323, AbstractBeanFactory (org.springframework.beans.factory.support)
     getObject:-1, 1027007693 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$29)
     getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)
     doGetBean:321, AbstractBeanFactory (org.springframework.beans.factory.support)
     getBean:207, AbstractBeanFactory (org.springframework.beans.factory.support)
     invokeBeanFactoryPostProcessors:89, PostProcessorRegistrationDelegate (org.springframework.context.support)
     invokeBeanFactoryPostProcessors:706, AbstractApplicationContext (org.springframework.context.support)
     refresh:532, AbstractApplicationContext (org.springframework.context.support)
     main:18, MyApp02 (io.github.jeanhwea.app02)
   #+END_SRC

   先分析调用栈，可以知道创建 Bean 的入口是 ~refresh()~ 方法的
   ~invokeBeanFactoryPostProcessors()~ 方法，这里牵扯到几个核心的方法
   1. ~AbstractApplicationContext#refresh()~
   2. ~AbstractBeanFactory#doGetBean(...)~
   3. ~AbstractAutowireCapableBeanFactory#instantiateBean(...)~

*** 实例化 Bean: ~instantiateBean()~ 方法
    ~instantiateBean(...)~ 实例化 Bean 主要完成如下工作
    1. 使用 InstantiationStrategy 实例化策略来实例化 Bean, Spring 中创建 Bean 有如
       下两种方式
       - 通过 ~BeanUtils.instantiateClass()~ 方法创建实例
       - 通过 ~new CglibSubclassCreator(bd, owner).instantiate(ctor, args)~ 方式
         进行创建
    2. 添加 BeanWrapper 封装 Bean 对象
       - 实现类为 ~BeanWrapperImpl~
       - ~BeanWrapperImpl~ 继承自 ~AbstractNestablePropertyAccessor~
       - ~AbstractNestablePropertyAccessor#setPropertyValue(...)~ 方法设置属性值
    #+BEGIN_SRC java
      /**
       ,* Instantiate the given bean using its default constructor.
       ,* @param beanName the name of the bean
       ,* @param mbd the bean definition for the bean
       ,* @return a BeanWrapper for the new instance
       ,*/
      protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
          try {
              Object beanInstance;
              final BeanFactory parent = this;
              if (System.getSecurityManager() != null) {
                  beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
                          getInstantiationStrategy().instantiate(mbd, beanName, parent),
                          getAccessControlContext());
              }
              else {
                  beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
              }
              BeanWrapper bw = new BeanWrapperImpl(beanInstance);
              initBeanWrapper(bw);
              return bw;
          }
          catch (Throwable ex) {
              throw new BeanCreationException(
                      mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
          }
      }
    #+END_SRC

*** 获取 Bean 实例: ~doGetBean()~ 方法
    ~doGetBean(...)~ 方法是获取 Bean 的最终处理函数，它的逻辑比较复杂，可以分成
    以下流程
    1. 获取 beanName
       - 解析带有别名的 Bean 到最终的名称
       - 去除 FactoryBean 的修饰符，即 ~&~ 前缀
    2. 缓存获取
       - 调用 ~DefaultSingletonBeanRegistry#getSingleton()~ 尝试从单例容器缓存中
         获取
       - 单例 Bean 只创建一次，创建完成直接放入缓存，参考
         ~DefaultSingletonBeanRegistry~ 的实现
       - 依赖的 Bean 避免循环依赖，只记录 ~ObjectFactory~ 对象, 参考
         ~singletonFactories~ 变量的定义及循环依赖的解决方法
    3. 创建 Bean 实例
       - 获取 FactoryBean 生成的 Bean 实例
         + FactoryBean 的实例是 ~factory-method~ 返回的 Bean, 后面称为
           beanInstance
         + ~getObjectForBeanInstance()~ 方法实现了获取 beanInstance 的逻辑
       - 如果不是 FactoryBean
         + 调用 ~isPrototypeCurrentlyInCreation(...)~ 判断创建原型 Bean 是否出现
           循环依赖
         + 尝试从 parentBeanFactory 中获取 Bean
         + 将 BeanDefinition 进行合并，得到 ~RootBeanDefinition~, 并检验
         + 调用 ~markBeanAsCreated()~ 方法标记创建 Bean
         + 解决 Bean 依赖
           - Bean 是动态加载的，当前待创建 Bean 的可能存在依赖项
           - 解决依赖的策略是顺序寻找出所有依赖，并完成创建
         + 通过不同的 scope 完成对应 Bean 的创建
           - 单例 Bean 创建: ~getSingleton(...)~
           - 原型 Bean 创建: ~getSingleton(...)~
           - 其它情况 Bean 创建，例如： ~@RequestScope~ ~@SessionScope~ 等
    4. 检查 Bean 实例，完成类型转换
    #+BEGIN_SRC java
      /**
       ,* Return an instance, which may be shared or independent, of the specified bean.
       ,* @param name the name of the bean to retrieve
       ,* @param requiredType the required type of the bean to retrieve
       ,* @param args arguments to use when creating a bean instance using explicit arguments
       ,* (only applied when creating a new instance as opposed to retrieving an existing one)
       ,* @param typeCheckOnly whether the instance is obtained for a type check,
       ,* not for actual use
       ,* @return an instance of the bean
       ,* @throws BeansException if the bean could not be created
       ,*/
      @SuppressWarnings("unchecked")
      protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
              @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

          final String beanName = transformedBeanName(name);
          Object bean;

          // Eagerly check singleton cache for manually registered singletons.
          Object sharedInstance = getSingleton(beanName);
          if (sharedInstance != null && args == null) {
              if (logger.isTraceEnabled()) {
                  if (isSingletonCurrentlyInCreation(beanName)) {
                      logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                              "' that is not fully initialized yet - a consequence of a circular reference");
                  }
                  else {
                      logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                  }
              }
              bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
          }

          else {
              // Fail if we're already creating this bean instance:
              // We're assumably within a circular reference.
              if (isPrototypeCurrentlyInCreation(beanName)) {
                  throw new BeanCurrentlyInCreationException(beanName);
              }

              // Check if bean definition exists in this factory.
              BeanFactory parentBeanFactory = getParentBeanFactory();
              if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
                  // Not found -> check parent.
                  String nameToLookup = originalBeanName(name);
                  if (parentBeanFactory instanceof AbstractBeanFactory) {
                      return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                              nameToLookup, requiredType, args, typeCheckOnly);
                  }
                  else if (args != null) {
                      // Delegation to parent with explicit args.
                      return (T) parentBeanFactory.getBean(nameToLookup, args);
                  }
                  else if (requiredType != null) {
                      // No args -> delegate to standard getBean method.
                      return parentBeanFactory.getBean(nameToLookup, requiredType);
                  }
                  else {
                      return (T) parentBeanFactory.getBean(nameToLookup);
                  }
              }

              if (!typeCheckOnly) {
                  markBeanAsCreated(beanName);
              }

              try {
                  final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                  checkMergedBeanDefinition(mbd, beanName, args);

                  // Guarantee initialization of beans that the current bean depends on.
                  String[] dependsOn = mbd.getDependsOn();
                  if (dependsOn != null) {
                      for (String dep : dependsOn) {
                          if (isDependent(beanName, dep)) {
                              throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                      "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                          }
                          registerDependentBean(dep, beanName);
                          try {
                              getBean(dep);
                          }
                          catch (NoSuchBeanDefinitionException ex) {
                              throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                      "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                          }
                      }
                  }

                  // Create bean instance.
                  if (mbd.isSingleton()) {
                      sharedInstance = getSingleton(beanName, () -> {
                          try {
                              return createBean(beanName, mbd, args);
                          }
                          catch (BeansException ex) {
                              // Explicitly remove instance from singleton cache: It might have been put there
                              // eagerly by the creation process, to allow for circular reference resolution.
                              // Also remove any beans that received a temporary reference to the bean.
                              destroySingleton(beanName);
                              throw ex;
                          }
                      });
                      bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                  }

                  else if (mbd.isPrototype()) {
                      // It's a prototype -> create a new instance.
                      Object prototypeInstance = null;
                      try {
                          beforePrototypeCreation(beanName);
                          prototypeInstance = createBean(beanName, mbd, args);
                      }
                      finally {
                          afterPrototypeCreation(beanName);
                      }
                      bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                  }

                  else {
                      String scopeName = mbd.getScope();
                      final Scope scope = this.scopes.get(scopeName);
                      if (scope == null) {
                          throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                      }
                      try {
                          Object scopedInstance = scope.get(beanName, () -> {
                              beforePrototypeCreation(beanName);
                              try {
                                  return createBean(beanName, mbd, args);
                              }
                              finally {
                                  afterPrototypeCreation(beanName);
                              }
                          });
                          bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                      }
                      catch (IllegalStateException ex) {
                          throw new BeanCreationException(beanName,
                                  "Scope '" + scopeName + "' is not active for the current thread; consider " +
                                  "defining a scoped proxy for this bean if you intend to refer to it from a singleton",
                                  ex);
                      }
                  }
              }
              catch (BeansException ex) {
                  cleanupAfterBeanCreationFailure(beanName);
                  throw ex;
              }
          }

          // Check if required type matches the type of the actual bean instance.
          if (requiredType != null && !requiredType.isInstance(bean)) {
              try {
                  T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                  if (convertedBean == null) {
                      throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                  }
                  return convertedBean;
              }
              catch (TypeMismatchException ex) {
                  if (logger.isTraceEnabled()) {
                      logger.trace("Failed to convert bean '" + name + "' to required type '" +
                              ClassUtils.getQualifiedName(requiredType) + "'", ex);
                  }
                  throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
              }
          }
          return (T) bean;
      }
    #+END_SRC
** FactoryBean
   FactoryBean 不同于普通的 Bean， FactoryBean 自身就是一个组装 Bean 的微型工厂，
   即在调用 ~BeanFactory#getBean(...)~ 方法时不返回 FactoryBean，而是返回工厂方
   法返回的 Bean，定义 FactoryBean 只需要实现 ~FactoryBean~ 接口即可

   #+BEGIN_SRC java
     public interface FactoryBean<T> {
         @Nullable
         T getObject() throws Exception;

         @Nullable
         Class<?> getObjectType();

         default boolean isSingleton() {
             return true;
         }
     }
   #+END_SRC
   1. ~getObject(...)~ 方法返回 FactoryBean 创建的实例，也称工厂方法
   2. ~getObjectType(...)~ 方法返回 FactoryBean 创建的实例的类型
   3. ~isSingleton(...)~ 方法返回FactoryBean创建的实例的Scope

* IoC
** IoC 核心接口和类
   Spring 的 IoC 容器对象一般继承自 ~ApplicationContext~ 接口，常见的对象类如下

   ~ClassPathXmlApplicationContext~: 读取 ClassPath 中 XML 配置文件的 Bean 定义
   的容器

   #+BEGIN_SRC text
     org.springframework.context.support
     Class ClassPathXmlApplicationContext

         java.lang.Object
             org.springframework.core.io.DefaultResourceLoader
                 org.springframework.context.support.AbstractApplicationContext
                     org.springframework.context.support.AbstractRefreshableApplicationContext
                         org.springframework.context.support.AbstractRefreshableConfigApplicationContext
                             org.springframework.context.support.AbstractXmlApplicationContext
                                 org.springframework.context.support.ClassPathXmlApplicationContext

         All Implemented Interfaces:
             Closeable, AutoCloseable, org.springframework.beans.factory.Aware,
             org.springframework.beans.factory.BeanFactory,
             org.springframework.beans.factory.BeanNameAware,
             org.springframework.beans.factory.HierarchicalBeanFactory,
             org.springframework.beans.factory.InitializingBean,
             org.springframework.beans.factory.ListableBeanFactory,
             ApplicationContext, ApplicationEventPublisher,
             ConfigurableApplicationContext, Lifecycle, MessageSource,
             org.springframework.core.env.EnvironmentCapable,
             org.springframework.core.io.ResourceLoader,
             org.springframework.core.io.support.ResourcePatternResolver
   #+END_SRC

   ~AnnotationConfigApplicationContext~: 读取注解 Bean 定义的容器

   #+BEGIN_SRC text
     org.springframework.context.annotation
     Class AnnotationConfigApplicationContext

         java.lang.Object
             org.springframework.core.io.DefaultResourceLoader
                 org.springframework.context.support.AbstractApplicationContext
                     org.springframework.context.support.GenericApplicationContext
                         org.springframework.context.annotation.AnnotationConfigApplicationContext

         All Implemented Interfaces:
             Closeable, AutoCloseable,
             org.springframework.beans.factory.BeanFactory,
             org.springframework.beans.factory.HierarchicalBeanFactory,
             org.springframework.beans.factory.ListableBeanFactory,
             org.springframework.beans.factory.support.BeanDefinitionRegistry,
             AnnotationConfigRegistry, ApplicationContext,
             ApplicationEventPublisher, ConfigurableApplicationContext,
             Lifecycle, MessageSource, org.springframework.core.AliasRegistry,
             org.springframework.core.env.EnvironmentCapable,
             org.springframework.core.io.ResourceLoader,
             org.springframework.core.io.support.ResourcePatternResolver
   #+END_SRC

   常见的类简单可以分成以下几类
   1. 资源处理
      - ~Resource~ Spring 中关于资源的定义
      - ~ResourceLoader~ 提供资源加载方法
      - ~BeanDefinitionReader~ 读取接口主要用来读取信息
   2. 注册形式，在 Spring 中关于注册的几个核心
      - ~AliasRegistry~ 别名注册
      - ~BeanDefinitionRegistry~ Bean 定义注册
      - ~SingletonBeanRegistry~ 单例 Bean 注册
        + ~DefaultSingletonBeanRegistry~
   3. 生命周期，可以分成容器生命周期和 Bean 生命周期两个小类
      - ~Lifecycle~ 容器生命周期的核心接口
      - ~InitializingBean~, ~DisposableBean~ 等 Bean 的生命周期接口
   4. Bean 拓展
      - ~BeanPostProcessor~
      - ~Aware~ 系列接口
   5. 上下文的接口:
      - ~ApplicationContext~ 作为主导接口
        - ~AbstractApplicationContext~

* ApplicationContext

* AOP
  使用动态代理实现
  - JDK 代理
  - cglib 代理

* Spring 核心类梳理
  1. ApplicationContext
     - AbstractApplicationContext
       + ~refresh()~ 实现 Spring Bean 加载的核心逻辑
  2. BeanDefinition
     - AbstractBeanDefinition
  3. BeanDefinitionReader
     - 读取 BeanDefinition 对象
  4. BeanFactory
     - Bean 工厂类
     - AbstractBeanFactory
       + ~doGetBean(...)~
  5. BeanFactoryPostProcessor
     - 函数式接口 ~@FunctionalInterface~
  6. BeanPostProcessor
     - 提供自定义 Bean 实例化的处理接口扩展
     - ~postProcessBeforeInitialization(Object bean, String beanName)~
       + Bean 实例化前置处理方法
     - ~postProcessAfterInitialization(Object bean, String beanName)~
       + Bean 实例化后置处理方法

* SpringBoot 自动装配
* 参考链接
  1. [[https://huifer.github.io/spring-analysis/][Spring Analysis]]
